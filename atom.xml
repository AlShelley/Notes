<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[lonelyorのblog]]></title>
  <link href="www.lonelyor.org/lonelyorNotes/atom.xml" rel="self"/>
  <link href="www.lonelyor.org/lonelyorNotes/"/>
  <updated>2019-01-13T23:05:45+08:00</updated>
  <id>www.lonelyor.org/lonelyorNotes/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[十大经典排序算法（动图演示）]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15474694746707.html"/>
    <updated>2019-01-14T20:37:54+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15474694746707.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>转载自：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
</blockquote>

<h2 id="toc_0">0、算法概述</h2>

<h3 id="toc_1">0.1 算法分类</h3>

<p>十种常见排序算法可以分为两大类：</p>

<blockquote>
<p>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p>

<p>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p>
</blockquote>

<p><img src="media/15474694746707/15474696026744.jpg" alt=""/></p>

<h3 id="toc_2">0.2 算法复杂度</h3>

<p><img src="media/15474694746707/15474696174505.jpg" alt=""/></p>

<h3 id="toc_3">0.3 相关概念</h3>

<blockquote>
<p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p>

<p>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p>

<p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p>

<p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p>
</blockquote>

<h2 id="toc_4">1、冒泡排序（Bubble Sort）</h2>

<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>

<h3 id="toc_5">1.1 算法描述</h3>

<p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br/>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br/>
针对所有的元素重复以上的步骤，除了最后一个；<br/>
重复步骤1~3，直到排序完成。</p>

<h3 id="toc_6">1.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="" width="681" height="212">
<h3 id="toc_7">1.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre>

<h2 id="toc_8">2、选择排序（Selection Sort）</h2>

<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>

<h3 id="toc_9">2.1 算法描述</h3>

<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>

<p>初始状态：无序区为R[1..n]，有序区为空；<br/>
第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br/>
n-1趟结束，数组有序化了。<br/>
2.2 动图演示<br/>
　　<br/>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="" width="684" height="209"></p>

<h3 id="toc_10">2.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
</code></pre>

<h3 id="toc_11">2.4 算法分析</h3>

<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>

<h2 id="toc_12">3、插入排序（Insertion Sort）</h2>

<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>

<h3 id="toc_13">3.1 算法描述</h3>

<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>

<p>从第一个元素开始，该元素可以认为已经被排序；<br/>
取出下一个元素，在已经排序的元素序列中从后向前扫描；<br/>
如果该元素（已排序）大于新元素，将该元素移到下一位置；<br/>
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br/>
将新元素插入到该位置后；<br/>
重复步骤2~5。</p>

<h3 id="toc_14">3.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="" width="671" height="418">
<h3 id="toc_15">3.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
</code></pre>

<h3 id="toc_16">3.4 算法分析</h3>

<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>

<h2 id="toc_17">4、希尔排序（Shell Sort）</h2>

<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>

<h3 id="toc_18">4.1 算法描述</h3>

<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>

<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br/>
按增量序列个数k，对序列进行k 趟排序；<br/>
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>

<h3 id="toc_19">4.2 动图演示</h3>
<img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt="">
<h3 id="toc_20">4.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while (gap &lt; len / 3) {          // 动态定义间隔序列
        gap = gap * 3 + 1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
    return arr;
}
</code></pre>

<h3 id="toc_21">4.4 算法分析</h3>

<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p>

<h2 id="toc_22">5、归并排序（Merge Sort）</h2>

<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>

<h3 id="toc_23">5.1 算法描述</h3>

<p>把长度为n的输入序列分成两个长度为n/2的子序列；<br/>
对这两个子序列分别采用归并排序；<br/>
将两个排序好的子序列合并成一个最终的排序序列。</p>

<h3 id="toc_24">5.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="" width="678" height="422">
<h2 id="toc_25">5.3 代码实现</h2>

<pre class="line-numbers"><code class="language-text">function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if (len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length&gt;0 &amp;&amp; right.length&gt;0) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
</code></pre>

<h3 id="toc_26">5.4 算法分析</h3>

<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>

<h2 id="toc_27">6、快速排序（Quick Sort）</h2>

<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>

<h3 id="toc_28">6.1 算法描述</h3>

<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>

<p>从数列中挑出一个元素，称为 “基准”（pivot）；<br/>
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br/>
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>

<h3 id="toc_29">6.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="" width="682" height="212">
<h3 id="toc_30">6.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;
 
    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre>

<h2 id="toc_31">7、堆排序（Heap Sort）</h2>

<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>

<h3 id="toc_32">7.1 算法描述</h3>

<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br/>
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br/>
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>

<h3 id="toc_33">7.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" alt="">
<h3 id="toc_34">7.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}
 
function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }
 
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
</code></pre>

<h2 id="toc_35">8、计数排序（Counting Sort）</h2>

<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>

<h3 id="toc_36">8.1 算法描述</h3>

<p>找出待排序的数组中最大和最小的元素；<br/>
统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br/>
对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br/>
反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>

<h3 id="toc_37">8.2 动图演示</h3>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" alt="" width="690" height="380">
<h3 id="toc_38">8.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;
 
    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
 
    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
 
    return arr;
}
</code></pre>

<h3 id="toc_39">8.4 算法分析</h3>

<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>

<h2 id="toc_40">9、桶排序（Bucket Sort）</h2>

<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>

<h3 id="toc_41">9.1 算法描述</h3>

<p>设置一个定量的数组当作空桶；<br/>
遍历输入数据，并且把数据一个一个放到对应的桶里去；<br/>
对每个不是空的桶进行排序；<br/>
从不是空的桶里把排好序的数据拼接起来。 </p>

<h3 id="toc_42">9.2 图片演示</h3>

<p><img src="media/15474694746707/15474703458460.jpg" alt=""/></p>

<h3 id="toc_43">9.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] &gt; maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
    var buckets = new Array(bucketCount);
    for (i = 0; i &lt; buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i &lt; arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i &lt; buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j &lt; buckets[i].length; j++) {
            arr.push(buckets[i][j]);                     
        }
    }
 
    return arr;
}
</code></pre>

<h3 id="toc_44">9.4 算法分析</h3>

<p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>

<h2 id="toc_45">10、基数排序（Radix Sort）</h2>

<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>

<h3 id="toc_46">10.1 算法描述</h3>

<p>取得数组中的最大数，并取得位数；<br/>
arr为原始数组，从最低位开始取每个位组成radix数组；<br/>
对radix进行计数排序（利用计数排序适用于小范围数的特点）；<br/>
10.2 动图演示</p>
<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" alt="" width="686" height="389">
<h3 id="toc_47">10.3 代码实现</h3>

<pre class="line-numbers"><code class="language-text">// LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j &lt; arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
</code></pre>

<h3 id="toc_48">10.4 算法分析</h3>

<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>

<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给网站嵌入百度搜索框]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15473910152747.html"/>
    <updated>2019-01-13T22:50:15+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15473910152747.html</id>
    <content type="html"><![CDATA[
<p>只需要在 htm 页面中嵌入以下代码即可：</p>

<pre class="line-numbers"><code class="language-markup"> &lt;div style=&#39;overflow:hidden&#39;&gt;
        &lt;form onsubmit=&quot;return baiduWithHttps(this)&quot; action=&quot;http://www.baidu.com/s&quot; target=&quot;_blank&quot;&gt;
        &lt;input class=&#39;bdtext&#39; type=&quot;text&quot;  onfocus=&quot;checkHttps&quot; name=&quot;wd&quot;  size=&quot;30&quot;&gt;
        &lt;input class=&#39;bdbtn&#39; type=&quot;submit&quot;value=&quot;百度搜索&quot;&gt;
        &lt;/form&gt;
        &lt;script&gt;
            function checkHttps () {
                BaiduHttps.useHttps();    
            };
            function baiduWithHttps (formname) {
                var data = BaiduHttps.useHttps();
                if (data.s === 0) {
                    return true;
                }
                else {
                    formname.action = &#39;https://www.baidu.com/s&#39; + &#39;?wd&#39; + data.ssl_code;
                    return true;
                }
            };
        &lt;/script&gt; 
    &lt;/div&gt;
</code></pre>

<p>效果如下：<br/>
<img src="media/15473910152747/%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2.png" alt="嵌入百度搜索"/><br/>
觉得不好看的可以自行加入 css 改变样式，我觉得就这样还蛮好看的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vscode 快速生成 html 代码]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15473903423452.html"/>
    <updated>2019-01-13T22:39:02+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15473903423452.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>参考的博客如下：<br/>
<a href="https://blog.csdn.net/weixin_42659625/article/details/82941394">https://blog.csdn.net/weixin_42659625/article/details/82941394</a><br/>
图是直接复制的别人博客的图</p>
</blockquote>

<p>1、首先创建一个 html 文件如：index.html<br/>
2、在编辑器中输入感叹号（！）<br/>
3、此时会弹出下拉项，直接在感叹号❗️上回车即可。<br/>
<img src="media/15473903423452/15473904287496.jpg" alt=""/><br/>
4、自动生成的html 代码如下：<br/>
<img src="media/15473903423452/15473904546232.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[msf更新]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15473524859484.html"/>
    <updated>2019-01-13T12:08:05+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15473524859484.html</id>
    <content type="html"><![CDATA[
<p>1、打开终端输入 msf 进入msfconsole<br/>
2、在 msfconsole 中输入 msfupdate 即可自动更新</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读 Monyer 文章有感]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15473464131197.html"/>
    <updated>2019-01-13T10:26:53+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15473464131197.html</id>
    <content type="html"><![CDATA[
<p>1、黑客是一种兴趣爱好<br/>
2、选行需谨慎，选前需要调研<br/>
3、技术分化，很难再&quot;全栈&quot;，知识面扩宽的同时，需要抓重点精深。<br/>
4、技术人员发展路线：技术输出阶段、经验输出阶段、思路输出阶段和决策输出阶段。<br/>
5、学习永不停歇<br/>
6、小游戏地址：<a href="http://monyer.com/game/game1/">http://monyer.com/game/game1/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改Mac主机名、计算机名]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15470313638273.html"/>
    <updated>2019-01-09T18:56:03+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15470313638273.html</id>
    <content type="html"><![CDATA[
<p><code>$sudo scutil --set ComputerName 你想要的计算机名称</code><br/>
<code>$sudo scutil --set HostName 你想要的主机名称</code></p>

<p>举例：<br/>
<code>$sudo scutil --set HostName lonelyor</code></p>

<p>使用以下命令查看主机名或计算机名<br/>
<code>$ scutil --get ComputerName</code><br/>
<code>$ scutil --get HostName</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用python快速搭建ftp服务器]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15468702076334.html"/>
    <updated>2019-01-07T22:10:07+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15468702076334.html</id>
    <content type="html"><![CDATA[
<p>使用第三方库：pyftpdlib<br/>
安装库：pip3 install pyftpdlib<br/>
其他依赖项：<br/>
<code>pip3 install PyOpenSSL</code> 用来支持ftps。<br/>
<code>pip3 install pysendfile</code> 用来在unix上加速上传（服务器到客户端）。<br/>
安装python库的时候要注意大小写。</p>

<p>后面的事情就是看官方示例，然后copy了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将网页保存为PDF]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15457897865747.html"/>
    <updated>2018-12-26T10:03:06+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15457897865747.html</id>
    <content type="html"><![CDATA[
<p>如果使用 google chrome 则不需要任何辅助工具即可做到。<br/>
Mac用户使用cmd+p即可；<br/>
Windows用户使用ctrl+p即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自建kms服务器激活windows]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15456175398128.html"/>
    <updated>2018-12-24T10:12:19+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15456175398128.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>kms的脚本来自：<a href="https://github.com/SystemRage/py-kms">https://github.com/SystemRage/py-kms</a><br/>
密钥来自：<br/>
<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj612867(v%3dws.11)">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj612867(v%3dws.11)</a><br/>
<a href="https://github.com/SystemRage/py-kms/wiki/Office-GVLK-Keys">https://github.com/SystemRage/py-kms/wiki/Office-GVLK-Keys</a><br/>
<a href="https://github.com/SystemRage/py-kms/wiki/Windows-GVLK-Keys">https://github.com/SystemRage/py-kms/wiki/Windows-GVLK-Keys</a></p>
</blockquote>

<h2 id="toc_0">下载kms服务端和客户端程序</h2>

<p>分别在服务器和客户端下载py-kms<br/>
<code>git clone https://github.com/SystemRage/py-kms.git</code></p>

<h2 id="toc_1">服务器设置</h2>

<p>使用python3</p>

<pre class="line-numbers"><code class="language-text">python3 -m pip install argparse
python3 -m pip install tzlocal
python3 -m pip install pysqlite3
python3 server
</code></pre>

<p>在一台服务器上运行server，默认运行在 0.0.0.0 1688。<br/>
这里的服务器可以是你的本地Mac主机，或者本地or远程Linux主机，Windows没试过不清楚。</p>

<h2 id="toc_2">客户端设置(不需要)</h2>

<p><code>python client.py 0.0.0.0（使用服务端ip） 1688</code>我运行了上述指令发现并没有什么卵用，也对，密钥都没导入，能有用才怪了。<br/>
现在我们创建一个activate.bat脚本：</p>

<pre class="line-numbers"><code class="language-bat">cscript //nologo slmgr.vbs /upk
cscript //nologo slmgr.vbs /ipk W269N-WFGWX-YVC9B-4J6C9-T83GXc
cscript //nologo slmgr.vbs /ipk MH37W-N47XK-V7XM9-C7227-GCQG9
cscript //nologo slmgr.vbs /ipk NPPR9-FWDCX-D2C8J-H872K-2YT43
cscript //nologo slmgr.vbs /ipk DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4
cscript //nologo slmgr.vbs /ipk NW6C2-QMPVW-D7KKK-3GKT6-VCFB2
cscript //nologo slmgr.vbs /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ
cscript //nologo slmgr.vbs /ipk D2N9P-3P6X9-2R39C-7RTCD-MDVJX
cscript //nologo slmgr.vbs /ipk W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9
cscript //nologo slmgr.vbs /ipk KNC87-3J2TX-XB4WP-VCPJV-M4FWM
cscript //nologo slmgr.vbs /ipk FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4
cscript //nologo slmgr.vbs /ipk MRPKT-YTG23-K7D7T-X2JMM-QY7MG
cscript //nologo slmgr.vbs /ipk W82YF-2Q76Y-63HXB-FGJG9-GF7QX
cscript //nologo slmgr.vbs /ipk 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH
cscript //nologo slmgr.vbs /ipk YDRBP-3D83W-TY26F-D46B2-XCKRJ
cscript //nologo slmgr.vbs /ipk CB7KF-BWN84-R7R2Y-793K2-8XDDG
cscript //nologo slmgr.vbs /ipk WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY
cscript //nologo slmgr.vbs /ipk JCKRF-N37P4-C2D82-9YXRT-4M63B
cscript //nologo slmgr.vbs /ipk YC7DK-G2NP3-2QQC3-J6H88-GVGXT
cscript //nologo slmgr.vbs /ipk KBKQT-2NMXY-JJWGP-M62JB-92CD4
cscript //nologo slmgr.vbs /ipk XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99
cscript //nologo slmgr.vbs /ipk JNRGM-WHDWX-FJJG3-K47QV-DRTFM
cscript //nologo slmgr.vbs /ipk YC7DK-G2NP3-2QQC3-J6H88-GVGXT
cscript //nologo slmgr.vbs /ipk KBKQT-2NMXY-JJWGP-M62JB-92CD4
cscript //nologo slmgr.vbs /ipk FN8TT-7WMH6-2D4X9-M337T-2342K
cscript //nologo slmgr.vbs /ipk 6NTH3-CW976-3G3Y2-JK3TX-8QHTT
cscript //nologo slmgr.vbs /ipk C2FG9-N6J68-H8BTJ-BW3QX-RM3B3
cscript //nologo slmgr.vbs /ipk J484Y-4NKBF-W2HMG-DBMJC-PGWR7
cscript //nologo slmgr.vbs /ipk VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB
cscript //nologo slmgr.vbs /ipk TGN6P-8MMBC-37P2F-XHXXK-P34VW
cscript //nologo slmgr.vbs /ipk 4NT99-8RJFH-Q2VDH-KYG2C-4RD4F
cscript //nologo slmgr.vbs /ipk 6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7
cscript //nologo slmgr.vbs /ipk XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99
cscript //nologo slmgr.vbs /ipk JNRGM-WHDWX-FJJG3-K47QV-DRTFM
cscript //nologo slmgr.vbs /ipk YG9NW-3K39V-2T3HJ-93F3Q-G83KT
cscript //nologo slmgr.vbs /ipk WGT24-HCNMF-FQ7XH-6M8K7-DRTW9
cscript //nologo slmgr.vbs /ipk GNFHQ-F6YQM-KQDGJ-327XX-KQBVC
cscript //nologo slmgr.vbs /ipk D8NRQ-JTYM3-7J2DX-646CT-6836M
cscript //nologo slmgr.vbs /ipk PD3PC-RHNGV-FXJ29-8JK7D-RJRJK
cscript //nologo slmgr.vbs /ipk 69WXN-MBYV6-22PQG-3WGHK-RM6XC
cscript //nologo slmgr.vbs /ipk 7WHWN-4T7MP-G96JF-G33KR-W8GF4
cscript //nologo slmgr.vbs /ipk NY48V-PPYYH-3F4PX-XJRKJ-W4423
cscript //nologo slmgr.vbs /ipk 9C2PK-NWTVB-JMPW8-BFT28-7FTBF
cscript //nologo slmgr.vbs /ipk DR92N-9HTF2-97XKM-XW2WJ-XW3J6
cscript //nologo slmgr.vbs /ipk R69KK-NTPKF-7M3Q4-QYBHW-6MT9B
cscript //nologo slmgr.vbs /ipk WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6
cscript //nologo slmgr.vbs /ipk J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6
cscript //nologo slmgr.vbs /ipk VQ9DP-NVHPH-T9HJC-J9PDT-KTQRG
cscript //nologo slmgr.vbs /ipk NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP
cscript //nologo slmgr.vbs /ipk XM2V9-DN9HH-QB449-XDGKC-W2RMW
cscript //nologo slmgr.vbs /ipk B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B
cscript //nologo slmgr.vbs /ipk C4F7P-NCP8C-6CQPT-MQHV9-JXD2M
cscript //nologo slmgr.vbs /ipk TMJWT-YYNMB-3BKTF-644FC-RVXBD
cscript //nologo slmgr.vbs /ipk 7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK
cscript //nologo slmgr.vbs /ipk RRNCX-C64HY-W2MM7-MCH9G-TJHMQ
cscript //nologo slmgr.vbs /ipk PBX3G-NWMT6-Q7XBW-PYJGG-WXD33
cscript //nologo slmgr.vbs /ipk N2CG9-YD3YK-936X4-3WR82-Q3X4H
cscript //nologo slmgr.vbs /ipk 9BGNQ-K37YR-RQHF2-38RQ3-7VCBB
cscript //nologo slmgr.vbs /ipk 7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2c
cscript //nologo slmgr.vbs /skms 192.168.220.187:1688
cscript //nologo slmgr.vbs /ato
cscript //nologo slmgr.vbs /ato
cscript //nologo slmgr.vbs /dlv
cmd /k
</code></pre>

<p>上面的脚本包含了win10、win7、office2019、office2016、office2013的大部分密钥（主要是专业版），基本满足需求，不过其实也没必要搞那么多，但是懒得筛选了。</p>

<h2 id="toc_3">激活win和office</h2>

<p>首先在服务器上运行 kms server。</p>

<ul>
<li>打开终端然后进入py-kms的py3-kms目录</li>
<li>然后输入<code>python3 server</code>并回车</li>
<li>右键点击以管理员身份运行 activate.bat 即可。</li>
</ul>

<p>显示如下信息表示激活成功：</p>

<p><img src="media/15456175398128/win%E6%BF%80%E6%B4%BB2018-12-24%2011-12-38.png" alt="win激活2018-12-24 11-12-38"/></p>

<h2 id="toc_4">其他</h2>

<p>kms每次只激活180天也就是3个月，这样每三个月就要重新激活一次，你可以每次提醒的时候再打开server然后运行activate.bat脚本。也可以把server部署在远程服务器上，然后在client添加一个计时任务周期性的运行bat脚本。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css美化文章标题]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453757934453.html"/>
    <updated>2018-12-21T15:03:13+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453757934453.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>MWeb自带的标题不好看，特别是首页展示的文章多的时候，没有区分度，看的眼花缭乱的。<br/>
参考自：<a href="http://www.fly63.com/article/detial/642">http://www.fly63.com/article/detial/642</a></p>
</blockquote>

<h2 id="toc_0">彩虹字</h2>

<p>下面是我添加的css代码，用来稍微美化一下文章标题。</p>

<pre class="line-numbers"><code class="language-css3">.markdown-body h1 {
  font-size: 2rem;
  margin: 0.67rem 0;
  background: linear-gradient(to right, red, orange, green, blue, indigo, violet);
  -webkit-background-clip: text; 
  color: transparent;   
}
</code></pre>

<h2 id="toc_1">虚化标题</h2>

<pre class="line-numbers"><code class="language-text">.markdown-body h1 {
  font-size: 30px;
  color:  #00cccc;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
  overflow-y: scroll;
  margin: 0px;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pycharm编程遇到的技巧]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453720146052.html"/>
    <updated>2018-12-21T14:00:14+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453720146052.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">pycharm技巧</h2>

<p>ctrl+z 撤回<br/>
全部选中然后tab是全部缩进<br/>
全部选中然后shift+tab是全部反缩进</p>

<h2 id="toc_1">编程技巧</h2>

<p>dir()    #输出函数包含的方法<br/>
type() #输出类型</p>

<p>更多技巧可以查阅官方文档的使用帮助。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[npm Cannot find module 'semver' --解决方案]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453717965995.html"/>
    <updated>2018-12-21T13:56:36+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453717965995.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://blog.csdn.net/hanshuonb/article/details/77969080">https://blog.csdn.net/hanshuonb/article/details/77969080</a></p>
</blockquote>

<p>度娘上面我没有找到相关的解决方法所以只能去Stack Overflow上寻找答案，找到的结果是这样的：</p>

<pre class="line-numbers"><code class="language-text">sudo rm -rf /usr/local/lib/node_modules
sudo rm -rf ~/.npm
brew uninstall --force node
brew install node
</code></pre>

<p>上面命令的意思删除所有全局包和.npm文件夹，重新安装node。 <br/>
这种方法我没试过，因为肯定有很多小伙伴安装了除npm之外的全局包比如express、webpack等等，如果不考虑清楚直接全删了的话。。。后果惨不忍睹。。。(ps:因为本人英语实在不好，所以经常直接傻瓜式粘命令，提醒小伙伴们最好粘命令之前去查查是什么意思，否则出了问题有可能都没法回退。。。)</p>

<p>说了这么多，下面切入正题 <br/>
首先需要知道为啥有报这个错，可以到全局的npm包看一下，路径是</p>

<p><code>/usr/local/lib/node_modules/npm</code><br/>
进入npm的node_modules中的semver文件夹可以看到里面变成空的了！具体的原因不好意思我没有深究，但是我觉得一定和yarn是有关系的。不仅如此，你会看到其他的文件夹也基本都是变成空的了，这下咱们就知道为啥报semver这个module找不到了吧！</p>

<p>网上还有解决方法是说用 <code>npm unintall npm -g</code> 删除npm包，实测不好使。。。npm所有的命令都不行了 uninstall肯定也不行了啊！！！</p>

<h2 id="toc_0">我的解决方法：</h2>

<p>1.先删除全局的npm包：也就是把刚才提到的<code>/usr/local/lib/node_modules/npm</code>，这个npm文件夹删除掉 <br/>
2.回到<code>/usr/local/lib/node_modules</code>这个目录，从GitHub上重新clone下git包 <br/>
终端:<br/>
<code>git clone --recursive git://github.com/isaacs/npm.git</code><br/>
这样新的npm包就回到了全局node_modules中 <br/>
3.打开终端输入<br/>
<code>npm -v</code><br/>
看一下npm是否可以打印出版本号，如果可以，npm就可以正常使用啦！</p>

<p>说白了就是：</p>

<pre class="line-numbers"><code class="language-text">rm -rf /usr/local/lib/node_modules/npm
cd /usr/local/lib/node_modules
git clone --recursive git://github.com/isaacs/npm.git`
</code></pre>

<p>搞定</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mongodb安装配置（arch）]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453716917526.html"/>
    <updated>2018-12-21T13:54:51+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453716917526.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>参考文档：<a href="https://wiki.archlinux.org/index.php/MongoDB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BD.BF.E7.94.A8">https://wiki.archlinux.org/index.php/MongoDB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BD.BF.E7.94.A8</a></p>
</blockquote>

<p><code>pacman -S mongo</code><br/>
<code>/usr/bin/.mongo --help</code><br/>
<code>systemctl start mongodb.service</code><br/>
这样就启动了mongo，启动的配置文件是：<code>cat /etc/mongodb.conf</code><br/>
然后退出到用户目录，运行mongo<br/>
<code>~ ❯❯❯ mongo</code><br/>
<code>/var/lib/mongodb/ 是Arch Linux 的 ** 默认dbpath**</code><br/>
但是无法访问<br/>
修改mongodb的用户组为自己的<br/>
<code>chown mongodb:lonelyor mongodb</code></p>

<p><code>mkdir /home/lonelyor/工作/mongodb</code><br/>
<code>touch /home/lonelyor/工作/mongodb/data</code><br/>
<code>touch /home/lonelyor/工作/mongodb/logs</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux安装配置aria2及其Web图形界面（debian为例）]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453714645346.html"/>
    <updated>2018-12-21T13:51:04+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453714645346.html</id>
    <content type="html"><![CDATA[
<p>下载aria2：apt-get install aria2<br/>
创建配置文件：mkdir /etc/aria2_conf/aria2.conf<br/>
编辑配置文件：nano /etc/aria2_conf/aria2.conf</p>

<p>aria2.conf配置：</p>

<pre class="line-numbers"><code class="language-text">#用户名
#rpc-user=user
#密码
#rpc-passwd=passwd
#上面的认证方式不建议使用,建议使用下面的token方式
#设置加密的密钥
rpc-secret=token
#允许rpc
enable-rpc=true
#允许所有来源, web界面跨域权限需要
rpc-allow-origin-all=true
#允许外部访问，false的话只监听本地端口
rpc-listen-all=true
#RPC端口, 仅当默认端口被占用时修改
rpc-listen-port=6800
#最大同时下载数(任务数), 路由建议值: 3
max-concurrent-downloads=5
#断点续传
continue=true
#同服务器连接数
max-connection-per-server=5
#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要
min-split-size=10M
#单文件最大线程数, 路由建议值: 5
split=10
#下载速度限制
max-overall-download-limit=0
#单文件速度限制
max-download-limit=0
#上传速度限制
max-overall-upload-limit=0
#单文件速度限制
max-upload-limit=0
#断开速度过慢的连接
#lowest-speed-limit=0
#验证用，需要1.16.1之后的release版本
#referer=*
#文件保存路径, 默认为当前启动位置
dir=/root/downloads
#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本
#disk-cache=0
#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)
#enable-mmap=true
#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长
#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持
file-allocation=prealloc
</code></pre>

<p>然后配置开机启动：<br/>
<code>nano /etc/init.d/aria2</code></p>

<pre class="line-numbers"><code class="language-text">#!/bin/bash
#
# aria2 - this script starts and stops the aria2 daemon
#
# chkconfig:   - 85 15
# description: Aria2 - Download Manager
# processname: aria2c
# config:      /etc/aria2/aria2.conf
# pidfile:

# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0

aria2c=&quot;/usr/bin/aria2c&quot;
ARIA2C_CONF_FILE=&quot;/etc/aria2/aria2.conf&quot;
options=&quot; --conf-path=$ARIA2C_CONF_FILE -D &quot;

RETVAL=0

start() {
    # code here to start the program
    echo -n &quot;Starting aria2c daemon.&quot;
    ${aria2c} ${options}
    RETVAL=$?
    echo
}

stop() {
    echo -n &quot;Shutting down aria2c daemon.&quot;
    /usr/bin/killall aria2c
    RETVAL=$?
    echo
}

status() {
    ID=$(/bin/ps -ef | grep &#39;aria2c&#39; | grep -v &#39;grep&#39; | awk &#39;{print $2}&#39;)
    if [[ &quot;x$ID&quot; != &quot;x&quot; ]]; then
            echo &quot;Aria2 is running.&quot;
    else
            echo &quot;Aria2 is not running.&quot;
    fi
}

restart() {
    stop
    sleep 3
    start
}

case &quot;$1&quot; in
    start)
            start
            ;;
    stop)
            stop
            ;;
    status)
            status
            ;;
    restart)
            restart
            ;;
    *)
            echo &quot;Usage: service aria2c {start|stop|restart}&quot;
            RETVAL=1
esac

exit $RETVAL
</code></pre>

<p>使用以下命令来立即启动 Aria2：</p>

<p><code>/usr/bin/aria2c --conf-path=/etc/aria2_conf/aria2.conf -D</code></p>

<p>保存之后配置 WebUI，首先开启 Web 服务，然后安装 WebUI 到指定目录，比如我的目录是/opt/aria2webUI/<br/>
<code>git clone https://github.com/ziahamza/webui-aria2.git</code><br/>
这样就下载了 WebUI，然后用 nginx 反代这个文件就ok了。</p>

<p>nginx(/etc/nginx/conf.d/aria2.conf)配置文件如下：</p>

<pre class="line-numbers"><code class="language-text">aria2.conf

server
{
listen 80;
server_name aria2.lonelyor.org;
location / {
    root /opt/aria2webUI/;
}
access_log logs/aria2_access.log;
}
</code></pre>

<p>然后打开浏览器访问 aria2.lonelyor.org 就可以了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下搜狗输入法不能用的解决办法]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453713553710.html"/>
    <updated>2018-12-21T13:49:15+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453713553710.html</id>
    <content type="html"><![CDATA[
<p>删除<br/>
<code>～/config</code><br/>
下的<br/>
<code>sogou-qimpanel</code><br/>
<code>SogouPY</code><br/>
<code>SogouPY.users</code><br/>
这三个文件夹，然后重启。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arch设置屏幕分辨率]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453712257423.html"/>
    <updated>2018-12-21T13:47:05+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453712257423.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://wiki.archlinux.org/index.php/Xrandr_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/Xrandr_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
</blockquote>

<p>1、先使用xrandr查看屏幕相关信息<br/>
2、编辑/e/X/xorg.conf.d ❯❯❯ sudo nano 11-lonelyorx.conf (自己新建)<br/>
结果我不怎么会写配置文件，导致写了都没法启动图形界面了，于是又删了，打算手动更改。<br/>
3、<br/>
xrandr查看当前设置 <br/>
<code>cvt 1920 1080</code><br/>
<code>cvt 2560 1440</code><br/>
找到正确的参数 <br/>
<code>xrandr --newmode &quot;1920x1080_60.00&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</code><br/>
<code>xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</code><br/>
然后设置 <br/>
<code>xrandr --addmode eDP1 1920x1080_60.00</code><br/>
<code>xrandr --addmode HDMI1 2560x1440_60.00</code><br/>
如果一且顺利的话，此时再查看xrandr命令，将发现最佳分辨率设置成功。 <br/>
4、修改分辨率<br/>
<code>xrandr --output eDP1 --mode 1920x1080_60.00</code><br/>
<code>xrandr --output HDMI1 --mode 2560x1440_60.00</code></p>

<p><code>xrandr --newmode &quot;1920x1080_60.00&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</code><br/>
<code>xrandr --addmode eDP1 1920x1080_60.00</code><br/>
<code>xrandr --output eDP1 --mode 1920x1080_60.00</code></p>

<p>这样屏幕分辨率就变成1080p了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python弱口令脚本的一点备注]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453709108643.html"/>
    <updated>2018-12-21T13:41:50+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453709108643.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>很久以前写的</p>
</blockquote>

<p>跑弱口令的脚本<br/>
不要使用字典这种操作，这不利于跑大量数据的场景。<br/>
应该制定规则去跑，比如：<br/>
取出一个用户名，然后根据规则生成弱口令，然后再去匹配用户名对应的密码，匹配则是弱口令，不匹配则不是弱口令。<br/>
这样可以后续变成一个服务，用户输入密码，触发了规则则告诉他密码是弱口令。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[msf安装与维护]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453707290429.html"/>
    <updated>2018-12-21T13:38:49+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453707290429.html</id>
    <content type="html"><![CDATA[
<p><code>curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \<br/>
  chmod 755 msfinstall &amp;&amp; \<br/>
  ./msfinstall</code></p>

<p>上面是官方提供的一键安装脚本</p>

<p>使用msfupdate可以进行更新</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看端口占用]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453706658952.html"/>
    <updated>2018-12-21T13:37:45+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453706658952.html</id>
    <content type="html"><![CDATA[
<p>使用命令：<br/>
<code>lsof -i:8000</code><br/>
或<br/>
<code>netstat -tunlp|grep 8000</code><br/>
均可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fsarchiver备份文件介绍]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15453705663839.html"/>
    <updated>2018-12-21T13:36:06+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15453705663839.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>多年以前的笔记</p>
</blockquote>

<p>fsarchiver安装<br/>
<code>apt-get install fsarchiver</code></p>

<pre class="line-numbers"><code class="language-text"># 对于备份操作，我们需要以只读形式重新挂载文件系统或者有条件的话直接卸载。也可以-A忽略
[peter@test88 ~]$ sudo /home/peter/fsarchiver savefs backup.fsa /dev/sdb1
oper_save.c#938,filesystem_mount_partition(): partition [/dev/sdb1] is mounted read/write. please mount it read-only
and then try again. you can do &quot;mount -o remount,ro /dev/sdb1&quot;. you can
also run fsarchiver with option &#39;-A&#39; if you know what you are doing.
removed backup.fsa
 
# 对于恢复操作，我们必须先卸载文件系统。
[peter@test88 ~]$ sudo /home/peter/fsarchiver restfs backup2.fsa id=0,dest=/dev/sdb2
oper_restore.c#1230,extractar_filesystem_extract(): partition [/dev/sdb2] is mounted on [/home/peter/sder].
cannot restore an archive to a partition which is mounted, unmount it first: umount /home/peter/sder
 
# 创建文件系统备份
# 可以将多个文件系统备份在一个文件中
[peter@test88 ~]$ sudo /home/peter/fsarchiver savefs backup.fsa /dev/sdb1 /dev/sdb2
 
# 恢复文件系统
# id=0表明从归档中提取第一个文件系统的内容
[peter@test88 ~]$ sudo /home/peter/fsarchiver restfs backup.fsa id=0,dest=/dev/sdc1 id=1,dest=/dev/sdc2



# 软件说明文档
====&gt; fsarchiver version 0.8.1 (2017-01-10) - http://www.fsarchiver.org &lt;====           
Distributed under the GPL v2 license (GNU General Public License v2).                   
 * usage: fsarchiver [&lt;options&gt;] &lt;command&gt; &lt;archive&gt; [&lt;dev1&gt; [&lt;dev2&gt; [...]]]            
&lt;commands&gt;                                                                              
 * savefs: save filesystems to an archive file (backup a device to a file)              
 * restfs: restore filesystems from an archive (overwrites the existing data)           
 * savedir: save directories to the archive (similar to a compressed tarball)           
 * restdir: restore data from an archive which is not based on a filesystem             
 * archinfo: show information about an existing archive file and its contents           
 * probe [detailed]: show list of filesystems detected on the disks                     
&lt;options&gt;                                                                               
 -o: overwrite the archive if it already exists instead of failing                      
 -v: verbose mode (can be used several times to increase the level of details)          
 -d: debug mode (can be used several times to increase the level of details)            
 -A: allow to save a filesystem which is mounted in read-write (live backup)            
 -a: allow to save a filesystem when acls and xattrs are not supported                  
 -x: enable support for experimental features (they are disabled by default)            
 -e &lt;pattern&gt;: exclude files and directories that match that pattern                    
 -L &lt;label&gt;: set the label of the archive (comment about the contents)                  
 -z &lt;level&gt;: compression level from 1 (very fast) to 9 (very good) default=3            
 -s &lt;mbsize&gt;: split the archive into several files of &lt;mbsize&gt; megabytes each           
 -j &lt;count&gt;: create more than one (de)compression thread. useful on multi-core cpu      
 -c &lt;password&gt;: encrypt/decrypt data in archive, &quot;-c -&quot; for interactive password        
 -h: show help and information about how to use fsarchiver with examples                
 -V: show program version and exit                                                      
&lt;information&gt;                                                                           
 * Support included for: lzo=yes, lzma=yes                                              
 * Support for ntfs filesystems is unstable: don&#39;t use it for production.               
&lt;examples&gt;                                                                              
 * save only one filesystem (/dev/sda1) to an archive:                                  
   fsarchiver savefs /data/myarchive1.fsa /dev/sda1                                     
 * save two filesystems (/dev/sda1 and /dev/sdb1) to an archive:
   fsarchiver savefs /data/myarchive2.fsa /dev/sda1 /dev/sdb1
 * restore the first filesystem from an archive (first = number 0):
   fsarchiver restfs /data/myarchive2.fsa id=0,dest=/dev/sda1
 * restore the second filesystem from an archive (second = number 1):
   fsarchiver restfs /data/myarchive2.fsa id=1,dest=/dev/sdb1
 * restore two filesystems from an archive (number 0 and 1):
   fsarchiver restfs /data/arch2.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1
 * restore a filesystem from an archive and convert it to reiserfs:
   fsarchiver restfs /data/myarchive1.fsa id=0,dest=/dev/sda1,mkfs=reiserfs
 * restore a filesystem from an archive and specify extra mkfs options:
   fsarchiver restfs /data/myarchive1.fsa id=0,dest=/dev/sda1,mkfs=ext4,mkfsopt=&quot;-I 256&quot;
 * restore a filesystem from an archive and specify a new label and a new UUID:
   fsarchiver restfs /data/myarchive1.fsa id=0,dest=/dev/sda1,label=root,uuid=5f6e5f4f-dc2a-4dbd-a6ea-9ca997cde75e
 * save the contents of /usr/src/linux to an archive (similar to tar):
   fsarchiver savedir /data/linux-sources.fsa /usr/src/linux
 * save a filesystem (/dev/sda1) to an archive split into volumes of 680MB:
   fsarchiver savefs -s 680 /data/myarchive1.fsa /dev/sda1
 * save a filesystem and exclude all files/dirs called &#39;pagefile.*&#39;:
   fsarchiver savefs /data/myarchive.fsa /dev/sda1 --exclude=&#39;pagefile.*&#39;
 * generic exclude for &#39;share&#39; such as &#39;/usr/share&#39; and &#39;/usr/local/share&#39;:
   fsarchiver savefs /data/myarchive.fsa --exclude=share
 * absolute exclude valid for &#39;/usr/share&#39; but not for &#39;/usr/local/share&#39;:
   fsarchiver savefs /data/myarchive.fsa --exclude=/usr/share
 * save a filesystem (/dev/sda1) to an encrypted archive:
   fsarchiver savefs -c mypassword /data/myarchive1.fsa /dev/sda1
 * same as before but prompt for password in the terminal:
   fsarchiver savefs -c - /data/myarchive1.fsa /dev/sda1
 * extract an archive made of simple files to /tmp/extract:
   fsarchiver restdir /data/linux-sources.fsa /tmp/extract
 * show information about an archive and its filesystems:
   fsarchiver archinfo /data/myarchive2.fsa
   ```
</code></pre>

]]></content>
  </entry>
  
</feed>
