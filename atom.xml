<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[lonelyorWiki]]></title>
  <link href="http://www.lonelyor.org/lonelyorWiki/atom.xml" rel="self"/>
  <link href="http://www.lonelyor.org/lonelyorWiki/"/>
  <updated>2019-01-29T11:21:20+08:00</updated>
  <id>http://www.lonelyor.org/lonelyorWiki/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Atom设置和取消代理]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045487644.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045487644.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">设置本地上游代理</h2>

<p>apm config set http-proxy socks5:127.0.0.1:1080<br/>
apm config set https-proxy socks5:127.0.0.1:1080</p>

<h2 id="toc_1">取消SSL</h2>

<p>apm config set strict-ssl false</p>

<h2 id="toc_2">取消代理</h2>

<p>apm config set http-proxy null<br/>
apm config set https-proxy null</p>

<h2 id="toc_3">查看代理设置</h2>

<p>apm config get http-proxy<br/>
apm config get https-proxy</p>

<p>编辑～/.atom/.apmrc文件，配置为：<br/>
strict-ssl=false<br/>
http_proxy = socks5: 127.0.0.1:1080<br/>
https_proxy = socks5: 127.0.0.1:1080</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BASIC INJECTION 基本注入]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045486850.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045486850.html</id>
    <content type="html"><![CDATA[
<p>题目：<a href="https://ctflearn.com/problems/88">https://ctflearn.com/problems/88</a><br/>
解：<br/>
访问题目中提到的：<a href="https://web.ctflearn.com/web4/">域名</a><br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-1.png" alt="ctflearn-basic-injection-1"/><br/>
然后输入payload，得到以下数据，方框中的即为flag。<br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-2.png" alt="ctflearn-basic-injection-2"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CRLF注入]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491221.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491221.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>文章翻译自OWASP的<a href="https://www.owasp.org/index.php/CRLF_Injection">CRLF_Injection</a></p>
</blockquote>

<p>CRLF即回车Carriage Return (ASCII 13, \r) 和 换行 Line Feed (ASCII 10, \n)。他们被用于注释掉一行的终止。不过不同系统的处理方式有点不同。windows中，CR和LF都被用于注释掉一行的结尾，而linux/unix中只需要一个LF。在HTTP协议中，CRLF序列始终用于一行的终止。<br/>
当用户设法将CRLF提交到应用程序时，可能发生CRLF注入攻击，这通常是通过修改HTTP参数或URL来完成。</p>

<p>CRLF注入可能产生这样的问题：</p>

<ul>
<li>HTTP响应拆分</li>
<li>日志注入<br/>
## HTTP响应拆分<br/>
通常，当出现以下情况时会发生HTTP响应拆分</li>
<li>数据通过不受信任的来源进入Web应用程序，如HTTP请求。</li>
<li>数据包含在发送给Web用户的HTTP响应标头中，而不会对恶意字符进行验证。<br/>
HTTP响应拆分是达到目的的手段而不是目的本身。<br/>
攻击方式如下：攻击者将恶意数据传递给易受攻击的应用程序，应用程序将数据包含在HTTP响应中。<br/>
要成功利用漏洞，应用程序必须允许<strong>包含有 CR（回车，即 %0d 或者 \r\n）和 LF（换行符，%0a 或者 \n）的输入在header中</strong>和<strong>底层平台必须容易注入这样的字符</strong>。</li>
</ul>

<p><em>大多数现代应用程序服务器(无论用什么语言编写的代码)，都已经不存在HTTP响应拆分漏洞。</em></p>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie(&quot;author&quot;, author);
      cookie.setMaxAge(cookieExpiration);
      response.addCookie(cookie);
</code></pre>

<p>上述代码的意思是：从客户端HTTP请求中接受参数（author），并将其设置在HTTP响应的cookie头中。<br/>
如果我们正常提交数据(author=lonelyor)，HTTP响应应该是这样：</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
</code></pre>

<p>但是，由于源代码中的cookie是由未经验证的用户输入组成的，因此如果我们提交恶意代码<code>Hacker By xxx\r\nContent-Length:45\r\n\r\n...</code>则HTTP响应将被拆分为原始响应和伪造响应。</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
    ...
    Set-Cookie: author=Hacker By xxx
    Content-Length: 999
    
    &lt;html&gt;恶意内容...&lt;/html&gt; (这个例子中为第999个字符)
    原始内容以1000开头, 现在被浏览器忽略了...
</code></pre>

<h3 id="toc_0">危害</h3>

<p>攻击者构建任意HTTP响应的能力可能导致以下攻击：<br/>
跨用户污染（Cross-User_Defacement）——利用条件很苛刻<br/>
缓存中毒（Cache_Poisoning）——利用条件很苛刻<br/>
XSS跨站脚本攻击<br/>
页面劫持</p>

<h2 id="toc_1">日志注入</h2>

<p>将未经验证的用户输入写入日志文件可能导致攻击者伪造日志或者将恶意内容注入日志。<br/>
以下情况可能导致日志伪造漏洞：</p>

<ul>
<li>数据从不受信任的来源进入应用程序</li>
<li>数据将写入应用程序或者系统日志文件</li>
</ul>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">...
String val = request.getParameter(&quot;val&quot;);
try {
  int value = Integer.parseInt(val);
}
catch (NumberFormatException) {
  log.info(&quot;Failed to parse val = &quot; + val);
}
...
</code></pre>

<p>上述代码的功能是，从请求对象中读取整数值，如果该值无法解析为整数，则会记录输入，并显示一条错误信息。<br/>
如果用户提交字符串“one”，则会记录以下条目<br/>
<code>INFO: Failed to parse val=one</code><br/>
然而，如果攻击者提交字符串<code>one%0a%0aINFO:+User+logged+out%3dbadguy</code>则会在日志中显示：</p>

<pre class="line-numbers"><code class="language-text">    INFO: Failed to parse val=one

    INFO: User logged out=badguy
</code></pre>

<p>显然攻击者可以使用相同机制插入任意日志条目。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FOEENSICS 101]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491124.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491124.html</id>
    <content type="html"><![CDATA[
<p>题目：<a href="https://ctflearn.com/problems/96">https://ctflearn.com/problems/96</a><br/>
<img src="http://images.lonelyor.org/ctflearn-96-1.png" alt="ctflearn-96-1"/><br/>
访问域名，然后会下载一张图片。<br/>
接下来我们使用十六进制编码器打开这张图片，会发现：<br/>
<img src="http://images.lonelyor.org/ctflearn-96-2.png" alt="ctflearn-96-2"/><br/>
标红部分即是flag。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpOnly]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490848.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490848.html</id>
    <content type="html"><![CDATA[
<p>HttpOnly是 Set-Cookie HTTP响应头中包含的附加标志。生成cookie时使用httponly标志有助于降低客户端脚本访问受保护cookie的风险。</p>

<p>如果HTTP响应头中包含HttpOnly标志，则无法通过客户端脚本访问cookie。因此即使存在xss跨站脚本漏洞，并且用户意外访问到恶意链接，浏览器也不会向第三方透露cookie（前提是浏览器支持HttpOnly）。</p>

<p>参考链接：</p>

<blockquote>
<p><a href="https://www.owasp.org/index.php/HttpOnly">https://www.owasp.org/index.php/HttpOnly</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IIS短文件名漏洞]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045487043.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045487043.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">漏洞原理</h2>

<hr/>

<p>windows在创建一个新文件时，操作系统还会生成 8.3 格式的兼容 MS-DOS 的（短）文件名，以允许基于 MS-DOS 或16位 windows 的程序访问这些文件。    </p>

<h2 id="toc_1">利用场景</h2>

<hr/>

<p>1、用于猜解文件/文件名<br/><br/>
2、.Net Framework 的拒绝服务攻击（不常见）</p>

<h2 id="toc_2">检测方法</h2>

<hr/>

<p><strong>黑盒测试</strong><br/><br/>
使用<a href="https://github.com/lijiejie/IIS_shortname_Scanner">IIS短文件名扫描器</a><br/><br/>
<strong>白盒测试</strong><br/>
几乎所有的 windows 操作系统，在 cmd 中使用命令：</p>

<pre class="line-numbers"><code class="language-bat">dir /x
</code></pre>

<p>如图：<br/>
<img src="media/15483045487043/%E7%9F%AD%E6%96%87%E4%BB%B6%E5%90%8D%E6%98%BE%E7%A4%BA.png" alt="短文件名显示"/></p>

<h2 id="toc_3">修复方案</h2>

<hr/>

<p>1、升级 .net framework 至 4.0 版本或以上<br/><br/>
2、修改注册表键值<br/><br/>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem 修改NtfsDisable8dot3NameCreation为1。（此项默认为0）<br/><br/>
此设置用于禁用短文件名功能，重启后生效。<br/><br/>
或者通过 CMD 命令：    </p>

<pre class="line-numbers"><code class="language-txt">Windows Server 2008 R2
查询是否开启短文件名功能：fsutil 8dot3name query
关闭该功能：fsutil 8dot3name set 1

Windows Server 2003
关闭该功能：fsutil behavior set disable8dot3 1
</code></pre>

<p>以上操作只能防止新创建的文件/文件名不会出现短文件名，而当前文件/文件名依然保持短文件名。完整解决方案还需要如下操作：<br/><br/>
3、<br/><br/>
　　a、从当前目录中创建一个副本,并将其重命名为 tempNew；<br/><br/>
　　b、将当前目录重命名为“tempOld”；<br/><br/>
　　c、将“tempNew”重命名为原来的目录名。<br/><br/>
4、禁止 url 中使用 “~” 或它的 Unicode 编码。（IIS7.0的请求阻塞不能完全阻止“~”波浪号。）</p>

<hr/>

<hr/>

<hr/>

<h2 id="toc_4">背景知识</h2>

<hr/>

<p>windows 支持的长文件名最多为 255 个字符。windows 还以 8.3 格式生成与 MS-DOS 兼容的（短）文件名，以允许基于 MS-DOS 或 16 位 windows 的程序访问这些文件。<br/><br/>
8.3格式短文件名规范中：<br/><br/>
‘8’是指文件名或目录名的主体部分小于等于 8 个字节；‘3’是指文件名的扩展名部分小于等于 3 个字节。<br/><br/>
windows 会按以下方式从长文件名生成短文件名：<br/><br/>
windows 首先会删除文件名中的任何无效字符和空格。无效字符包括：</p>

<pre class="line-numbers"><code class="language-txt">.&quot;/\[]:;=,
</code></pre>

<p>由于短文件名只能包含一个英文句点（.），因此 windows 将删除文件名中的其他英文句点，即使文件名中最后一个英文句点后面是有效的非空格字符也是如此。例如：windows 从长文件名 This is a really long filename.123.456.789.txt 生成短文件名 Thisis~1.txt 否则，windows 将忽略最后一个英文句点，而使用倒数第二个英文句点。例如：windows从长文件名 This is a really long filename.123.456.789. 生成短文件名 Thisis~1.789。<br/><br/>
生成短文件名若需要复制的话，windows 将文件名截断为 6 个字符，并在后边附加一个波形符号（~）和一个数字（创建的每一个以 ~1 结尾的唯一文件名，复制文件以 ~2、~3等结尾。）    </p>

<h2 id="toc_5">影响范围</h2>

<hr/>

<p>Windows 10 Pro released in July 2015Windows 10 Enterprise released in July 2015Microsoft Windows Server 2003 Standard EditionMicrosoft Windows Server 2003 Enterprise EditionMicrosoft Windows Server 2003 Datacenter EditionMicrosoft Windows Server 2003 Web EditionMicrosoft Windows Server 2003, Enterprise x64 EditionMicrosoft Windows Small Business Server 2003 Standard EditionMicrosoft Windows Small Business Server 2003 Premium EditionMicrosoft Windows XP Home EditionMicrosoft Windows XP Professional EditionMicrosoft Windows Datacenter Server Limited EditionMicrosoft Windows Advanced Server, Limited EditionMicrosoft Windows 2000 ServerMicrosoft Windows 2000 Advanced ServerMicrosoft Windows 2000 Professional EditionMicrosoft Windows NT Workstation 3.5Microsoft Windows NT Workstation 3.51Microsoft Windows NT Workstation 4.0 开发员版Microsoft Windows NT Server 3.51Microsoft Windows NT Server 4.0 Standard EditionWindows Vista Service Pack 2Windows Vista BusinessWindows Vista EnterpriseWindows Vista Home PremiumWindows Vista UltimateWindows Server 2008 Service Pack 2Windows Server 2008 StandardWindows Server 2008 EnterpriseWindows Server 2008 DatacenterWindows Server 2008 for Itanium-Based SystemsWindows 7 Service Pack 1Windows 7 Home PremiumWindows 7 ProfessionalWindows 7 EnterpriseWindows 7 UltimateWindows Server 2008 R2 Service Pack 1Windows Server 2008 R2 StandardWindows Server 2008 R2 EnterpriseWindows Server 2008 R2 DatacenterWindows Server 2008 R2 for Itanium-Based SystemsWindows 8 EnterpriseWindows 8 ProWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 Datacenter<br/>
列表内所有操作系统均受影响（数据来源日期：20171213）<br/><br/>
该漏洞有其局限性：<br/><br/>
1、只能猜解文件/文件夹名前六位，以及扩展名前三位<br/><br/>
2、名称较短的文件是没有响应的短文件名的<br/><br/>
3、需要 IIS 和 .net 同时满足。  </p>

<h2 id="toc_6">漏洞详情</h2>

<hr/>

<p>在 windows 上的 Apache（Apache支持短文件名）上运行的 web 应用程序正在创建一个长文件名文件（如sql备份文件或会话文件，假设文件名是 backup-082119f75623eb7abd7bf357698ff66c.sql，windows 将创建短文件名 BACKUP〜1.SQL）。这种情况下，如果我们用短文件名访问这个文件，那么就有可能获取这个包含sql数据库备份的文件。<br/><br/>
比较著名的一个例子：<br/><br/>
wordpress 有一个备份博客的插件，该插件会为备份创建一个自定义目录（backup-88456）。备份完成后，该目录包含一个名为 wordpress_wp_20120702_576.sql 的文件  ，即 WordPress 数据库备份。这本应该难以猜测的，因为我们的目录名称中有5个数字加上日期和另外3个数字，即使忽略日期也至少有 100,000,000 个组合。然而由于短文件名的原因，目录名会变成 BACKUP~1 而文件名会变成 WORDPR~1.SQL。100,000,000 个组合被缩减为一个组合。    </p>

<h2 id="toc_7">漏洞利用</h2>

<hr/>

<p><strong>短文件名漏洞</strong><br/>
漏洞利用需要使用到通配符。在 windows 中，* 可以匹配n个字符（n可以为0,一个星号和n个星号的意义一样）。判断某站点是否存在 IIS 短文件名爆破，构造如下payload：    </p>

<pre class="line-numbers"><code class="language-http">1. http://www.xxx.com/*~1*/.aspx
2. http://www.xxx.com/l1j1e*~1*/.aspx
</code></pre>

<p>若1返回404而2返回400，则可以判断目标站点存在漏洞。<br/><br/>
判断漏洞存在后，继续猜解目录下是否存在a开头的文件或文件夹，访问：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/a*~1*/.aspx
</code></pre>

<p>若存在将返回404，不存在则返回400。以此类推，不断向下猜解所有的6个字符。<br/><br/>
到此要考虑两种情况，若abcdef开头的是一个文件夹则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*/~1/.aspx
</code></pre>

<p>返回404。若abcdef开头的是一个文件，则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1/.aspx
</code></pre>

<p>返回404（注意！返回404表示存在）同理我们可以猜出文件后缀名：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1*h*/.aspx
</code></pre>

<p>若返回404则代表扩展名中肯定存在h字符。<br/><br/>
利用此漏洞可以猜解后台地址、敏感文件/文件名（如备份的rar、bak、sql等）；某些情况下，可以通过短文件名漏洞直接下载对应的文件（如备份sql文件）。<br/><br/>
<br><br/>
<strong>.Net Framework 拒绝服务攻击</strong><br/><br/>
当请求文件夹名称包含 ~1 的请求，会导致不存在该文件的 .Net Framework 去递归查询所有根目录。如果只有一个“~1”是无效的，当“~1”大于一个，比如像这样：        </p>

<pre class="line-numbers"><code class="language-http">\wwwtest\fuck~1\~1\~1\~1.aspx
</code></pre>

<p>此时文件系统会这样调用：    </p>

<pre class="line-numbers"><code class="language-txt">\wwwtest                           SUCCESS
\wwwtest\fuck~1\~1\~1\~1           PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest\fuck~1\~1\                PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\             PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1                 PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest                           SUCCESS
\wwwtest                           SUCCESS
</code></pre>

<p>如果我们请求的文件/文件夹名同时存在大小写时，这个请求会被请求两次，一次是原封不动的请求，一次是全部使用小写的请求。<br/><br/>
下表显示了每个请求的FS调用的数量（Windows 2008 R2, IIS 7.5(latest patch – June 2012), and .Net framework 4.0.30319 (在别的系统下可能会不同)）<br/><br/>
<img src="media/15483045487043/F5%E8%B0%83%E7%94%A8.png" alt="F5调用"/></p>

<p>这个问题适用于当时的 .Net framework 的所有版本(<br/><br/>
    IIS 1.0, Windows NT 3.51<br/><br/>
    IIS 2.0, Windows NT 4.0<br/><br/>
    IIS 3.0, Windows NT 4.0 Service Pack 2<br/><br/>
    IIS 4.0, Windows NT 4.0 Option Pack<br/><br/>
    IIS 5.0, Windows 2000<br/><br/>
    IIS 5.1, Windows XP Professional and Windows XP Media Center Edition<br/><br/>
    IIS 6.0, Windows Server 2003 and Windows XP Professional x64 Edition<br/><br/>
    IIS 7.0, Windows Server 2008 and Windows Vista<br/><br/>
    IIS 7.5, Windows 7 (error remotely enabled or no web.config)<br/><br/>
    IIS 7.5, Windows 2008 (classic pipeline mode))<br/><br/>
只是 F5 的调用次数会有不同。    </p>

<h2 id="toc_8">参考链接</h2>

<hr/>

<ul>
<li><a href="http://www.lijiejie.com/iis-win8-3-shortname-brute/">http://www.lijiejie.com/iis-win8-3-shortname-brute/</a><br/></li>
<li><a href="https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/">https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/</a><br/></li>
<li><a href="http://www.freebuf.com/articles/4908.html">http://www.freebuf.com/articles/4908.html</a><br/></li>
<li><a href="https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions">https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions</a><br/></li>
<li><a href="https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf">https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf</a><br/></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript基础]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045491003.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045491003.html</id>
    <content type="html"><![CDATA[
<p>JavaScript是一种脚本编程语言。<br/>
JavaScript运行顺序是从上往下，因此要注意代码的顺序。</p>

<h2 id="toc_0">如何使用JavaScript</h2>

<p>内部JavaScript：在html页面中嵌入<code>&lt;script&gt;这里写js代码&lt;/script&gt;</code>即可插入js代码。<br/>
外部JavaScript：<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>可以调用html文件同级目录下的script.js文件。</p>

<h2 id="toc_1">注释</h2>

<p><code>// 这是单行注释</code><br/>
<code>/* 这是多行注释 */</code></p>

<h2 id="toc_2">变量</h2>

<p>var用来定义变量</p>

<h2 id="toc_3">函数</h2>

<p>function funName(){<br/>
    js代码<br/>
}<br/>
函数是可复用的代码块，可以一次编写反复使用。</p>

<h2 id="toc_4">运算符</h2>

<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 分别是加减乘除<br/>
<code>===</code>、<code>!==</code>、<code>&lt;</code>、<code>&gt;</code> 分别是等于、不等于、小于、大于<br/>
<code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 分别表示与、或、非</p>

<h2 id="toc_5">条件语句</h2>

<p>if(条件){<br/>
    js代码<br/>
} else {<br/>
    js代码<br/>
}</p>

<h2 id="toc_6">事件</h2>

<p>事件相关函数分为：事件监听器和事件处理器 </p>

<h2 id="toc_7">循环</h2>

<p>for(起式值；退出条件；增加器){<br/>
    js代码<br/>
}</p>

<h2 id="toc_8">switch语句</h2>

<p>switch - 他们以单个表达式/值作为输入，然后查看多个选项，直到找到与该值相匹配的选项，执行与之相关的代码。</p>

<pre class="line-numbers"><code class="language-javascript">switch (expression) {
  case choice1:
    run this code
    break;

  case choice2:
    run this code instead
    break;
    
  // include as many cases as you like

  default:
    actually, just run this code
}
</code></pre>

<h2 id="toc_9">写一个猜数字的小游戏</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/A_first_splash#%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F">猜数字游戏</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MWeb打开文档库快捷键]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045488875.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045488875.html</id>
    <content type="html"><![CDATA[
<p>CMD + L 即可显示</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac大小写切换]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045488856.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045488856.html</id>
    <content type="html"><![CDATA[
<p>无论中文还是英文状态下,按住 shift 输入即是大写</p>

<p>长按 caps lock 2s 灯亮后输入即是大写</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown基础语法]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490336.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490336.html</id>
    <content type="html"><![CDATA[
<p>占坑，内容以后写</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OneDrive映射到本地（像访问本地磁盘一样访问网盘）]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490562.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490562.html</id>
    <content type="html"><![CDATA[
<p>参考以下链接即可：<br/>
<a href="http://baijiahao.baidu.com/s?id=1549908946659905&amp;wfr=spider&amp;for=pc">http://baijiahao.baidu.com/s?id=1549908946659905&amp;wfr=spider&amp;for=pc</a></p>

<p>举一反三，webdav、nfs、samba等都可以使用这种方式挂载，来方便访问。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pycharm编程遇到的技巧]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045487979.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045487979.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">pycharm技巧</h2>

<p>ctrl+z 撤回<br/>
全部选中然后tab是全部缩进<br/>
全部选中然后shift+tab是全部反缩进</p>

<h2 id="toc_1">编程技巧</h2>

<p>dir()    #输出函数包含的方法<br/>
type() #输出类型</p>

<p>更多技巧可以查阅官方文档的使用帮助。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Snipaste 无法在 Mac 上截图的解决办法]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15484074464554.html"/>
    <updated>2019-01-25T17:10:46+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15484074464554.html</id>
    <content type="html"><![CDATA[
<p>MacOSX 版本：Mojave 10.14.2<br/>
Snipaste 版本：1.16.2</p>

<p>以下列出遇到部分问题：<br/>
1、使用截图功能，手动画矩形框，但是选定框画完后松开触摸板，选定框自动消失，导致无法截图。（手动选定截图区域占截图使用时间99%）<br/>
2、使用截图功能，程序自动识别截图区域，双击可以得到截图并且有箭头等选项，画一个箭头后，选定框自动消失，截图会带着箭头自动保存到图片目录。（这导致没法多画几个箭头，也没法另存为图片）</p>

<h1 id="toc_0">解决办法</h1>

<p>我后来在 <a href="https://github.com/Snipaste/feedback/issues/1012">https://github.com/Snipaste/feedback/issues/1012</a> 这里找到了答案。<br/>
关闭欧路词典的划词翻译功能，即可正常使用截图。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VMware14秘钥]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490138.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490138.html</id>
    <content type="html"><![CDATA[
<p>CG54H-D8D0H-H8DHY-C6X7X-N2KG6<br/>
ZC3WK-AFXEK-488JP-A7MQX-XL8YF<br/>
AC5XK-0ZD4H-088HP-9NQZV-ZG2R4<br/>
ZC5XK-A6E0M-080XQ-04ZZG-YF08D<br/>
ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8<br/>
FF590-2DX83-M81LZ-XDM7E-MKUT4</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web安全工程师求职清单]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490948.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490948.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>一年前写的一点玩意，没什么卵用</p>
</blockquote>

<h2 id="toc_0">安全资讯</h2>

<p><a href="http://www.freebuf.com/">freebuf</a></p>

<p><a href="https://www.t00ls.net/">tools</a></p>

<p><a href="https://www.secpulse.com/">安全脉搏</a></p>

<p><a href="https://packetstormsecurity.com/">数据包风暴</a></p>

<p><a href="http://www.4hou.com/">嘶吼</a></p>

<p><a href="https://www.aqniu.com/">安全牛</a></p>

<p><a href="https://www.anquanke.com/">安全客</a></p>

<p><a href="https://www.sec-wiki.com/">sec-wiki</a></p>

<p><a href="http://www.secdoctor.com/">中国信息安全博士网</a></p>

<h2 id="toc_1">威胁情报</h2>

<p>暂略</p>

<h2 id="toc_2">安全工具</h2>

<p><a href="https://www.ctftools.com/down/">最强安全工具集</a></p>

<ul>
<li>burpsuite(抓包)</li>
<li>sqlmap(sql注入)</li>
<li>whireshark(网络抓包)</li>
<li>中国菜刀(webshell、一句话后门)</li>
<li>HxD(十六进制编辑器和磁盘编辑器)</li>
<li>nmap(扫描)</li>
<li>hydra(爆破)</li>
<li>cain(爆破)</li>
<li>metasploit(漏洞利用)</li>
<li>mitmproxy(http/https代理)</li>
<li>commix(命令注入)</li>
<li>httrack(网站克隆)</li>
<li>netcat(瑞士军刀-网络调试和探测工具)</li>
<li>scapy(python的交互式数据包操作程序和库)</li>
<li>empire(域渗透)</li>
</ul>

<h2 id="toc_3">靶机环境</h2>

<h2 id="toc_4">安全知识库</h2>

<p><a href="https://www.anquanquan.info/">安全圈</a></p>

<p><a href="http://wiki.open.qq.com/wiki/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83">腾讯安全开发规范</a></p>

<p><a href="https://highon.coffee/blog/cheat-sheet/">安全研究备忘单</a></p>

<p><a href="https://portswigger.net/kb/issues">Burp漏洞定义</a></p>

<p><a href="https://www.offensive-security.com/metasploit-unleashed/">MSF框架终极指南</a></p>

<p><a href="https://www.owasp.org/index.php/Main_Page">OWASP</a></p>

<p><a href="http://vipread.com/index">vipread知识库</a></p>

<p><a href="https://kb.help.rapid7.com/docs/">Rapid7知识库</a></p>

<p><a href="https://kernelnewbies.org/">linux内核研究</a></p>

<p><a href="http://www.loner.fm/bugs/">乌云漏洞</a></p>

<p><a href="https://wooyun.js.org/">乌云文章</a></p>

<p><a href="http://www.office-cn.net/t/api/index.html?web.htm">WindowsAPI参考手册</a></p>

<p><a href="https://support.portswigger.net/customer/portal/articles/2326039-the-burp-methodology">Burp方法论</a></p>

<p><a href="https://ctf-wiki.github.io/ctf-wiki/">CTF-Wiki</a></p>

<p><a href="https://github.com/ctfs/">CTFs</a></p>

<p><a href="https://ctftime.org">ctftime</a></p>

<p><a href="https://www.codesec.net/">代码安全</a></p>

<p><a href="https://silic.wiki/doku.php">习科小黑板</a></p>

<p><a href="https://bbs.safewiki.org/portal.php">安全文库</a></p>

<p><a href="http://webscan.360.cn/vul">360网站常见漏洞</a></p>

<h2 id="toc_5">漏洞平台</h2>

<p><a href="https://butian.360.cn/">补天</a></p>

<p><a href="https://www.vulbox.com/">漏洞盒子</a></p>

<p><a href="https://www.bugbank.cn/">漏洞银行</a></p>

<p><a href="http://www.cnvd.org.cn/">CNVD国家信息安全漏洞共享平台</a></p>

<p><a href="https://src.edu-info.edu.cn/">教育行业漏洞报告平台</a></p>

<p><a href="https://www.seebug.org">Seebug</a></p>

<p><a href="http://0xsafe.org/vuldb.html">Vuldbs漏洞平台</a></p>

<h2 id="toc_6">技能要求</h2>

<ul>
<li>不同场景下的渗透测试流程、方法</li>
<li>常见漏洞的攻击方法和防御方法</li>
<li>代码级白盒测试能力</li>
<li>owasp_top10概念、原理、测试方法、防御方法</li>
<li>主流防火墙、IDS、IPS、漏洞扫描工具的安装、使用方法</li>
<li>熟悉python、php、javascript、c、c++等语言的一种或多种</li>
<li>cissp之类的证书或ctf解题能力是加分项</li>
<li>各种靶机环境搭建</li>
<li>安全分析报告的编写</li>
<li>对业务快速熟悉的能力（业务安全重点、应用范围划分、业务安全基线）</li>
<li>spring、struts、hibernate框架安全相关</li>
<li>web组件加固、服务器加固、数据库加固</li>
<li>域渗透、dns、arp等内网渗透知识</li>
<li>各类提权如系统提权、数据库提权等</li>
<li>风险评估、等级保护、安全体系规划、安全体系建设。包括信息资产管理、安全威胁和风险评估、安全解决方案制定、信息安全体系实施</li>
<li>Nginx、Apache、Tomcat等安全配置基线</li>
<li>各类安全测试标准(ISSAF、OSSTMM、OWASP、微软SDLC、OPENSAMM、BSIMM、SSECMM)</li>
<li>网络日志分析、攻击流量检测</li>
<li>hadoop、openstack、sdn云安全</li>
<li>mongodb、redis、HBASE等nosql安全</li>
<li>burpsuite插件编写</li>
<li>python脚本开发能力、shell脚本开发能力</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web安全检测checklist]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045487207.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045487207.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">x01 爆破</h2>

<h3 id="toc_1">弱口令</h3>

<p>HTTP登录<br/>
SSH<br/>
MySQL<br/>
Telnet</p>

<h3 id="toc_2">遍历</h3>

<p>网站敏感文件<br/>
    源码<br/>
    配置文件<br/>
    备份文件<br/>
    探针类文件<br/>
网站敏感目录<br/>
    物理路径<br/>
    网站管理后台<br/>
    上传目录<br/>
    数据库Web管理入口<br/>
    现成的Webshell<br/>
端口扫描<br/>
0day扫描<br/>
子域名</p>

<h2 id="toc_3">x02 不安全配置</h2>

<h3 id="toc_4">Web服务器</h3>

<p>Nginx<br/>
Apache<br/>
IIS</p>

<h3 id="toc_5">Web应用服务器</h3>

<p>Tomcat<br/>
JBoss<br/>
Weblogic</p>

<h3 id="toc_6">HTTP安全特性</h3>

<p>HTTP Headers<br/>
HTTP Options<br/>
rebots.txt<br/>
flash跨域策略</p>

<h2 id="toc_7">x03 敏感信息泄露</h2>

<h3 id="toc_8">用户敏感信息</h3>

<p>手机号<br/>
身份证号<br/>
社保<br/>
银行卡号<br/>
家庭住址</p>

<h3 id="toc_9">应用敏感信息</h3>

<p>debug信息<br/>
堆栈报错</p>

<h3 id="toc_10">站点敏感信息</h3>

<p>测试页面<br/>
备份文件</p>

<h3 id="toc_11">本地敏感信息</h3>

<p>前端保存用户密码<br/>
前端保存验证码</p>

<h2 id="toc_12">x04 xss跨站脚本</h2>

<p>反射型xss<br/>
存储型xss<br/>
DOM型xss</p>

<h2 id="toc_13">x05 请求伪造</h2>

<p>csrf跨站请求伪造<br/>
ssrf服务器请求伪造</p>

<h2 id="toc_14">x06 注入</h2>

<p>LDAP注入<br/>
ORM注入<br/>
XML注入<br/>
XPath注入<br/>
IMAP/SMTP注入<br/>
SQL注入<br/>
代码注入<br/>
客户端模板注入（CSTI）<br/>
服务端模板注入（SSTI）<br/>
服务器端包含注入（SSI）</p>

<h2 id="toc_15">x07 已知漏洞组件</h2>

<p>库文件（某些库会导致远程命令执行）<br/>
框架（如wordpress、thinkphp、django等）<br/>
模块（python的某些模块会导致代码注入）</p>

<h2 id="toc_16">x08 文件类漏洞</h2>

<p>文件包含漏洞<br/>
任意文件创建<br/>
任意文件读取<br/>
任意文件上传<br/>
任意文件下载<br/>
任意文件删除</p>

<h2 id="toc_17">x09 解析漏洞</h2>

<p>IIS解析漏洞<br/>
Nginx解析漏洞<br/>
Apache解析漏洞<br/>
PHP CGI解析漏洞</p>

<h2 id="toc_18">x10 劫持类漏洞</h2>

<p>点击劫持<br/>
Jsonp劫持<br/>
WebSocket劫持<br/>
DNS劫持<br/>
二维码劫持<br/>
子域名劫持</p>

<h2 id="toc_19">x11 业务逻辑漏洞</h2>

<h3 id="toc_20">认证</h3>

<p>使用默认凭证<br/>
冻结账户策略不当<br/>
弱用户名和密码<br/>
“记住我”功能<br/>
自动登录<br/>
单点登录<br/>
弱口令<br/>
弱安全问题/答案<br/>
第三方登录风险<br/>
Oauth2.0安全<br/>
JWT安全<br/>
注册覆盖<br/>
未验证的重定向和转发<br/>
双因素认证不当</p>

<h3 id="toc_21">授权</h3>

<p>测试角色定义<br/>
权限管理缺失<br/>
匿名访问（备用接口——常见于兼容老的不安全的接口时产生）<br/>
水平越权<br/>
垂直越权<br/>
超级账户<br/>
实名认证不严格</p>

<h3 id="toc_22">会话管理</h3>

<p>cookie安全属性<br/>
cookie可猜解<br/>
cookie溢出<br/>
会话固定<br/>
用户凭证不安全传输（弱加密或明文传输）<br/>
用户凭证未一次失效<br/>
用户凭证可猜解<br/>
注销与会话超时<br/>
敏感数据不安全传输</p>

<h3 id="toc_23">流程绕过</h3>

<p>找回密码流程绕过</p>

<h2 id="toc_24">x12 API安全</h2>

<p>整理中</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arch设置屏幕分辨率]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490018.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490018.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://wiki.archlinux.org/index.php/Xrandr_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/Xrandr_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
</blockquote>

<p>1、先使用xrandr查看屏幕相关信息<br/>
2、编辑/e/X/xorg.conf.d ❯❯❯ sudo nano 11-lonelyorx.conf (自己新建)<br/>
结果我不怎么会写配置文件，导致写了都没法启动图形界面了，于是又删了，打算手动更改。<br/>
3、<br/>
xrandr查看当前设置 <br/>
<code>cvt 1920 1080</code><br/>
<code>cvt 2560 1440</code><br/>
找到正确的参数 <br/>
<code>xrandr --newmode &quot;1920x1080_60.00&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</code><br/>
<code>xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</code><br/>
然后设置 <br/>
<code>xrandr --addmode eDP1 1920x1080_60.00</code><br/>
<code>xrandr --addmode HDMI1 2560x1440_60.00</code><br/>
如果一且顺利的话，此时再查看xrandr命令，将发现最佳分辨率设置成功。 <br/>
4、修改分辨率<br/>
<code>xrandr --output eDP1 --mode 1920x1080_60.00</code><br/>
<code>xrandr --output HDMI1 --mode 2560x1440_60.00</code></p>

<p><code>xrandr --newmode &quot;1920x1080_60.00&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</code><br/>
<code>xrandr --addmode eDP1 1920x1080_60.00</code><br/>
<code>xrandr --output eDP1 --mode 1920x1080_60.00</code></p>

<p>这样屏幕分辨率就变成1080p了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[backup系统备份工具介绍]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490117.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490117.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>backup是一款强大的备份软件，用于系统备份、增量备份、远程备份，企业级。<br/>
我还是当年使用debian时用过...这是以前的笔记，留一份在这好了。</p>
</blockquote>

<p>软件安装（debian 9）<br/>
<code>apt-get install backuppc</code><br/>
然后会弹窗：<br/>
backuppc设定<br/>
管理web地址：<br/>
<code>http://lonelyor/backuppc</code><br/>
<code>user：backuppc</code><br/>
<code>passwd：u6oN2KE1</code><br/>
可以通过运行<code>htpasswd /etc/backuppc/htpasswd</code>来修改密码<br/>
这些信息要记住！</p>

<p>安装后：<br/>
<code>Creating config file /etc/backuppc/config.pl with new version（可以暂时忽略）</code></p>

<p>然后运行：<br/>
<code>systemctl restart apache2</code><br/>
<code>/etc/init.d/backuppc restart</code></p>

<p>接着就打开浏览器访问：<br/>
<code>http://lonelyor/backuppc</code><br/>
就能看到web管理界面了。<br/>
如果进不去可以打开隐身模式或者清除cookie再试。</p>

<p>官方安装文档：<code>http://backuppc.sourceforge.net/BackupPC-4.1.3.html#Installing-BackupPC</code></p>

<p>参考文档：<br/>
<code>http://server.zol.com.cn/513/5130348.html</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[burpsuite如何给数据打标的]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045488670.html"/>
    <updated>2019-01-24T12:35:48+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045488670.html</id>
    <content type="html"><![CDATA[
<p>用特殊字符标记关键字即可</p>

<p>类似的有sqlmap，它是使用参数指定要打标的关键词</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[burpsuite插件编写之官方代码示例解读]]></title>
    <link href="http://www.lonelyor.org/lonelyorWiki/15483045490884.html"/>
    <updated>2019-01-24T12:35:49+08:00</updated>
    <id>http://www.lonelyor.org/lonelyorWiki/15483045490884.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>description: 分析burpsuite官方提供的示例代码，以此来学习插件编写。</p>
</blockquote>

<h2 id="toc_0">HelloWorld</h2>

<p>废话不多说，直接上代码！</p>

<pre class="line-numbers"><code class="language-python">from burp import IBurpExtender
from java.io import PrintWriter
from java.lang import RuntimeException

# 上面import的第一句是所有burp插件都必须有的
# 下面开始创建一个burp插件的类来实现插件
class BurpExtender(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        # 创建插件名
        callbacks.setExtensionName(&quot;HelloWorld extension&quot;)
        # 获取输出和错误流
        stdout = PrintWriter(callbacks.getStdout(), True)
        stderr = PrintWriter(callbacks.getStderr(), True)
        # 在输出流和错误流中插入消息
        stdout.println(&quot;Hello output&quot;)
        stderr.println(&quot;Hello errors&quot;)
        # 将消息插入burp的alert警报标签中
        callbacks.issueAlert(&quot;Hello alerts&quot;)
        # 抛出将出现在错误流中的异常
        raise RuntimeException(&quot;Hello exception&quot;)
</code></pre>

<p>现在开始来说几个坑：<br/>
1、插件最好尽量放在英文路径，不然可能会报错<br/>
2、编写代码前指定编码(如：# -<em>- coding:utf8 -</em>-)<br/>
3、raise RuntimeException(&quot;Hello exception&quot;) 这行代码我没看懂是要干嘛的，反正写了之后Errors就报错，不想看的话就注释掉好了。</p>

<h2 id="toc_1">event_listeners 事件监听器</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener
from burp import IProxyListener
from burp import IScannerListener
from burp import IExtensionStateListener
from java.io import PrintWriter

class BurpExtender(IBurpExtender, IHttpListener, IProxyListener, IScannerListener, IExtensionStateListener):
    def registerExtenderCallbacks(self, callbacks):
        # 保持对回调对象的引用
        self._callbacks = callbacks
        # 创建插件名
        callbacks.setExtensionName(&quot;Event Listeners&quot;)
        # 获取输出流
        self._stdout = PrintWriter(callbacks.getStdout(), True)
        # 注册为http监听器
        callbacks.registerHttpListener(self)
        # 注册为proxy监听器
        callbacks.registerProxyListener(self)
        # 注册为scanner监听器
        callbacks.registerScannerListener(self)
        # 注册为扩展插件状态监听器
        callbacks.registerExtensionStateListener(self)
    # 下面几个函数各自实现监听
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        self._stdout.println(
            (&quot;HTTP request to &quot; if messageIsRequest else &quot;HTTP response from&quot;) +
            messageInfo.getHttpService().toString() +
            &quot;[&quot; + self._callbacks.getToolName(toolFlag) + &quot;]&quot;
        )

    def processProxyMessage(self, messageIsRequest, message):
        self._stdout.println(
            (&quot;Proxy request to &quot; if messageIsRequest else &quot;Proxy response from&quot;) +
            message.getMessageInfo.getHTTPService().toString()
        )

    def newScanIssue(self, issue):
        self._stdout.prinln(&quot;New scan issue &quot; + issue.getIssueName())

    def extensionUnloaded(self):
        self._stdout.println(&quot;Extension was unloaded&quot;)
</code></pre>

<p>我是没搞懂这个插件做了什么，诶无所谓，也就是多敲敲代码，熟悉熟悉感觉。</p>

<h2 id="toc_2">traffic_redirector 流量重定向</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener

HOST_FROM = &quot;www.baidu.com&quot;
HOST_TO = &quot;www.zhihu.com&quot;

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        # 获取扩展helpers对象
        self._helpers = callbacks.getHelpers()
        # 设置扩展名
        callbacks.setExtensionName(&quot;Traffic redirector&quot;)
        # 将自己注册为HTTP侦听器
        callbacks.registerHttpListener(self)

    def processHttpMessage(self, toolsFlag, messageIsRequest, messageInfo):
        # 只获取请求
        if not messageIsRequest:
            return
        # 获取http服务的请求
        httpService = messageInfo.getHttpService()
        # 如果主机是HOST_FROM则将它改成HOST_TO
        if (HOST_FROM == httpService.getHost()):
            messageInfo.setHttpService(self._helpers.buildHttpService(HOST_TO,
                httpService.getPort(), httpService.getProtocol()))
</code></pre>

<p>这个插件简单来说就是，把请求中的host部分修改掉。比如上述代码会监听所有host为百度的请求，一旦出现，就会把host改成知乎。</p>

]]></content>
  </entry>
  
</feed>
