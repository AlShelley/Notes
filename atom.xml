<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[lonelyorのblog]]></title>
  <link href="www.lonelyor.org/lonelyorNotes/atom.xml" rel="self"/>
  <link href="www.lonelyor.org/lonelyorNotes/"/>
  <updated>2018-11-28T15:28:02+08:00</updated>
  <id>www.lonelyor.org/lonelyorNotes/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[BASIC INJECTION 基本注入]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15433875205785.html"/>
    <updated>2018-11-28T14:45:20+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15433875205785.html</id>
    <content type="html"><![CDATA[
<p>题目：<a href="https://ctflearn.com/problems/88">https://ctflearn.com/problems/88</a><br/>
解：<br/>
访问题目中提到的：<a href="https://web.ctflearn.com/web4/">域名</a><br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-1.png" alt="ctflearn-basic-injection-1"/><br/>
然后输入payload，得到以下数据，方框中的即为flag。<br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-2.png" alt="ctflearn-basic-injection-2"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpOnly]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15433756568203.html"/>
    <updated>2018-11-28T11:27:36+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15433756568203.html</id>
    <content type="html"><![CDATA[
<p>HttpOnly是 Set-Cookie HTTP响应头中包含的附加标志。生成cookie时使用httponly标志有助于降低客户端脚本访问受保护cookie的风险。</p>

<p>如果HTTP响应头中包含HttpOnly标志，则无法通过客户端脚本访问cookie。因此即使存在xss跨站脚本漏洞，并且用户意外访问到恶意链接，浏览器也不会向第三方透露cookie（前提是浏览器支持HttpOnly）。</p>

<p>参考链接：</p>

<blockquote>
<p><a href="https://www.owasp.org/index.php/HttpOnly">https://www.owasp.org/index.php/HttpOnly</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows右键添加管理员获得所有权]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428715286450.html"/>
    <updated>2018-11-22T15:25:28+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428715286450.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>右键添加获得管理员所有权是个比较方便的功能。</p>
</blockquote>

<p>打开记事本或者别的文本编辑器，然后写入如下内容:</p>

<pre class="line-numbers"><code class="language-cmd">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\*\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\*\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
</code></pre>

<p>然后另存为：管理员获得所有权.reg<br/>
文件名可以随便写，但是后缀记得写成reg（改成这个后缀后文件图标就会变成一个破碎蓝色魔方）。<br/>
然后右键以管理员身份运行，若弹框注册表xxx的，同意就行了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux将shell脚本添加到系统命令的方法]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428714021434.html"/>
    <updated>2018-11-22T15:23:22+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428714021434.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>可以自定义一些shell脚本，用来提高执行常用组合命令的效率。还有一种方式是使用alias命令。</p>
</blockquote>

<p>两种方法：<br/>
1、直接把shell脚本放到/usr/local/bin ，然后添加权限 <code>sudo chmod +x xxx.sh</code> 就ok了。这样是在本地用户添加命令。<br/>
root用户添加命令则把脚本放在 /usr/bin 即可。<br/>
2、使用软连接的方式<code>ln -s 【源文件或目录】【目标文件或目录】</code><br/>
注意要使用绝对路径。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CRLF注入]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428712896668.html"/>
    <updated>2018-11-22T15:21:29+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428712896668.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>文章翻译自OWASP的<a href="https://www.owasp.org/index.php/CRLF_Injection">CRLF_Injection</a></p>
</blockquote>

<p>CRLF即回车Carriage Return (ASCII 13, \r) 和 换行 Line Feed (ASCII 10, \n)。他们被用于注释掉一行的终止。不过不同系统的处理方式有点不同。windows中，CR和LF都被用于注释掉一行的结尾，而linux/unix中只需要一个LF。在HTTP协议中，CRLF序列始终用于一行的终止。<br/>
当用户设法将CRLF提交到应用程序时，可能发生CRLF注入攻击，这通常是通过修改HTTP参数或URL来完成。</p>

<p>CRLF注入可能产生这样的问题：</p>

<ul>
<li>HTTP响应拆分</li>
<li>日志注入<br/>
## HTTP响应拆分<br/>
通常，当出现以下情况时会发生HTTP响应拆分</li>
<li>数据通过不受信任的来源进入Web应用程序，如HTTP请求。</li>
<li>数据包含在发送给Web用户的HTTP响应标头中，而不会对恶意字符进行验证。<br/>
HTTP响应拆分是达到目的的手段而不是目的本身。<br/>
攻击方式如下：攻击者将恶意数据传递给易受攻击的应用程序，应用程序将数据包含在HTTP响应中。<br/>
要成功利用漏洞，应用程序必须允许<strong>包含有 CR（回车，即 %0d 或者 \r\n）和 LF（换行符，%0a 或者 \n）的输入在header中</strong>和<strong>底层平台必须容易注入这样的字符</strong>。</li>
</ul>

<p><em>大多数现代应用程序服务器(无论用什么语言编写的代码)，都已经不存在HTTP响应拆分漏洞。</em></p>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie(&quot;author&quot;, author);
      cookie.setMaxAge(cookieExpiration);
      response.addCookie(cookie);
</code></pre>

<p>上述代码的意思是：从客户端HTTP请求中接受参数（author），并将其设置在HTTP响应的cookie头中。<br/>
如果我们正常提交数据(author=lonelyor)，HTTP响应应该是这样：</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
</code></pre>

<p>但是，由于源代码中的cookie是由未经验证的用户输入组成的，因此如果我们提交恶意代码<code>Hacker By xxx\r\nContent-Length:45\r\n\r\n...</code>则HTTP响应将被拆分为原始响应和伪造响应。</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
    ...
    Set-Cookie: author=Hacker By xxx
    Content-Length: 999
    
    &lt;html&gt;恶意内容...&lt;/html&gt; (这个例子中为第999个字符)
    原始内容以1000开头, 现在被浏览器忽略了...
</code></pre>

<h3 id="toc_0">危害</h3>

<p>攻击者构建任意HTTP响应的能力可能导致以下攻击：<br/>
跨用户污染（Cross-User_Defacement）——利用条件很苛刻<br/>
缓存中毒（Cache_Poisoning）——利用条件很苛刻<br/>
XSS跨站脚本攻击<br/>
页面劫持</p>

<h2 id="toc_1">日志注入</h2>

<p>将未经验证的用户输入写入日志文件可能导致攻击者伪造日志或者将恶意内容注入日志。<br/>
以下情况可能导致日志伪造漏洞：</p>

<ul>
<li>数据从不受信任的来源进入应用程序</li>
<li>数据将写入应用程序或者系统日志文件</li>
</ul>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">...
String val = request.getParameter(&quot;val&quot;);
try {
  int value = Integer.parseInt(val);
}
catch (NumberFormatException) {
  log.info(&quot;Failed to parse val = &quot; + val);
}
...
</code></pre>

<p>上述代码的功能是，从请求对象中读取整数值，如果该值无法解析为整数，则会记录输入，并显示一条错误信息。<br/>
如果用户提交字符串“one”，则会记录以下条目<br/>
<code>INFO: Failed to parse val=one</code><br/>
然而，如果攻击者提交字符串<code>one%0a%0aINFO:+User+logged+out%3dbadguy</code>则会在日志中显示：</p>

<pre class="line-numbers"><code class="language-text">    INFO: Failed to parse val=one

    INFO: User logged out=badguy
</code></pre>

<p>显然攻击者可以使用相同机制插入任意日志条目。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[burpsuite设置上游代理]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428711597348.html"/>
    <updated>2018-11-22T15:19:19+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428711597348.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>burpsuite的使用技巧之一，设置上游代理。比如测试境外网站时可能需要[fanqiang]才能访问，此时这个技巧就能用得上了。</p>
</blockquote>

<p><img src="http://images.lonelyor.org/burp%E8%AE%BE%E7%BD%AE%E4%B8%8A%E6%B8%B8%E4%BB%A3%E7%90%8620180823161146.png" alt="burp设置上游代理20180823161146"/></p>

<p>1、在浏览器中设置burp代理以保证可以抓包<br/>
2、开启上游代理<br/>
3、在burp的图中所示位置设置上游代理</p>

<p>打完收工</p>

<h2 id="toc_0">参考链接</h2>

<p><a href="http://www.360zhijia.com/360anquanke/191737.html">http://www.360zhijia.com/360anquanke/191737.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更优雅的使用Hexo写博客]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428708110510.html"/>
    <updated>2018-11-22T15:13:31+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428708110510.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>曾经的博客是使用 Hexo 写的，我觉得Hexo这种在文章前面写上元信息的方式很棒。然而，每此写markdown文档都要输入这些元信息，这很麻烦，所以就写了个shell脚本来自动化输入文件元信息的过程。<br/>
代码如下：</p>
</blockquote>

<pre class="line-numbers"><code class="language-bash">#!/bin/bash

printf &quot;请输入文件名(example.md)，记得写后缀!\n&quot;
read -p &quot;文件名是: &quot; filename
# 这里的title取文件名不取后缀
echo &quot;title: &quot;${filename%.*} &gt;&gt; $filename
echo &quot;author: lonelyor&quot; &gt;&gt; $filename
echo &quot;language: zh-CN&quot; &gt;&gt; $filename
echo &quot;tags:&quot; &gt;&gt; $filename
echo &quot;  - 标签&quot; &gt;&gt; $filename
echo &quot;categories:&quot; &gt;&gt; $filename
echo &quot;  - 分类&quot; &gt;&gt; $filename
time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)
echo &quot;date: ${time}&quot;&gt;&gt; $filename
echo &quot;---&quot; &gt;&gt; $filename
echo &quot;&gt; description: &quot; &gt;&gt; $filename
# printf和echo都是输出，&gt;&gt;表示追加，&gt;会覆盖文件
# shell中使用变量需要先定义变量，然后使用时加 $
# read 用来创建文件，文件名从终端获取
</code></pre>

<p>展示效果如下:</p>

<pre class="line-numbers"><code class="language-md">title: 如何优雅的创建markdown文件
author: lonelyor
language: zh-CN
tags:
  - Hexo
  - markdown
categories:
  - 技术杂文
date: 2018-09-06 17:42:40
---
&gt; description: 若爱请深爱，若不爱请离开。
</code></pre>

<p>接下来说说如何使用(仅限linux、macos，或者说可以执行bash的环境，win用户请自行转换成bat)：<br/>
首先，创建一个名叫 md.sh 的文件（名字你爱咋咋地），把代码copy进去。<br/>
然后，<code>ln -s /md文件绝对路径 /usr/local/bin/md</code> ,这条语句的意思就是创建一个软连接，把 md.sh 连接到当前用户的 md 命令上。<br/>
最后，打开终端输入 md ，然后输入要创建的markdown文件名（如：test.md），即可在当前目录下创建带有元信息的markdown文件。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web安全检测checklist]]></title>
    <link href="www.lonelyor.org/lonelyorNotes/15428591301433.html"/>
    <updated>2018-11-22T11:58:50+08:00</updated>
    <id>www.lonelyor.org/lonelyorNotes/15428591301433.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">x01 爆破</h2>

<h3 id="toc_1">弱口令</h3>

<p>HTTP登录<br/>
SSH<br/>
MySQL<br/>
Telnet</p>

<h3 id="toc_2">遍历</h3>

<p>网站敏感文件<br/>
    源码<br/>
    配置文件<br/>
    备份文件<br/>
    探针类文件<br/>
网站敏感目录<br/>
    物理路径<br/>
    网站管理后台<br/>
    上传目录<br/>
    数据库Web管理入口<br/>
    现成的Webshell<br/>
端口扫描<br/>
0day扫描<br/>
子域名</p>

<h2 id="toc_3">x02 不安全配置</h2>

<h3 id="toc_4">Web服务器</h3>

<p>Nginx<br/>
Apache<br/>
IIS</p>

<h3 id="toc_5">Web应用服务器</h3>

<p>Tomcat<br/>
JBoss<br/>
Weblogic</p>

<h3 id="toc_6">HTTP安全特性</h3>

<p>HTTP Headers<br/>
HTTP Options<br/>
rebots.txt<br/>
flash跨域策略</p>

<h2 id="toc_7">x03 敏感信息泄露</h2>

<p>用户敏感信息<br/>
    手机号<br/>
    身份证号<br/>
    社保<br/>
    银行卡号<br/>
    家庭住址</p>

<p>应用敏感信息<br/>
    debug信息<br/>
    堆栈报错<br/>
站点敏感信息<br/>
    测试页面<br/>
    备份文件<br/>
本地敏感信息<br/>
    前端保存用户密码<br/>
    前端保存验证码</p>

<h2 id="toc_8">x04 xss跨站脚本</h2>

<p>反射型xss<br/>
存储型xss<br/>
DOM型xss</p>

<h2 id="toc_9">x05 请求伪造</h2>

<p>csrf跨站请求伪造<br/>
ssrf服务器请求伪造</p>

<h2 id="toc_10">x06 注入</h2>

<p>LDAP注入<br/>
ORM注入<br/>
XML注入<br/>
XPath注入<br/>
IMAP/SMTP注入<br/>
SQL注入<br/>
代码注入</p>

<h2 id="toc_11">x07已知漏洞组件</h2>

<p>库文件<br/>
框架<br/>
模块</p>

<h2 id="toc_12">x08 文件类漏洞</h2>

<p>文件包含漏洞<br/>
任意文件创建<br/>
任意文件读取<br/>
任意文件上传<br/>
任意文件下载<br/>
任意文件删除</p>

<h2 id="toc_13">x09 解析漏洞</h2>

<p>IIS解析漏洞<br/>
Nginx解析漏洞<br/>
Apache解析漏洞<br/>
PHP CGI解析漏洞</p>

<h2 id="toc_14">x10 劫持类漏洞</h2>

<p>点击劫持<br/>
Jsonp劫持<br/>
WebSocket劫持<br/>
DNS劫持<br/>
二维码劫持<br/>
子域名劫持</p>

<h2 id="toc_15">x11 业务逻辑漏洞</h2>

<p>认证<br/>
    使用默认凭证<br/>
    冻结账户策略不当<br/>
    弱用户名和密码<br/>
    “记住我”功能<br/>
    自动登录<br/>
    单点登录<br/>
    弱口令<br/>
    弱安全问题/答案<br/>
    第三方登录风险<br/>
    Oauth2.0安全<br/>
    JWT安全<br/>
    注册覆盖<br/>
    未验证的重定向和转发<br/>
    双因素认证不当<br/>
授权<br/>
    测试角色定义<br/>
    权限管理缺失<br/>
    匿名访问（备用接口——常见于兼容老的不安全的接口时产生）<br/>
    水平越权<br/>
    垂直越权<br/>
    超级账户<br/>
    实名认证不严格<br/>
会话管理<br/>
    cookie安全属性<br/>
    cookie可猜解<br/>
    cookie溢出<br/>
    会话固定<br/>
    用户凭证不安全传输<br/>
    用户凭证未一次失效<br/>
    用户凭证可猜解<br/>
    注销与会话超时<br/>
流程绕过<br/>
    找回密码流程绕过</p>

<h2 id="toc_16">x12 密码学安全</h2>

<p>弱加密<br/>
不安全传输</p>

<h2 id="toc_17">x13 API安全</h2>

<p>暂略</p>

]]></content>
  </entry>
  
</feed>
